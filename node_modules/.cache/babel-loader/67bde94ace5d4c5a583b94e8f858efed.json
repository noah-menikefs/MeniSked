{"ast":null,"code":"'use strict';\n/* eslint-disable space-infix-ops */\n// The precision used to consider an ellipse as a circle\n//\n\nvar epsilon = 0.0000000001; // To convert degree in radians\n//\n\nvar torad = Math.PI / 180; // Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\n\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) {\n    return new Ellipse(rx, ry, ax);\n  }\n\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n} // Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\n\n\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad),\n      s = Math.sin(this.ax * torad);\n  var ma = [this.rx * (m[0] * c + m[2] * s), this.rx * (m[1] * c + m[3] * s), this.ry * (-m[0] * s + m[2] * c), this.ry * (-m[1] * s + m[3] * c)]; // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n\n  var J = ma[0] * ma[0] + ma[2] * ma[2],\n      K = ma[1] * ma[1] + ma[3] * ma[3]; // the discriminant of the characteristic polynomial of ma * transpose(ma)\n\n  var D = ((ma[0] - ma[3]) * (ma[0] - ma[3]) + (ma[2] + ma[1]) * (ma[2] + ma[1])) * ((ma[0] + ma[3]) * (ma[0] + ma[3]) + (ma[2] - ma[1]) * (ma[2] - ma[1])); // the \"mean eigenvalue\"\n\n  var JK = (J + K) / 2; // check if the image is (almost) a circle\n\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  } // if it is not a circle\n\n\n  var L = ma[0] * ma[1] + ma[2] * ma[3];\n  D = Math.sqrt(D); // {l1,l2} = the two eigen values of ma * transpose(ma)\n\n  var l1 = JK + D / 2,\n      l2 = JK - D / 2; // the x - axis - rotation angle is the argument of the l1 - eigenvector\n\n  /*eslint-disable indent*/\n\n  this.ax = Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon ? 90 : Math.atan(Math.abs(L) > Math.abs(l1 - K) ? (l1 - J) / L : L / (l1 - K)) * 180 / Math.PI;\n  /*eslint-enable indent*/\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n}; // Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\n\n\nEllipse.prototype.isDegenerate = function () {\n  return this.rx < epsilon * this.ry || this.ry < epsilon * this.rx;\n};\n\nmodule.exports = Ellipse;","map":{"version":3,"sources":["/Users/noah.menikefs/Desktop/menisked/MeniSked/node_modules/svgpath/lib/ellipse.js"],"names":["epsilon","torad","Math","PI","Ellipse","rx","ry","ax","prototype","transform","m","c","cos","s","sin","ma","J","K","D","JK","sqrt","L","l1","l2","abs","atan","isDegenerate","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/* eslint-disable space-infix-ops */\n\n// The precision used to consider an ellipse as a circle\n//\nvar epsilon = 0.0000000001;\n\n// To convert degree in radians\n//\nvar torad = Math.PI / 180;\n\n// Class constructor :\n//  an ellipse centred at 0 with radii rx,ry and x - axis - angle ax.\n//\nfunction Ellipse(rx, ry, ax) {\n  if (!(this instanceof Ellipse)) { return new Ellipse(rx, ry, ax); }\n  this.rx = rx;\n  this.ry = ry;\n  this.ax = ax;\n}\n\n// Apply a linear transform m to the ellipse\n// m is an array representing a matrix :\n//    -         -\n//   | m[0] m[2] |\n//   | m[1] m[3] |\n//    -         -\n//\nEllipse.prototype.transform = function (m) {\n  // We consider the current ellipse as image of the unit circle\n  // by first scale(rx,ry) and then rotate(ax) ...\n  // So we apply ma =  m x rotate(ax) x scale(rx,ry) to the unit circle.\n  var c = Math.cos(this.ax * torad), s = Math.sin(this.ax * torad);\n  var ma = [\n    this.rx * (m[0]*c + m[2]*s),\n    this.rx * (m[1]*c + m[3]*s),\n    this.ry * (-m[0]*s + m[2]*c),\n    this.ry * (-m[1]*s + m[3]*c)\n  ];\n\n  // ma * transpose(ma) = [ J L ]\n  //                      [ L K ]\n  // L is calculated later (if the image is not a circle)\n  var J = ma[0]*ma[0] + ma[2]*ma[2],\n      K = ma[1]*ma[1] + ma[3]*ma[3];\n\n  // the discriminant of the characteristic polynomial of ma * transpose(ma)\n  var D = ((ma[0]-ma[3])*(ma[0]-ma[3]) + (ma[2]+ma[1])*(ma[2]+ma[1])) *\n          ((ma[0]+ma[3])*(ma[0]+ma[3]) + (ma[2]-ma[1])*(ma[2]-ma[1]));\n\n  // the \"mean eigenvalue\"\n  var JK = (J + K) / 2;\n\n  // check if the image is (almost) a circle\n  if (D < epsilon * JK) {\n    // if it is\n    this.rx = this.ry = Math.sqrt(JK);\n    this.ax = 0;\n    return this;\n  }\n\n  // if it is not a circle\n  var L = ma[0]*ma[1] + ma[2]*ma[3];\n\n  D = Math.sqrt(D);\n\n  // {l1,l2} = the two eigen values of ma * transpose(ma)\n  var l1 = JK + D/2,\n      l2 = JK - D/2;\n  // the x - axis - rotation angle is the argument of the l1 - eigenvector\n  /*eslint-disable indent*/\n  this.ax = (Math.abs(L) < epsilon && Math.abs(l1 - K) < epsilon) ?\n    90\n  :\n    Math.atan(Math.abs(L) > Math.abs(l1 - K) ?\n      (l1 - J) / L\n    :\n      L / (l1 - K)\n    ) * 180 / Math.PI;\n  /*eslint-enable indent*/\n\n  // if ax > 0 => rx = sqrt(l1), ry = sqrt(l2), else exchange axes and ax += 90\n  if (this.ax >= 0) {\n    // if ax in [0,90]\n    this.rx = Math.sqrt(l1);\n    this.ry = Math.sqrt(l2);\n  } else {\n    // if ax in ]-90,0[ => exchange axes\n    this.ax += 90;\n    this.rx = Math.sqrt(l2);\n    this.ry = Math.sqrt(l1);\n  }\n\n  return this;\n};\n\n// Check if the ellipse is (almost) degenerate, i.e. rx = 0 or ry = 0\n//\nEllipse.prototype.isDegenerate = function () {\n  return (this.rx < epsilon * this.ry || this.ry < epsilon * this.rx);\n};\n\nmodule.exports = Ellipse;\n"]},"metadata":{},"sourceType":"script"}