{"ast":null,"code":"import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _extends from '@babel/runtime/helpers/extends';\nimport React from 'react';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport BlobStream from 'blob-stream';\nimport PDFDocument, { PDFFont } from '@react-pdf/pdfkit';\nimport 'is-url';\nimport fontkit from '@react-pdf/fontkit';\nimport fetch from 'cross-fetch';\nimport { match, is, when, test, compose, cond, T, mapObjIndexed, flip, curryN, either, path, propEq, hasPath, both, tap, pathOr, o, prop, splitEvery, map, slice, split as split$1, replace, trim, identity, reduce, max as max$1, min as min$1, always, pluck, pathEq, propOr, forEach, ifElse, isNil, join, juxt, toUpper, head, tail, memoizeWith, last, evolve, concat, assoc, groupBy, defaultTo, find, complement, filter, __, pick, merge, apply, equals, anyPass, unless, sort, add, then, reject, isEmpty, converge, includes, applySpec, subtract, pathSatisfies, allPass, mergeAll, dissoc, useWith, lte, all, assocPath, dissocPath, any, reverse } from 'ramda';\nimport runWidth from '@react-pdf/textkit/run/advanceWidth';\nimport lineWidth from '@react-pdf/textkit/attributedString/advanceWidth';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\nimport arcToCurve from 'svg-arc-to-cubic-bezier';\nimport PDFRenderer from '@react-pdf/textkit/renderers/pdf';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\nimport AttributedString from '@react-pdf/textkit/attributedString';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport colorString from 'color-string';\nimport hlsToHex from 'hsl-to-hex';\nimport PNG from '@react-pdf/png-js';\nimport emojiRegex from 'emoji-regex';\nimport matchMedia from 'media-engine';\nimport Yoga from 'yoga-layout-prebuilt';\nimport ReactFiberReconciler from 'react-reconciler';\nimport { unstable_scheduleCallback, unstable_cancelCallback } from 'scheduler';\nvar VIEW = 'VIEW';\nvar TEXT = 'TEXT';\nvar LINK = 'LINK';\nvar PAGE = 'PAGE';\nvar NOTE = 'NOTE';\nvar IMAGE = 'IMAGE';\nvar DOCUMENT = 'DOCUMENT';\nvar CANVAS = 'CANVAS';\nvar TEXT_INSTANCE = 'TEXT_INSTANCE';\nvar SVG = 'SVG';\nvar GROUP = 'G';\nvar PATH = 'PATH';\nvar RECT = 'RECT';\nvar LINE = 'LINE';\nvar CIRCLE = 'CIRCLE';\nvar ELLIPSE = 'ELLIPSE';\nvar POLYGON = 'POLYGON';\nvar POLYLINE = 'POLYLINE';\nvar DEFS = 'DEFS';\nvar TSPAN = 'TSPAN';\nvar CLIP_PATH = 'CLIP_PATH';\nvar STOP = 'STOP';\nvar LINEAR_GRADIENT = 'LINEAR_GRADIENT';\nvar RADIAL_GRADIENT = 'RADIAL_GRADIENT';\nvar DPI = 72; // 72pt per inch.\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping\n\nvar FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\nvar PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n};\nvar PORTRAIT = 'portrait';\nvar LANDSCAPE = 'landscape';\nvar INHERITED_PROPERTIES = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\nvar SVG_INHERITED_PROPS = ['x', 'y', 'clipPath', 'clipRule', 'opacity', 'fill', 'fillOpacity', 'fillRule', 'stroke', 'strokeLinecap', 'strokeLinejoin', 'strokeOpacity', 'strokeWidth', 'textAnchor'].concat(INHERITED_PROPERTIES);\nvar RULER_WIDTH = 13;\nvar RULER_COLOR = 'white';\nvar RULER_FONT_SIZE = 6;\nvar DEFAULT_RULER_STEPS = 50;\nvar LINE_WIDTH = 0.5;\nvar LINE_COLOR = 'gray';\nvar GRID_COLOR = '#ababab';\nvar BOX_MODEL_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nvar OBJECT_POSITION_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nvar BORDER_SHORTHAND_REGEX = /(\\d+(px|in|mm|cm|pt|vw|vh|px)?)\\s(\\S+)\\s(\\S+)/;\nvar TRANSFORM_ORIGIN_REGEX = /(-?\\d+(px|in|mm|cm|pt|%|vw|vh|px)?)|top|right|bottom|left|center/g;\nvar matchBoxModel = match(BOX_MODEL_REGEX);\nvar matchObjectPosition = match(OBJECT_POSITION_REGEX);\nvar matchBorderShorthand = match(BORDER_SHORTHAND_REGEX);\nvar matchTransformOrigin = match(TRANSFORM_ORIGIN_REGEX);\nvar isNumber = is(Number);\n\nvar isFontWeightStyle = function isFontWeightStyle(key) {\n  return key.match(/^fontWeight/);\n};\n\nvar isBorderStyle = function isBorderStyle(key, value) {\n  return key.match(/^border(Top|Right|Bottom|Left)(Color|Width|Style)/) && typeof value === 'string';\n};\n\nvar isBoxModelStyle = function isBoxModelStyle(key, value) {\n  return key.match(/^(margin)|(padding)/) && typeof value === 'string';\n};\n\nvar isObjectPositionStyle = function isObjectPositionStyle(key, value) {\n  return key.match(/^objectPosition/) && typeof value === 'string';\n};\n\nvar isTransformOriginStyle = function isTransformOriginStyle(key, value) {\n  return key.match(/^transformOrigin/) && typeof value === 'string';\n};\n\nvar isFlexGrow = function isFlexGrow(key) {\n  return key === 'flexGrow';\n};\n\nvar isFlexShrink = function isFlexShrink(key) {\n  return key === 'flexShrink';\n};\n\nvar isFlexBasis = function isFlexBasis(key) {\n  return key === 'flexBasis';\n};\n\nvar processBorders = function processBorders(key, value) {\n  var match = matchBorderShorthand(value);\n\n  if (match) {\n    if (key.match(/Color$/)) {\n      return match[4] || value;\n    } else if (key.match(/Style$/)) {\n      return match[3] || value;\n    } else if (key.match(/Width$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar processBoxModel = function processBoxModel(key, value) {\n  var match = matchBoxModel(value);\n\n  if (match) {\n    if (key.match(/Top$/)) {\n      return match[0];\n    } else if (key.match(/Right$/)) {\n      return match[1] || match[0];\n    } else if (key.match(/Bottom$/)) {\n      return match[2] || match[0];\n    } else if (key.match(/Left$/)) {\n      return match[3] || match[1] || match[0];\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar processFontWeight = function processFontWeight(key, value) {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  return FONT_WEIGHTS[value.toLowerCase()];\n};\n\nvar processObjectPosition = function processObjectPosition(key, value) {\n  var match = matchObjectPosition(value);\n\n  if (match) {\n    if (key.match(/X$/)) {\n      return match[0] || value;\n    } else if (key.match(/Y$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar transformOffsetKeywords = function transformOffsetKeywords(value) {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n\n    case 'right':\n    case 'bottom':\n      return '100%';\n\n    case 'center':\n      return '50%';\n\n    default:\n      return value;\n  }\n}; // Transforms shorthand transformOrigin values\n\n\nvar processTransformOrigin = function processTransformOrigin(key, value) {\n  var match = matchTransformOrigin(value);\n\n  if (match) {\n    var result;\n\n    if (key.match(/X$/)) {\n      result = match[0] || value;\n    } else if (key.match(/Y$/)) {\n      result = match[1] || match[0] || value;\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n\n    return transformOffsetKeywords(result);\n  }\n\n  return value;\n};\n\nvar processFlexGrow = function processFlexGrow(key, value) {\n  if (isNumber(value)) return value;\n  var matches = value.split(' ');\n  return matches[0];\n};\n\nvar processFlexShrink = function processFlexShrink(key, value) {\n  if (isNumber(value)) return value;\n  var matches = value.split(' ');\n  return matches[1];\n};\n\nvar processFlexBasis = function processFlexBasis(key, value) {\n  if (isNumber(value)) return value;\n  var matches = value.split(' ');\n  return matches[2];\n};\n\nvar keepSame = function keepSame(key, value) {\n  return value;\n};\n\nvar matchNumber = when(is(String), test(/^-?\\d*\\.?\\d*$/));\nvar castFloat = when(matchNumber, function (v) {\n  return parseFloat(v, 10);\n});\n/**\n * Transforms style key-value\n *\n * @param {String} key style key\n * @param {String} value style value\n * @returns {String | Number} transformed style values\n */\n\nvar transformStyle = compose(castFloat, cond([[isBorderStyle, processBorders], [isBoxModelStyle, processBoxModel], [isObjectPositionStyle, processObjectPosition], [isTransformOriginStyle, processTransformOrigin], [isFontWeightStyle, processFontWeight], [isFlexGrow, processFlexGrow], [isFlexShrink, processFlexShrink], [isFlexBasis, processFlexBasis], [T, keepSame]]));\n/**\n * Transforms already expanded styles shortcuts into appropiate values\n * Ex. marginTopWidth: '2 solid red' -> marginTopWidth: 2\n *\n * @param {Object} styles expanded object\n * @returns {Object} transformed styles\n */\n\nvar transformStyles = mapObjIndexed(flip(transformStyle));\n\nvar fetchFont = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(src, options) {\n    var response, buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(src, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchFont(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar FontSource = /*#__PURE__*/function () {\n  function FontSource(src, fontFamily, fontStyle, fontWeight, options) {\n    this.src = src;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = processFontWeight(fontWeight) || 400;\n    this.data = null;\n    this.loading = false;\n    this.options = options;\n  }\n\n  var _proto = FontSource.prototype;\n\n  _proto.load = /*#__PURE__*/function () {\n    var _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var _this = this;\n\n      var _this$options, headers, body, _this$options$method, method, data;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              this.loading = true;\n              _this$options = this.options, headers = _this$options.headers, body = _this$options.body, _this$options$method = _this$options.method, method = _this$options$method === void 0 ? 'GET' : _this$options$method;\n              _context2.next = 5;\n              return fetchFont(this.src, {\n                method: method,\n                body: body,\n                headers: headers\n              });\n\n            case 5:\n              data = _context2.sent;\n              this.data = fontkit.create(data);\n              _context2.next = 12;\n              break;\n\n            case 9:\n              _context2.next = 11;\n              return new Promise(function (resolve, reject) {\n                return fontkit.open(_this.src, function (err, data) {\n                  return err ? reject(err) : resolve(data);\n                });\n              });\n\n            case 11:\n              this.data = _context2.sent;\n\n            case 12:\n              this.loading = false;\n\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function load() {\n      return _load.apply(this, arguments);\n    }\n\n    return load;\n  }();\n\n  return FontSource;\n}();\n\nvar Font = /*#__PURE__*/function () {\n  Font.create = function create(family) {\n    return new Font(family);\n  };\n\n  function Font(family) {\n    this.family = family;\n    this.sources = [];\n  }\n\n  var _proto2 = Font.prototype;\n\n  _proto2.register = function register(_ref2) {\n    var src = _ref2.src,\n        fontWeight = _ref2.fontWeight,\n        fontStyle = _ref2.fontStyle,\n        options = _objectWithoutPropertiesLoose(_ref2, [\"src\", \"fontWeight\", \"fontStyle\"]);\n\n    this.sources.push(new FontSource(src, this.fontFamily, fontStyle, fontWeight, options));\n  };\n\n  _proto2.resolve = function resolve(descriptor) {\n    var _descriptor$fontWeigh = descriptor.fontWeight,\n        fontWeight = _descriptor$fontWeigh === void 0 ? 400 : _descriptor$fontWeigh,\n        _descriptor$fontStyle = descriptor.fontStyle,\n        fontStyle = _descriptor$fontStyle === void 0 ? 'normal' : _descriptor$fontStyle;\n    var styleSources = this.sources.filter(function (s) {\n      return s.fontStyle === fontStyle;\n    }); // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n\n    var exactFit = styleSources.find(function (s) {\n      return s.fontWeight === fontWeight;\n    });\n    if (exactFit) return exactFit;\n    var res;\n\n    if (fontWeight >= 400 && fontWeight <= 500) {\n      var leftOffset = styleSources.filter(function (s) {\n        return s.fontWeight <= fontWeight;\n      });\n      var rightOffset = styleSources.filter(function (s) {\n        return s.fontWeight > 500;\n      });\n      var fit = styleSources.filter(function (s) {\n        return s.fontWeight >= fontWeight && s.fontWeight < 500;\n      });\n      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];\n    }\n\n    var lt = styleSources.filter(function (s) {\n      return s.fontWeight < fontWeight;\n    });\n    var gt = styleSources.filter(function (s) {\n      return s.fontWeight > fontWeight;\n    });\n\n    if (fontWeight < 400) {\n      res = lt[lt.length - 1] || gt[0];\n    }\n\n    if (fontWeight > 500) {\n      res = gt[0] || lt[lt.length - 1];\n    }\n\n    if (!res) {\n      throw new Error(\"Could not resolve font for \" + this.fontFamily + \", fontWeight \" + fontWeight);\n    }\n\n    return res;\n  };\n\n  return Font;\n}();\n\nvar emojiSource;\n\nvar registerEmojiSource = function registerEmojiSource(_ref) {\n  var url = _ref.url,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'png' : _ref$format;\n  emojiSource = {\n    url: url,\n    format: format\n  };\n};\n\nvar getEmojiSource = function getEmojiSource() {\n  return emojiSource;\n};\n\nvar emoji = {\n  registerEmojiSource: registerEmojiSource,\n  getEmojiSource: getEmojiSource\n};\nvar standardFonts = ['Courier', 'Courier-Bold', 'Courier-Oblique', 'Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique', 'Times-Roman', 'Times-Bold', 'Times-Italic'];\nvar hyphenationCallback;\n\nvar registerHyphenationCallback = function registerHyphenationCallback(callback) {\n  hyphenationCallback = callback;\n};\n\nvar getHyphenationCallback = function getHyphenationCallback() {\n  return hyphenationCallback;\n};\n\nvar hyphenation = {\n  registerHyphenationCallback: registerHyphenationCallback,\n  getHyphenationCallback: getHyphenationCallback\n};\nvar fonts = {};\n\nvar register = function register(data) {\n  var family = data.family;\n\n  if (!fonts[family]) {\n    fonts[family] = Font.create(family);\n  } // Bulk loading\n\n\n  if (data.fonts) {\n    for (var i = 0; i < data.fonts.length; i++) {\n      fonts[family].register(_extends({\n        family: family\n      }, data.fonts[i]));\n    }\n  } else {\n    fonts[family].register(data);\n  }\n};\n\nvar getRegisteredFonts = function getRegisteredFonts() {\n  return fonts;\n};\n\nvar getRegisteredFontFamilies = function getRegisteredFontFamilies() {\n  return Object.keys(fonts);\n};\n\nvar getFont = function getFont(descriptor) {\n  var fontFamily = descriptor.fontFamily;\n  var isStandard = standardFonts.includes(fontFamily);\n  if (isStandard) return null;\n\n  if (!fonts[fontFamily]) {\n    throw new Error(\"Font family not registered: \" + fontFamily + \". Please register it calling Font.register() method.\");\n  }\n\n  return fonts[fontFamily].resolve(descriptor);\n};\n\nvar load = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(descriptor) {\n    var fontFamily, isStandard, font;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            fontFamily = descriptor.fontFamily;\n            isStandard = standardFonts.includes(fontFamily);\n\n            if (!isStandard) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 4:\n            font = getFont(descriptor); // We cache the font to avoid fetching it many times\n\n            if (!(!font.data && !font.loading)) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.next = 8;\n            return font.load();\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function load(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar reset = function reset() {\n  for (var _font in fonts) {\n    if (fonts.hasOwnProperty(_font)) {\n      fonts[_font].data = null;\n    }\n  }\n};\n\nvar clear = function clear() {\n  fonts = {};\n};\n\nvar Font$1 = _extends({\n  register: register,\n  getRegisteredFonts: getRegisteredFonts,\n  getRegisteredFontFamilies: getRegisteredFontFamilies,\n  getFont: getFont,\n  load: load,\n  clear: clear,\n  reset: reset\n}, emoji, hyphenation);\n\nvar save = function save(ctx, node) {\n  ctx.save();\n  return node;\n};\n\nvar save$1 = curryN(2, save);\nvar PROTOCOL_REGEXP = /^([a-z]+\\:(\\/\\/)?)/i;\nvar DEST_REGEXP = /^#.+/;\n/**\n * Add protocol th URL if valid\n *\n * @param {String} value url\n * @returns {String} corrected url\n */\n\nvar getURL = function getURL(value) {\n  if (!value) return '';\n  if (isSrcId(value)) return value; // don't modify it if it is an id\n\n  if (typeof value === 'string' && !value.match(PROTOCOL_REGEXP)) {\n    return \"http://\" + value;\n  }\n\n  return value;\n};\n\nvar isSrcId = function isSrcId(src) {\n  return src.match(DEST_REGEXP);\n};\n\nvar DEST_REGEXP$1 = /^#.+/;\nvar isSrcId$1 = test(DEST_REGEXP$1);\nvar getSource = compose(either(path(['props', 'src']), path(['props', 'href'])));\n\nvar setLink = function setLink(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left,\n      width = _node$box.width,\n      height = _node$box.height;\n  var src = getSource(node);\n  var instanceMethod = isSrcId$1(src) ? 'goTo' : 'link';\n  var value = isSrcId$1(src) ? src.slice(1) : getURL(src);\n\n  if (value) {\n    ctx[instanceMethod](left, top, width, height, value);\n  }\n\n  return node;\n};\n\nvar setLink$1 = curryN(2, setLink);\n\nvar restore = function restore(ctx, node) {\n  ctx.restore();\n  return node;\n};\n\nvar restore$1 = curryN(2, restore);\n/**\n * Checks if node is svg\n *\n * @param {Object} node\n * @returns {Boolean} is node svg?\n */\n\nvar isSvg = propEq('type', SVG);\n/**\n * Checks if node is text\n *\n * @param {Object} node\n * @returns {Boolean} is node text?\n */\n\nvar isText = propEq('type', TEXT);\n/**\n * Checks if node is page\n *\n * @param {Object} node\n * @returns {Boolean} is node page?\n */\n\nvar isPage = propEq('type', PAGE);\n/**\n * Checks if node has valid source prop\n *\n * @param {Object} node\n * @returns {Boolean} does node have source prop?\n */\n\nvar hasSource = either(hasPath(['props', 'src']), hasPath(['props', 'href']));\n/**\n * Checks if node is link\n *\n * @param {Object} node\n * @returns {Boolean} is node link?\n */\n\nvar isLink = either(propEq('type', LINK), both(propEq('type', TEXT), hasSource));\n/**\n * Checks if node is note\n *\n * @param {Object} node\n * @returns {Boolean} is node note?\n */\n\nvar isNote = propEq('type', NOTE);\n/**\n * Checks if node is image\n *\n * @param {Object} node\n * @returns {Boolean} is node image?\n */\n\nvar isImage = propEq('type', IMAGE);\n/**\n * Checks if node is canvas\n *\n * @param {Object} node\n * @returns {Boolean} is node canvas?\n */\n\nvar isCanvas = propEq('type', CANVAS); // Bezier curve.\n\nvar KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar clipNode = function clipNode(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left,\n      width = _node$box.width,\n      height = _node$box.height;\n  var _node$style = node.style,\n      _node$style$borderTop = _node$style.borderTopLeftRadius,\n      borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop,\n      _node$style$borderTop2 = _node$style.borderTopRightRadius,\n      borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2,\n      _node$style$borderBot = _node$style.borderBottomRightRadius,\n      borderBottomRightRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot,\n      _node$style$borderBot2 = _node$style.borderBottomLeftRadius,\n      borderBottomLeftRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2; // Border top\n\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var ctr = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr); // Border right\n\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var cbr = rbr * (1.0 - KAPPA);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height); // Border bottom\n\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  var cbl = rbl * (1.0 - KAPPA);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl); // Border left\n\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var ctl = rtl * (1.0 - KAPPA);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n  return node;\n};\n\nvar clipNode$1 = curryN(2, clipNode);\n\nvar renderPath = function renderPath(ctx) {\n  return tap(function (node) {\n    var d = path(['props', 'd'], node);\n    if (d) ctx.path(node.props.d);\n  });\n};\n\nvar KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar getProp = function getProp(d, p, v) {\n  return pathOr(d, ['props', p], v);\n};\n\nvar renderRect = function renderRect(ctx) {\n  return function (node) {\n    var x = getProp(0, 'x', node);\n    var y = getProp(0, 'y', node);\n    var rx = getProp(0, 'rx', node);\n    var ry = getProp(0, 'ry', node);\n    var width = getProp(0, 'width', node);\n    var height = getProp(0, 'height', node);\n    if (!width || !height) return node;\n\n    if (rx && ry) {\n      var krx = rx * KAPPA$1;\n      var kry = ry * KAPPA$1;\n      ctx.moveTo(x + rx, y);\n      ctx.lineTo(x - rx + width, y);\n      ctx.bezierCurveTo(x - rx + width + krx, y, x + width, y + ry - kry, x + width, y + ry);\n      ctx.lineTo(x + width, y + height - ry);\n      ctx.bezierCurveTo(x + width, y + height - ry + kry, x - rx + width + krx, y + height, x - rx + width, y + height);\n      ctx.lineTo(x + rx, y + height);\n      ctx.bezierCurveTo(x + rx - krx, y + height, x, y + height - ry + kry, x, y + height - ry);\n      ctx.lineTo(x, y + ry);\n      ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n    } else {\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + width, y);\n      ctx.lineTo(x + width, y + height);\n      ctx.lineTo(x, y + height);\n    }\n\n    ctx.closePath();\n    return node;\n  };\n};\n\nvar getProp$1 = function getProp(p, v) {\n  return path(['props', p], v);\n};\n\nvar renderLine = function renderLine(ctx) {\n  return function (node) {\n    var x1 = getProp$1('x1', node);\n    var y1 = getProp$1('y1', node);\n    var x2 = getProp$1('x2', node);\n    var y2 = getProp$1('y2', node);\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    return node;\n  };\n};\n\nvar KAPPA$2 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar getProp$2 = function getProp(p, v) {\n  return path(['props', p], v);\n};\n\nvar drawEllipse = function drawEllipse(ctx, cx, cy, rx, ry) {\n  var x = cx - rx;\n  var y = cy - ry;\n  var ox = rx * KAPPA$2;\n  var oy = ry * KAPPA$2;\n  var xe = x + rx * 2;\n  var ye = y + ry * 2;\n  var xm = x + rx;\n  var ym = y + ry;\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\n\nvar renderEllipse = function renderEllipse(ctx) {\n  return tap(function (node) {\n    var cx = getProp$2('cx', node);\n    var cy = getProp$2('cy', node);\n    var rx = getProp$2('rx', node);\n    var ry = getProp$2('ry', node);\n    drawEllipse(ctx, cx, cy, rx, ry);\n  });\n};\n\nvar getProp$3 = function getProp(p, v) {\n  return path(['props', p], v);\n};\n\nvar renderCircle = function renderCircle(ctx) {\n  return tap(function (node) {\n    var cx = getProp$3('cx', node);\n    var cy = getProp$3('cy', node);\n    var r = getProp$3('r', node);\n    drawEllipse(ctx, cx, cy, r, r);\n  });\n};\n\nvar renderRun = function renderRun(ctx, run) {\n  var runAdvanceWidth = runWidth(run);\n  var _run$attributes = run.attributes,\n      font = _run$attributes.font,\n      fontSize = _run$attributes.fontSize,\n      color = _run$attributes.color,\n      opacity = _run$attributes.opacity;\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n\n  if (font.sbix || font.COLR && font.CPAL) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n\n    for (var i = 0; i < run.glyphs.length; i++) {\n      var position = run.positions[i];\n      var glyph = run.glyphs[i];\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n      glyph.render(ctx, fontSize);\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n    try {\n      ctx._addGlyphs(run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nvar renderSpan = function renderSpan(ctx, line, textAnchor) {\n  ctx.save();\n  var x = pathOr(0, ['box', 'x'], line);\n  var y = pathOr(0, ['box', 'y'], line);\n  var width = lineWidth(line);\n\n  switch (textAnchor) {\n    case 'middle':\n      ctx.translate(x - width / 2, y);\n      break;\n\n    case 'end':\n      ctx.translate(x - width, y);\n      break;\n\n    default:\n      ctx.translate(x, y);\n      break;\n  }\n\n  for (var _iterator = line.runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n    renderRun(ctx, run);\n  }\n\n  ctx.restore();\n};\n\nvar renderSvgText = function renderSvgText(ctx) {\n  return function (node) {\n    for (var _iterator2 = node.children, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var span = _ref2;\n      renderSpan(ctx, span.lines[0], span.props.textAnchor);\n    }\n\n    return node;\n  };\n};\n\nvar isOdd = function isOdd(x) {\n  return x % 2 !== 0;\n};\n\nvar lengthIsOdd = o(isOdd, prop('length'));\nvar parsePoints = compose(splitEvery(2), map(parseFloat), when(lengthIsOdd, slice(0, -1)), split$1(/\\s+/), replace(/(\\d)-(\\d)/g, '$1 -$2'), replace(/,/g, ' '), trim);\n\nvar drawPolyline = function drawPolyline(ctx) {\n  return function (points) {\n    if (points.length > 0) {\n      ctx.moveTo(points[0][0], points[0][1]);\n      points.slice(1).forEach(function (p) {\n        return ctx.lineTo(p[0], p[1]);\n      });\n    }\n  };\n};\n\nvar renderPolyline = function renderPolyline(ctx) {\n  return tap(compose(drawPolyline(ctx), parsePoints, pathOr('', ['props', 'points'])));\n};\n\nvar closePath = function closePath(ctx) {\n  return tap(function () {\n    return ctx.closePath();\n  });\n};\n\nvar renderPolygon = function renderPolygon(ctx) {\n  return compose(closePath(ctx), renderPolyline(ctx));\n};\n\nfunction printWarning(format) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var argIndex = 0;\n  var message = 'Warning: ' + format.replace(/%s/g, function () {\n    return args[argIndex++];\n  });\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n}\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = __DEV__ ? function (condition, format) {\n  if (format === undefined) {\n    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n  }\n\n  if (!condition) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    printWarning.apply(void 0, [format].concat(args));\n  }\n} : function () {};\n\nvar drawImage = function drawImage(ctx) {\n  return function (node) {\n    var _node$props = node.props,\n        x = _node$props.x,\n        y = _node$props.y;\n    var _node$style = node.style,\n        width = _node$style.width,\n        height = _node$style.height,\n        opacity = _node$style.opacity;\n    var paddingTop = node.box.paddingLeft || 0;\n    var paddingLeft = node.box.paddingLeft || 0;\n\n    if (node.image.data) {\n      if (width !== 0 && height !== 0) {\n        ctx.fillOpacity(opacity || 1).image(node.image.data, x + paddingLeft, y + paddingTop, {\n          width: width,\n          height: height\n        });\n      } else {\n        warning(false, \"Image with src '\" + node.props.href + \"' skipped due to invalid dimensions\");\n      }\n    }\n\n    return node;\n  };\n};\n\nvar renderImage = function renderImage(ctx, node) {\n  compose(restore$1(ctx), drawImage(ctx), save$1(ctx))(node);\n  return node;\n};\n\nvar renderSvgImage = curryN(2, renderImage);\n\nvar getRotation = function getRotation(transform) {\n  var match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    var value = match[1];\n    return match[2] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nvar getTranslateX = function getTranslateX(transform) {\n  var matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nvar getTranslateY = function getTranslateY(transform) {\n  var matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n  return 0;\n};\n\nvar getScaleX = function getScaleX(transform) {\n  var matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nvar getScaleY = function getScaleY(transform) {\n  var matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nvar getMatrix = function getMatrix(transform) {\n  var match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), {\n      origin: origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, {\n      origin: origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, {\n      origin: origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform.apply(ctx, getMatrix(transform));\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  if (!node.origin) return node;\n  var match;\n  var re = /[a-zA-Z]+\\([^)]+\\)/g;\n  var origin = [node.origin.left, node.origin.top];\n  var transform = node.style && node.style.transform || node.props && node.props.transform || '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nvar applyTransformations$1 = curryN(2, applyTransformations);\n/**\n * Checks if node is path\n *\n * @param {Object} node\n * @returns {Boolean} is node path?\n */\n\nvar isPath = propEq('type', PATH);\n/**\n * Checks if node is rect\n *\n * @param {Object} node\n * @returns {Boolean} is node rect?\n */\n\nvar isRect = propEq('type', RECT);\n/**\n * Checks if node is line\n *\n * @param {Object} node\n * @returns {Boolean} is node line?\n */\n\nvar isLine = propEq('type', LINE);\n/**\n * Checks if node is tspan\n *\n * @param {Object} node\n * @returns {Boolean} is node tspan?\n */\n\nvar isTspan = propEq('type', TSPAN);\n/**\n * Checks if node is group\n *\n * @param {Object} node\n * @returns {Boolean} is node group?\n */\n\nvar isGroup = propEq('type', GROUP);\n/**\n * Checks if node is circle\n *\n * @param {Object} node\n * @returns {Boolean} is node circle?\n */\n\nvar isCircle = propEq('type', CIRCLE);\n/**\n * Checks if node is text intance\n *\n * @param {Object} node\n * @returns {Boolean} is node text intance?\n */\n\nvar isTextInstance = propEq('type', TEXT_INSTANCE);\n\nvar renderGroup = function renderGroup() {\n  return identity;\n};\n/**\n * Checks if node is ellipse\n *\n * @param {Object} node\n * @returns {Boolean} is node ellipse?\n */\n\n\nvar isEllipse = propEq('type', ELLIPSE);\n/**\n * Checks if node is polygon\n *\n * @param {Object} node\n * @returns {Boolean} is node polygon?\n */\n\nvar isPolygon = propEq('type', POLYGON);\n/**\n * Checks if node is polyline\n *\n * @param {Object} node\n * @returns {Boolean} is node polyline?\n */\n\nvar isPolyline = propEq('type', POLYLINE); // Copied here because an import issue with 'svg-arc-to-cubic-bezier'\n\nvar normalizePath = function normalizePath(path) {\n  var result = [];\n  var prev;\n  var bezierX = 0;\n  var bezierY = 0;\n  var startX = 0;\n  var startY = 0;\n  var quadX = null;\n  var quadY = null;\n  var x = 0;\n  var y = 0;\n\n  for (var i = 0, len = path.length; i < len; i++) {\n    var seg = path[i];\n    var command = seg[0];\n\n    switch (command) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n\n      case 'A':\n        var curves = arcToCurve({\n          px: x,\n          py: y,\n          cx: seg[6],\n          cy: seg[7],\n          rx: seg[1],\n          ry: seg[2],\n          xAxisRotation: seg[3],\n          largeArcFlag: seg[4],\n          sweepFlag: seg[5]\n        }); // null-curves\n\n        if (!curves.length) continue;\n\n        for (var j = 0, c; j < curves.length; j++) {\n          c = curves[j];\n          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];\n          if (j < curves.length - 1) result.push(seg);\n        }\n\n        break;\n\n      case 'S':\n        // default control point\n        var cx = x;\n        var cy = y;\n\n        if (prev === 'C' || prev === 'S') {\n          cx += cx - bezierX; // reflect the previous command's control\n\n          cy += cy - bezierY; // point relative to the current point\n        }\n\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        break;\n\n      case 'T':\n        if (prev === 'Q' || prev === 'T') {\n          quadX = x * 2 - quadX; // as with 'S' reflect previous control point\n\n          quadY = y * 2 - quadY;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);\n        break;\n\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);\n        break;\n\n      case 'L':\n        seg = line(x, y, seg[1], seg[2]);\n        break;\n\n      case 'H':\n        seg = line(x, y, seg[1], y);\n        break;\n\n      case 'V':\n        seg = line(x, y, x, seg[1]);\n        break;\n\n      case 'Z':\n        seg = line(x, y, startX, startY);\n        break;\n\n      default:\n        break;\n    } // update state\n\n\n    prev = command;\n    x = seg[seg.length - 2];\n    y = seg[seg.length - 1];\n\n    if (seg.length > 4) {\n      bezierX = seg[seg.length - 4];\n      bezierY = seg[seg.length - 3];\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n\n    result.push(seg);\n  }\n\n  return result;\n};\n\nvar line = function line(x1, y1, x2, y2) {\n  return ['C', x1, y1, x2, y2, x2, y2];\n};\n\nvar quadratic = function quadratic(x1, y1, cx, cy, x2, y2) {\n  return ['C', x1 / 3 + 2 / 3 * cx, y1 / 3 + 2 / 3 * cy, x2 / 3 + 2 / 3 * cx, y2 / 3 + 2 / 3 * cy, x2, y2];\n};\n\nvar getPathBoundingBox = function getPathBoundingBox(node) {\n  var path = compose(normalizePath, absPath, parsePath, pathOr('', ['props', 'd']))(node);\n  if (!path.length) return [0, 0, 0, 0];\n  var bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (var i = 0, l = path.length; i < l; i++) {\n    var points = path[i].slice(1);\n\n    for (var j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n};\n\nvar getCircleBoundingBox = function getCircleBoundingBox(node) {\n  var r = pathOr(0, ['props', 'r'], node);\n  var cx = pathOr(0, ['props', 'cx'], node);\n  var cy = pathOr(0, ['props', 'cy'], node);\n  return [cx - r, cy - r, cx + r, cy + r];\n};\n\nvar getEllipseBoundingBox = function getEllipseBoundingBox(node) {\n  var cx = pathOr(0, ['props', 'cx'], node);\n  var cy = pathOr(0, ['props', 'cy'], node);\n  var rx = pathOr(0, ['props', 'rx'], node);\n  var ry = pathOr(0, ['props', 'ry'], node);\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\n\nvar getLineBoundingBox = function getLineBoundingBox(node) {\n  var x1 = pathOr(0, ['props', 'x1'], node);\n  var y1 = pathOr(0, ['props', 'y1'], node);\n  var x2 = pathOr(0, ['props', 'x2'], node);\n  var y2 = pathOr(0, ['props', 'y2'], node);\n  return [min$1(x1, x2), min$1(y1, y2), max$1(x1, x2), max$1(y1, y2)];\n};\n\nvar getRectBoundingBox = function getRectBoundingBox(node) {\n  var x = pathOr(0, ['props', 'x'], node);\n  var y = pathOr(0, ['props', 'y'], node);\n  var width = pathOr(0, ['props', 'width'], node);\n  var height = pathOr(0, ['props', 'height'], node);\n  return [x, y, x + width, y + height];\n};\n\nvar max = reduce(max$1, -Infinity);\nvar min = reduce(min$1, Infinity);\n\nvar getPolylineBoundingBox = function getPolylineBoundingBox(node) {\n  var points = compose(parsePoints, pathOr([], ['props', 'points']))(node);\n  var xValues = pluck(0, points);\n  var yValues = pluck(1, points);\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\n\nvar getBoundingBox = cond([[isRect, getRectBoundingBox], [isLine, getLineBoundingBox], [isPath, getPathBoundingBox], [isCircle, getCircleBoundingBox], [isEllipse, getEllipseBoundingBox], [isPolygon, getPolylineBoundingBox], [isPolyline, getPolylineBoundingBox], [T, always([0, 0, 0, 0])]]);\nvar warnUnsupportedNode = tap(function (node) {\n  console.warn(\"SVG node of type \" + node.type + \" is not currenty supported\");\n});\n\nvar getProp$4 = function getProp(d, p, v) {\n  return pathOr(d, ['props', p], v);\n};\n\nvar setStrokeWidth = function setStrokeWidth(ctx) {\n  return function (node) {\n    var lineWidth = getProp$4(0, 'strokeWidth', node);\n    if (lineWidth) ctx.lineWidth(lineWidth);\n    return node;\n  };\n};\n\nvar setStrokeColor = function setStrokeColor(ctx) {\n  return function (node) {\n    var strokeColor = getProp$4(null, 'stroke', node);\n    if (strokeColor) ctx.strokeColor(strokeColor);\n    return node;\n  };\n};\n\nvar setOpacity = function setOpacity(ctx) {\n  return function (node) {\n    var opacity = getProp$4(null, 'opacity', node);\n    if (opacity) ctx.opacity(opacity);\n    return node;\n  };\n};\n\nvar setFillOpacity = function setFillOpacity(ctx) {\n  return function (node) {\n    var fillOpacity = getProp$4(null, 'fillOpacity', node);\n    if (fillOpacity) ctx.fillOpacity(fillOpacity);\n    return node;\n  };\n};\n\nvar setStrokeOpacity = function setStrokeOpacity(ctx) {\n  return function (node) {\n    var strokeOpacity = getProp$4(null, 'strokeOpacity', node);\n    if (strokeOpacity) ctx.strokeOpacity(strokeOpacity);\n    return node;\n  };\n};\n\nvar setLineJoin = function setLineJoin(ctx) {\n  return function (node) {\n    var lineJoin = getProp$4(null, 'strokeLinejoin', node);\n    if (lineJoin) ctx.lineJoin(lineJoin);\n    return node;\n  };\n};\n\nvar setLineCap = function setLineCap(ctx) {\n  return function (node) {\n    var lineCap = getProp$4(null, 'strokeLinecap', node);\n    if (lineCap) ctx.lineCap(lineCap);\n    return node;\n  };\n};\n\nvar setLineDash = function setLineDash(ctx) {\n  return function (node) {\n    var value = getProp$4(null, 'strokeDasharray', node);\n\n    if (value) {\n      var dashArray = compose(map(o(parseFloat, trim)), split$1(','))(value);\n      ctx.dash(dashArray[0], {\n        space: dashArray[1]\n      });\n    }\n\n    return node;\n  };\n};\n\nvar hasLinearGradientFill = pathEq(['props', 'fill', 'type'], LINEAR_GRADIENT);\nvar hasRadialGradientFill = pathEq(['props', 'fill', 'type'], RADIAL_GRADIENT); // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\n\nvar setLinearGradientFill = function setLinearGradientFill(ctx) {\n  return tap(function (node) {\n    var bbox = getBoundingBox(node);\n    var gradient = getProp$4(null, 'fill', node);\n    var x1 = pathOr(0, ['props', 'x1'], gradient);\n    var y1 = pathOr(0, ['props', 'y1'], gradient);\n    var x2 = pathOr(1, ['props', 'x2'], gradient);\n    var y2 = pathOr(0, ['props', 'y2'], gradient);\n    var m0 = bbox[2] - bbox[0];\n    var m3 = bbox[3] - bbox[1];\n    var m4 = bbox[0];\n    var m5 = bbox[1];\n    var gx1 = m0 * x1 + m4;\n    var gy1 = m3 * y1 + m5;\n    var gx2 = m0 * x2 + m4;\n    var gy2 = m3 * y2 + m5;\n    var grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n    gradient.children.forEach(function (stop) {\n      grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n  });\n}; // Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\n\n\nvar setRadialGradientFill = function setRadialGradientFill(ctx) {\n  return tap(function (node) {\n    var bbox = getBoundingBox(node);\n    var gradient = getProp$4(null, 'fill', node);\n    var cx = pathOr(0.5, ['props', 'cx'], gradient);\n    var cy = pathOr(0.5, ['props', 'cy'], gradient);\n    var fx = pathOr(cx, ['props', 'fx'], gradient);\n    var fy = pathOr(cy, ['props', 'fy'], gradient);\n    var r = pathOr(0.5, ['props', 'r'], gradient);\n    var m0 = bbox[2] - bbox[0];\n    var m3 = bbox[3] - bbox[1];\n    var m4 = bbox[0];\n    var m5 = bbox[1];\n    var gr = r * m0;\n    var gcx = m0 * cx + m4;\n    var gcy = m3 * cy + m5;\n    var gfx = m0 * fx + m4;\n    var gfy = m3 * fy + m5;\n    var grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n    gradient.children.forEach(function (stop) {\n      grad.stop(stop.props.offset, stop.props.stopColor, stop.props.stopOpacity);\n    });\n    ctx.fill(grad);\n  });\n};\n\nvar setFillColor = function setFillColor(ctx) {\n  return tap(function (node) {\n    var fillColor = getProp$4(null, 'fill', node);\n    if (fillColor) ctx.fillColor(fillColor);\n  });\n};\n\nvar setFill = function setFill(ctx) {\n  return cond([[hasLinearGradientFill, setLinearGradientFill(ctx)], [hasRadialGradientFill, setRadialGradientFill(ctx)], [T, setFillColor(ctx)]]);\n};\n\nvar draw = function draw(ctx) {\n  return function (node) {\n    var props = propOr({}, 'props', node);\n\n    if (props.fill && props.stroke) {\n      ctx.fillAndStroke(props.fillRule);\n    } else if (props.fill) {\n      ctx.fill(props.fillRule);\n    } else if (props.stroke) {\n      ctx.stroke();\n    } else {\n      ctx.save();\n      ctx.opacity(0);\n      ctx.fill(null);\n      ctx.restore();\n    }\n\n    return node;\n  };\n};\n\nvar renderNode = function renderNode(ctx) {\n  return cond([[isTspan, identity], [isTextInstance, identity], [isPath, renderPath(ctx)], [isRect, renderRect(ctx)], [isLine, renderLine(ctx)], [isGroup, renderGroup(ctx)], [isText, renderSvgText(ctx)], [isCircle, renderCircle(ctx)], [isImage, renderSvgImage(ctx)], [isEllipse, renderEllipse(ctx)], [isPolygon, renderPolygon(ctx)], [isPolyline, renderPolyline(ctx)], [T, warnUnsupportedNode]]);\n};\n\nvar drawNode = function drawNode(ctx) {\n  return compose(draw(ctx), renderNode(ctx), applyTransformations$1(ctx), setOpacity(ctx), setFillOpacity(ctx), setStrokeOpacity(ctx), setFill(ctx), setStrokeColor(ctx), setStrokeWidth(ctx), setLineJoin(ctx), setLineDash(ctx), setLineCap(ctx));\n};\n\nvar clipPath = function clipPath(ctx) {\n  return function (node) {\n    var value = path(['props', 'clipPath'], node);\n\n    if (value) {\n      compose(function () {\n        return ctx.clip();\n      }, forEach(renderNode(ctx)), propOr([], 'children'))(value);\n    }\n\n    return node;\n  };\n};\n\nvar drawChildren = function drawChildren(ctx) {\n  return function (node) {\n    return compose(map(compose(restore$1(ctx), drawChildren(ctx), drawNode(ctx), clipPath(ctx), save$1(ctx))), propOr([], 'children'))(node);\n  };\n};\n\nvar defaultsZero = pathOr(0);\n\nvar preserveAspectRatio = function preserveAspectRatio(ctx) {\n  return function (node) {\n    var _node$box = node.box,\n        width = _node$box.width,\n        height = _node$box.height;\n    var _node$props = node.props,\n        viewBox = _node$props.viewBox,\n        _node$props$preserveA = _node$props.preserveAspectRatio,\n        preserveAspectRatio = _node$props$preserveA === void 0 ? {} : _node$props$preserveA;\n    var _preserveAspectRatio$ = preserveAspectRatio.meetOrSlice,\n        meetOrSlice = _preserveAspectRatio$ === void 0 ? 'meet' : _preserveAspectRatio$,\n        _preserveAspectRatio$2 = preserveAspectRatio.align,\n        align = _preserveAspectRatio$2 === void 0 ? 'xMidYMid' : _preserveAspectRatio$2;\n    if (viewBox == null || width == null || height == null) return node;\n    var x = viewBox ? viewBox.minX : 0;\n    var y = viewBox ? viewBox.minY : 0;\n    var logicalWidth = viewBox ? viewBox.maxX : width;\n    var logicalHeight = viewBox ? viewBox.maxY : height;\n    var logicalRatio = logicalWidth / logicalHeight;\n    var physicalRatio = width / height;\n    var scaleX = width / logicalWidth;\n    var scaleY = height / logicalHeight;\n\n    if (align === 'none') {\n      ctx.scale(scaleX, scaleY);\n      ctx.translate(-x, -y);\n      return node;\n    }\n\n    if (logicalRatio < physicalRatio && meetOrSlice === 'meet' || logicalRatio >= physicalRatio && meetOrSlice === 'slice') {\n      ctx.scale(scaleY, scaleY);\n\n      switch (align) {\n        case 'xMinYMin':\n        case 'xMinYMid':\n        case 'xMinYMax':\n          ctx.translate(-x, -y);\n          break;\n\n        case 'xMidYMin':\n        case 'xMidYMid':\n        case 'xMidYMax':\n          ctx.translate(-x - (logicalWidth - width * logicalHeight / height) / 2, -y);\n          break;\n\n        default:\n          ctx.translate(-x - (logicalWidth - width * logicalHeight / height), -y);\n      }\n    } else {\n      ctx.scale(scaleX, scaleX);\n\n      switch (align) {\n        case 'xMinYMin':\n        case 'xMidYMin':\n        case 'xMaxYMin':\n          ctx.translate(-x, -y);\n          break;\n\n        case 'xMinYMid':\n        case 'xMidYMid':\n        case 'xMaxYMid':\n          ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width) / 2);\n          break;\n\n        default:\n          ctx.translate(-x, -y - (logicalHeight - height * logicalWidth / width));\n      }\n    }\n\n    return node;\n  };\n};\n\nvar moveToOrigin = function moveToOrigin(ctx) {\n  return function (node) {\n    var _node$box2 = node.box,\n        top = _node$box2.top,\n        left = _node$box2.left;\n    var paddingLeft = defaultsZero('paddingLeft', node.box);\n    var paddingTop = defaultsZero('paddingTop', node.box);\n    ctx.translate(left + paddingLeft, top + paddingTop);\n    return node;\n  };\n};\n\nvar renderSvg = function renderSvg(ctx, node) {\n  compose(restore$1(ctx), drawChildren(ctx), preserveAspectRatio(ctx), moveToOrigin(ctx), clipNode$1(ctx), save$1(ctx))(node);\n  return node;\n};\n\nvar renderSvg$1 = curryN(2, renderSvg);\n\nvar renderText = function renderText(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left;\n  var paddingTop = pathOr(0, ['box', 'paddingTop'], node);\n  var paddingLeft = pathOr(0, ['box', 'paddingLeft'], node);\n  var initialY = node.lines[0] ? node.lines[0].box.y : 0;\n  ctx.save();\n  ctx.translate(left + paddingLeft, top + paddingTop - initialY);\n  PDFRenderer.render(ctx, [node.lines]);\n  ctx.restore();\n  return node;\n};\n\nvar renderText$1 = curryN(2, renderText);\n\nvar renderPage = function renderPage(ctx, node) {\n  var _node$box = node.box,\n      width = _node$box.width,\n      height = _node$box.height;\n  ctx.addPage({\n    size: [width, height],\n    margin: 0\n  });\n  return node;\n};\n\nvar renderPage$1 = curryN(2, renderPage);\n\nvar renderNote = function renderNote(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left;\n  var value = node.children[0] ? node.children[0].value : '';\n  ctx.note(left, top, 0, 0, value);\n  return node;\n};\n\nvar renderNote$1 = curryN(2, renderNote);\n\nvar isPercent = function isPercent(value) {\n  return /((-)?\\d+\\.?\\d*)%/g.exec(value);\n};\n/**\n * Get percentage value of input\n *\n * @param {String} value\n * @returns {Object} percent value (if matches)\n */\n\n\nvar matchPercent = function matchPercent(value) {\n  var match = isPercent(value);\n\n  if (match) {\n    var _value = parseFloat(match[1], 10);\n\n    var percent = _value / 100;\n    return {\n      value: _value,\n      percent: percent,\n      absValue: Math.abs(_value),\n      absPercent: Math.abs(percent)\n    };\n  }\n\n  return null;\n};\n\nvar isNumeric = function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nvar applyContainObjectFit = function applyContainObjectFit(cw, ch, iw, ih, px, py) {\n  var cr = cw / ch;\n  var ir = iw / ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    var height = ch;\n    var width = height * ir;\n    var yOffset = isNumeric(py) ? py : 0;\n    var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width: width,\n      height: height,\n      xOffset: xOffset,\n      yOffset: yOffset\n    };\n  } else {\n    var _width = cw;\n\n    var _height = _width / ir;\n\n    var _xOffset = isNumeric(px) ? px : 0;\n\n    var _yOffset = isNumeric(py) ? py : (ch - _height) * pyv;\n\n    return {\n      width: _width,\n      height: _height,\n      yOffset: _yOffset,\n      xOffset: _xOffset\n    };\n  }\n};\n\nvar applyNoneObjectFit = function applyNoneObjectFit(cw, ch, iw, ih, px, py) {\n  var width = iw;\n  var height = ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n  var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width: width,\n    height: height,\n    xOffset: xOffset,\n    yOffset: yOffset\n  };\n};\n\nvar applyCoverObjectFit = function applyCoverObjectFit(cw, ch, iw, ih, px, py) {\n  var ir = iw / ih;\n  var cr = cw / ch;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    var width = cw;\n    var height = width / ir;\n    var xOffset = isNumeric(px) ? px : 0;\n    var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width: width,\n      height: height,\n      yOffset: yOffset,\n      xOffset: xOffset\n    };\n  } else {\n    var _height2 = ch;\n\n    var _width2 = _height2 * ir;\n\n    var _xOffset2 = isNumeric(px) ? px : (cw - _width2) * pxv;\n\n    var _yOffset2 = isNumeric(py) ? py : 0;\n\n    return {\n      width: _width2,\n      height: _height2,\n      xOffset: _xOffset2,\n      yOffset: _yOffset2\n    };\n  }\n};\n\nvar applyScaleDownObjectFit = function applyScaleDownObjectFit(cw, ch, iw, ih, px, py) {\n  var containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  var noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\n\nvar applyFillObjectFit = function applyFillObjectFit(cw, ch, px, py) {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\n\nvar resolveObjectFit = function resolveObjectFit(type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nvar drawImage$1 = function drawImage(ctx) {\n  return function (node) {\n    var _node$box = node.box,\n        left = _node$box.left,\n        top = _node$box.top;\n    var _node$style = node.style,\n        opacity = _node$style.opacity,\n        objectPositionX = _node$style.objectPositionX,\n        objectPositionY = _node$style.objectPositionY;\n    var paddingTop = node.box.paddingLeft || 0;\n    var paddingRight = node.box.paddingRight || 0;\n    var paddingBottom = node.box.paddingBottom || 0;\n    var paddingLeft = node.box.paddingLeft || 0;\n\n    var _resolveObjectFit = resolveObjectFit(node.style.objectFit, node.box.width - paddingLeft - paddingRight, node.box.height - paddingTop - paddingBottom, node.image.width, node.image.height, objectPositionX, objectPositionY),\n        width = _resolveObjectFit.width,\n        height = _resolveObjectFit.height,\n        xOffset = _resolveObjectFit.xOffset,\n        yOffset = _resolveObjectFit.yOffset;\n\n    if (node.image.data) {\n      if (width !== 0 && height !== 0) {\n        ctx.fillOpacity(opacity || 1).image(node.image.data, left + paddingLeft + xOffset, top + paddingTop + yOffset, {\n          width: width,\n          height: height\n        });\n      } else {\n        warning(false, \"Image with src '\" + node.props.src + \"' skipped due to invalid dimensions\");\n      }\n    }\n\n    return node;\n  };\n};\n\nvar renderImage$1 = function renderImage(ctx, node) {\n  compose(restore$1(ctx), drawImage$1(ctx), clipNode$1(ctx), save$1(ctx))(node);\n  return node;\n};\n\nvar renderImage$2 = curryN(2, renderImage$1);\nvar availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\n\nvar painter = function painter(ctx) {\n  var p = availableMethods.reduce(function (acc, prop) {\n    var _extends2;\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[prop] = function () {\n      ctx[prop].apply(ctx, arguments);\n      return p;\n    }, _extends2));\n  }, {});\n  return p;\n};\n\nvar defaultsZero$1 = pathOr(0);\n\nvar renderCanvas = function renderCanvas(ctx, node) {\n  var _node$box = node.box,\n      top = _node$box.top,\n      left = _node$box.left,\n      width = _node$box.width,\n      height = _node$box.height;\n  var paddingLeft = defaultsZero$1('paddingLeft', node.box);\n  var paddingRight = defaultsZero$1('paddingRight', node.box);\n  var paddingTop = defaultsZero$1('paddingTop', node.box);\n  var paddingBottom = defaultsZero$1('paddingBottom', node.box);\n  var availableWidth = width - paddingLeft - paddingRight;\n  var availableHeight = height - paddingTop - paddingBottom;\n  warning(availableWidth && availableHeight, 'Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n\n  ctx.restore();\n  return node;\n};\n\nvar renderCanvas$1 = curryN(2, renderCanvas);\n/**\n * Checks if page should render vertical ruler\n *\n * @param {Object} page\n * @returns {boolean} has vertical ruler\n */\n\nvar hasVerticalRuler = either(hasPath(['props', 'ruler']), hasPath(['props', 'verticalRuler']));\n/**\n * Checks if page should render horizontal ruler\n *\n * @param {Object} page\n * @returns {boolean} has horizontal ruler\n */\n\nvar hasHorizontalRuler = either(hasPath(['props', 'ruler']), hasPath(['props', 'horizontalRuler']));\n\nvar range = function range(max, steps) {\n  return Array.from({\n    length: Math.ceil(max / steps)\n  }, function (_, i) {\n    return i * steps;\n  });\n};\n\nvar matchPercentage = function matchPercentage(value) {\n  var match = matchPercent(value);\n  return match ? 100 / match.value : null;\n};\n\nvar getVerticalSteps = function getVerticalSteps(page) {\n  var value = page.props.horizontalRulerSteps || page.props.rulerSteps || DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    var percentage = matchPercentage(value);\n\n    if (percentage) {\n      var width = page.box.width - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return width / percentage;\n    }\n\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nvar getHorizontalSteps = function getHorizontalSteps(page) {\n  var value = page.props.verticalRulerSteps || page.props.rulerSteps || DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    var percentage = matchPercentage(value);\n\n    if (percentage) {\n      var height = page.box.height - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return height / percentage;\n    }\n\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nvar renderVerticalRuler = function renderVerticalRuler(ctx) {\n  return function (page) {\n    var width = page.box.width;\n    var height = page.box.height;\n    var offset = hasHorizontalRuler(page) ? RULER_WIDTH : 0;\n    var hRange = range(width, getVerticalSteps(page));\n    ctx.rect(offset, 0, width, RULER_WIDTH).fill(RULER_COLOR).moveTo(offset, RULER_WIDTH).lineTo(width, RULER_WIDTH).stroke(LINE_COLOR);\n    hRange.map(function (step) {\n      ctx.moveTo(offset + step, 0).lineTo(offset + step, RULER_WIDTH).stroke(LINE_COLOR).fillColor('black').text(\"\" + Math.round(step), offset + step + 1, 1);\n\n      if (step !== 0) {\n        ctx.moveTo(offset + step, RULER_WIDTH).lineTo(offset + step, height).stroke(GRID_COLOR);\n      }\n    });\n    return page;\n  };\n};\n\nvar renderHorizontalRuler = function renderHorizontalRuler(ctx) {\n  return function (page) {\n    var width = page.box.width;\n    var height = page.box.height;\n    var offset = hasVerticalRuler(page) ? RULER_WIDTH : 0;\n    var hRange = range(height, getHorizontalSteps(page));\n    ctx.rect(0, offset, RULER_WIDTH, height).fill(RULER_COLOR).moveTo(RULER_WIDTH, hasHorizontalRuler(page) ? RULER_WIDTH : 0).lineTo(RULER_WIDTH, height).stroke(LINE_COLOR);\n    hRange.map(function (step) {\n      ctx.moveTo(0, offset + step).lineTo(RULER_WIDTH, offset + step).stroke(LINE_COLOR).fillColor('black').text(\"\" + Math.round(step), 1, offset + step + 1);\n\n      if (step !== 0) {\n        ctx.moveTo(RULER_WIDTH, offset + step).lineTo(width, offset + step).stroke(GRID_COLOR);\n      }\n    });\n    return page;\n  };\n};\n\nvar renderRulers = function renderRulers(ctx, page) {\n  ctx.save().lineWidth(LINE_WIDTH).fontSize(RULER_FONT_SIZE).opacity(1);\n  compose(when(hasVerticalRuler, renderVerticalRuler(ctx)), when(hasHorizontalRuler, renderHorizontalRuler(ctx)))(page);\n  ctx.restore();\n  return page;\n};\n\nvar renderRulers$1 = curryN(2, renderRulers);\n\nvar getDocumentProp = function getDocumentProp(target) {\n  return function (or, prop) {\n    return pathOr(or, ['props', prop], target);\n  };\n};\n\nvar setPDFMetadata = function setPDFMetadata(target) {\n  return function (key, value) {\n    if (value) target.info[key] = value;\n  };\n};\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\n\n\nvar addMetadata = function addMetadata(ctx, doc) {\n  var getProp = getDocumentProp(doc);\n  var setProp = setPDFMetadata(ctx);\n  var title = getProp(null, 'title');\n  var author = getProp(null, 'author');\n  var subject = getProp(null, 'subject');\n  var keywords = getProp(null, 'keywords');\n  var creator = getProp('react-pdf', 'creator');\n  var producer = getProp('react-pdf', 'producer');\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n  return doc;\n};\n\nvar addMetadata$1 = curryN(2, addMetadata);\nvar CONTENT_COLOR = '#a1c6e7';\nvar PADDING_COLOR = '#c4deb9';\nvar MARGIN_COLOR = '#f8cca1';\nvar shouldDebug = pathEq(['props', 'debug'], true); // TODO: Draw debug boxes using clipping to enhance quality\n\nvar debugContent = function debugContent(ctx) {\n  return tap(function (node) {\n    var _node$box = node.box,\n        left = _node$box.left,\n        top = _node$box.top,\n        width = _node$box.width,\n        height = _node$box.height,\n        paddingLeft = _node$box.paddingLeft,\n        paddingTop = _node$box.paddingTop,\n        paddingRight = _node$box.paddingRight,\n        paddingBottom = _node$box.paddingBottom,\n        borderLeftWidth = _node$box.borderLeftWidth,\n        borderTopWidth = _node$box.borderTopWidth,\n        borderRightWidth = _node$box.borderRightWidth,\n        borderBottomWidth = _node$box.borderBottomWidth;\n    ctx.fillColor(CONTENT_COLOR).opacity(0.5).rect(left + paddingLeft + borderLeftWidth, top + paddingTop + borderTopWidth, width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth, height - paddingTop - paddingBottom - borderTopWidth - borderBottomWidth).fill();\n  });\n};\n\nvar debugPadding = function debugPadding(ctx) {\n  return tap(function (node) {\n    var _node$box2 = node.box,\n        left = _node$box2.left,\n        top = _node$box2.top,\n        width = _node$box2.width,\n        height = _node$box2.height,\n        paddingLeft = _node$box2.paddingLeft,\n        paddingTop = _node$box2.paddingTop,\n        paddingRight = _node$box2.paddingRight,\n        paddingBottom = _node$box2.paddingBottom,\n        borderLeftWidth = _node$box2.borderLeftWidth,\n        borderTopWidth = _node$box2.borderTopWidth,\n        borderRightWidth = _node$box2.borderRightWidth,\n        borderBottomWidth = _node$box2.borderBottomWidth;\n    ctx.fillColor(PADDING_COLOR).opacity(0.5); // Padding top\n\n    ctx.rect(left + paddingLeft + borderLeftWidth, top + borderTopWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingTop).fill(); // Padding left\n\n    ctx.rect(left + borderLeftWidth, top + borderTopWidth, paddingLeft, height - borderTopWidth - borderBottomWidth).fill(); // Padding right\n\n    ctx.rect(left + width - paddingRight - borderRightWidth, top + borderTopWidth, paddingRight, height - borderTopWidth - borderBottomWidth).fill(); // Padding bottom\n\n    ctx.rect(left + paddingLeft + borderLeftWidth, top + height - paddingBottom - borderBottomWidth, width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth, paddingBottom).fill();\n  });\n};\n\nvar debugMargin = function debugMargin(ctx) {\n  return tap(function (node) {\n    var _node$box3 = node.box,\n        left = _node$box3.left,\n        top = _node$box3.top,\n        width = _node$box3.width,\n        height = _node$box3.height,\n        marginLeft = _node$box3.marginLeft,\n        marginTop = _node$box3.marginTop,\n        marginRight = _node$box3.marginRight,\n        marginBottom = _node$box3.marginBottom;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5); // Margin top\n\n    ctx.rect(left, top - marginTop, width, marginTop).fill(); // Margin left\n\n    ctx.rect(left - marginLeft, top - marginTop, marginLeft, height + marginTop + marginBottom).fill(); // Margin right\n\n    ctx.rect(left + width, top - marginTop, marginRight, height + marginTop + marginBottom).fill(); // Margin bottom\n\n    ctx.rect(left, top + height, width, marginBottom).fill();\n  });\n};\n\nvar debugText = function debugText(ctx) {\n  return tap(function (node) {\n    var _node$box4 = node.box,\n        left = _node$box4.left,\n        top = _node$box4.top,\n        width = _node$box4.width,\n        height = _node$box4.height,\n        marginLeft = _node$box4.marginLeft,\n        marginTop = _node$box4.marginTop,\n        marginRight = _node$box4.marginRight,\n        marginBottom = _node$box4.marginBottom;\n    var roundedWidth = Math.round(width + marginLeft + marginRight);\n    var roundedHeight = Math.round(height + marginTop + marginBottom);\n    ctx.fontSize(4).opacity(1).fillColor('black').text(roundedWidth + \" x \" + roundedHeight, left - marginLeft, Math.max(top - marginTop - 4, 1));\n  });\n};\n\nvar debugOrigin = function debugOrigin(ctx) {\n  return tap(function (node) {\n    if (node.origin) {\n      ctx.circle(node.origin.left, node.origin.top, 3).fill('red').circle(node.origin.left, node.origin.top, 5).stroke('red');\n    }\n  });\n};\n\nvar renderDebug = function renderDebug(ctx) {\n  return tap(when(shouldDebug, compose(restore$1(ctx), debugOrigin(ctx), debugText(ctx), debugMargin(ctx), debugPadding(ctx), debugContent(ctx), save$1(ctx))));\n}; // This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\n\n\nvar KAPPA$3 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nvar clipBorderTop = function clipBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth; // Clip outer top border edge\n\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  var c0 = rtr * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr); // Move down in case the margin exceedes the radius\n\n  var topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord); // Clip inner top right cap\n\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord); // Ellipse coefficients inner top right cap\n\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c1 = innerTopRightRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerTopRightRadiusY * (1.0 - KAPPA$3); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth); // Clip inner top border edge\n\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c3 = innerTopLeftRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerTopLeftRadiusY * (1.0 - KAPPA$3);\n  var topLeftYCoord = top + Math.max(borderTopWidth, rtl); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  var c5 = rtl * (1.0 - KAPPA$3); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip(); // Clip border top cap joins\n\n  if (borderRightWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    var _trSlope = -borderTopWidth / borderLeftWidth;\n\n    ctx.moveTo(left + width / 2, _trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderTop = function fillBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width;\n  var borderTopColor = style.borderTopColor,\n      borderTopWidth = style.borderTopWidth,\n      borderTopStyle = style.borderTopStyle,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth;\n  var c0 = rtl * (1.0 - KAPPA$3);\n  var c1 = rtr * (1.0 - KAPPA$3);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderRight = function clipBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderBottomWidth = style.borderBottomWidth; // Clip outer right border edge\n\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer bottom right cap\n\n  var c0 = rbr * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height); // Move left in case the margin exceedes the radius\n\n  var topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height); // Clip inner bottom right cap\n\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth); // Ellipse coefficients inner bottom right cap\n\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c1 = innerBottomRightRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerBottomRightRadiusY * (1.0 - KAPPA$3); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth)); // Clip inner right border edge\n\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth)); // Ellipse coefficients inner top right cap\n\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c3 = innerTopRightRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerTopRightRadiusY * (1.0 - KAPPA$3);\n  var topRightXCoord = left + width - Math.max(rtr, borderRightWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top); // Move right in case the margin exceedes the radius\n\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  var c5 = rtr * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderTopWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderRight = function fillBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderRightColor = style.borderRightColor,\n      borderRightStyle = style.borderRightStyle,\n      borderRightWidth = style.borderRightWidth,\n      borderTopWidth = style.borderTopWidth,\n      borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbr * (1.0 - KAPPA$3);\n  var c1 = rtr * (1.0 - KAPPA$3);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderBottom = function clipBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderBottomWidth = style.borderBottomWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth; // Clip outer top border edge\n\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  var c0 = rbl * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl); // Move up in case the margin exceedes the radius\n\n  var bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord); // Clip inner bottom left cap\n\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord); // Ellipse coefficients inner top right cap\n\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c1 = innerBottomLeftRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerBottomLeftRadiusY * (1.0 - KAPPA$3); // Clip inner bottom left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth); // Clip inner bottom border edge\n\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth); // Ellipse coefficients inner top left cap\n\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c3 = innerBottomRightRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerBottomRightRadiusY * (1.0 - KAPPA$3);\n  var bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer top left cap\n\n  var c5 = rbr * (1.0 - KAPPA$3); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip(); // Clip border bottom cap joins\n\n  if (borderRightWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderBottom = function fillBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderBottomColor = style.borderBottomColor,\n      borderBottomStyle = style.borderBottomStyle,\n      borderBottomWidth = style.borderBottomWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth;\n  var c0 = rbl * (1.0 - KAPPA$3);\n  var c1 = rbr * (1.0 - KAPPA$3);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderLeft = function clipBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderLeftWidth = style.borderLeftWidth,\n      borderBottomWidth = style.borderBottomWidth; // Clip outer left border edge\n\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  var c0 = rtl * (1.0 - KAPPA$3); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top); // Move right in case the margin exceedes the radius\n\n  var topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top); // Clip inner top left cap\n\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c1 = innerTopLeftRadiusX * (1.0 - KAPPA$3);\n  var c2 = innerTopLeftRadiusY * (1.0 - KAPPA$3); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth)); // Clip inner left border edge\n\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth)); // Ellipse coefficients inner bottom left cap\n\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c3 = innerBottomLeftRadiusX * (1.0 - KAPPA$3);\n  var c4 = innerBottomLeftRadiusY * (1.0 - KAPPA$3);\n  var bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height); // Move left in case the margin exceedes the radius\n\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  var c5 = rbl * (1.0 - KAPPA$3); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderBottomWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    var _trSlope2 = -borderTopWidth / borderLeftWidth;\n\n    ctx.moveTo(left + width / 2, _trSlope2 * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderLeft = function fillBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      height = layout.height;\n  var borderLeftColor = style.borderLeftColor,\n      borderLeftStyle = style.borderLeftStyle,\n      borderLeftWidth = style.borderLeftWidth,\n      borderTopWidth = style.borderTopWidth,\n      borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbl * (1.0 - KAPPA$3);\n  var c1 = rtl * (1.0 - KAPPA$3);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar shouldRenderBorders = function shouldRenderBorders(node) {\n  return node.box && (node.box.borderTopWidth || node.box.borderRightWidth || node.box.borderBottomWidth || node.box.borderLeftWidth);\n};\n\nvar renderBorders = function renderBorders(ctx, node) {\n  if (!shouldRenderBorders(node)) return node;\n  var _node$box = node.box,\n      width = _node$box.width,\n      height = _node$box.height,\n      borderTopWidth = _node$box.borderTopWidth,\n      borderLeftWidth = _node$box.borderLeftWidth,\n      borderRightWidth = _node$box.borderRightWidth,\n      borderBottomWidth = _node$box.borderBottomWidth;\n  var _node$style = node.style,\n      opacity = _node$style.opacity,\n      _node$style$borderTop = _node$style.borderTopLeftRadius,\n      borderTopLeftRadius = _node$style$borderTop === void 0 ? 0 : _node$style$borderTop,\n      _node$style$borderTop2 = _node$style.borderTopRightRadius,\n      borderTopRightRadius = _node$style$borderTop2 === void 0 ? 0 : _node$style$borderTop2,\n      _node$style$borderBot = _node$style.borderBottomLeftRadius,\n      borderBottomLeftRadius = _node$style$borderBot === void 0 ? 0 : _node$style$borderBot,\n      _node$style$borderBot2 = _node$style.borderBottomRightRadius,\n      borderBottomRightRadius = _node$style$borderBot2 === void 0 ? 0 : _node$style$borderBot2,\n      _node$style$borderTop3 = _node$style.borderTopColor,\n      borderTopColor = _node$style$borderTop3 === void 0 ? 'black' : _node$style$borderTop3,\n      _node$style$borderTop4 = _node$style.borderTopStyle,\n      borderTopStyle = _node$style$borderTop4 === void 0 ? 'solid' : _node$style$borderTop4,\n      _node$style$borderLef = _node$style.borderLeftColor,\n      borderLeftColor = _node$style$borderLef === void 0 ? 'black' : _node$style$borderLef,\n      _node$style$borderLef2 = _node$style.borderLeftStyle,\n      borderLeftStyle = _node$style$borderLef2 === void 0 ? 'solid' : _node$style$borderLef2,\n      _node$style$borderRig = _node$style.borderRightColor,\n      borderRightColor = _node$style$borderRig === void 0 ? 'black' : _node$style$borderRig,\n      _node$style$borderRig2 = _node$style.borderRightStyle,\n      borderRightStyle = _node$style$borderRig2 === void 0 ? 'solid' : _node$style$borderRig2,\n      _node$style$borderBot3 = _node$style.borderBottomColor,\n      borderBottomColor = _node$style$borderBot3 === void 0 ? 'black' : _node$style$borderBot3,\n      _node$style$borderBot4 = _node$style.borderBottomStyle,\n      borderBottomStyle = _node$style$borderBot4 === void 0 ? 'solid' : _node$style$borderBot4;\n  var style = {\n    borderTopColor: borderTopColor,\n    borderTopWidth: borderTopWidth,\n    borderTopStyle: borderTopStyle,\n    borderLeftColor: borderLeftColor,\n    borderLeftWidth: borderLeftWidth,\n    borderLeftStyle: borderLeftStyle,\n    borderRightColor: borderRightColor,\n    borderRightWidth: borderRightWidth,\n    borderRightStyle: borderRightStyle,\n    borderBottomColor: borderBottomColor,\n    borderBottomWidth: borderBottomWidth,\n    borderBottomStyle: borderBottomStyle,\n    borderTopLeftRadius: borderTopLeftRadius,\n    borderTopRightRadius: borderTopRightRadius,\n    borderBottomLeftRadius: borderBottomLeftRadius,\n    borderBottomRightRadius: borderBottomRightRadius\n  };\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n  return node;\n};\n\nvar renderBorders$1 = curryN(2, renderBorders);\n\nvar setDestination = function setDestination(ctx) {\n  return tap(function (node) {\n    if (node.props.id) {\n      ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n  });\n};\n\nvar drawBackground = function drawBackground(ctx) {\n  return function (node) {\n    if (node.box && node.style.backgroundColor) {\n      var _node$box = node.box,\n          top = _node$box.top,\n          left = _node$box.left,\n          width = _node$box.width,\n          height = _node$box.height;\n      ctx.fillOpacity(node.style.opacity || 1).fillColor(node.style.backgroundColor).rect(left, top, width, height).fill();\n    }\n\n    return node;\n  };\n};\n\nvar shouldRenderBackground = hasPath(['style', 'backgroundColor']);\n\nvar renderBackground = function renderBackground(ctx, node) {\n  when(shouldRenderBackground, compose(restore$1(ctx), drawBackground(ctx), clipNode$1(ctx), save$1(ctx)))(node);\n  return node;\n};\n\nvar renderBackground$1 = curryN(2, renderBackground);\n\nvar shouldRenderChildren = function shouldRenderChildren(v) {\n  return !isText(v) && !isSvg(v);\n};\n\nvar renderChildren = function renderChildren(ctx) {\n  return function (node) {\n    save$1(ctx, node);\n    ctx.translate(node.box.left, node.box.top);\n    compose(forEach(renderNode$1(ctx)), pathOr([], ['children']))(node);\n    restore$1(ctx, node);\n    return node;\n  };\n};\n\nvar renderNode$1 = function renderNode(ctx) {\n  return function (node) {\n    return compose(restore$1(ctx), renderDebug(ctx), setDestination(ctx), when(shouldRenderChildren, renderChildren(ctx)), when(either(isText, isLink), setLink$1(ctx)), cond([[isText, renderText$1(ctx)], [isNote, renderNote$1(ctx)], [isImage, renderImage$2(ctx)], [isCanvas, renderCanvas$1(ctx)], [isSvg, renderSvg$1(ctx)], [T, identity]]), renderBorders$1(ctx), renderBackground$1(ctx), applyTransformations$1(ctx), save$1(ctx), when(isPage, renderPage$1(ctx)))(node);\n  };\n};\n\nvar renderDocument = function renderDocument(ctx) {\n  return compose(forEach(compose(renderRulers$1(ctx), renderNode$1(ctx))), pathOr([], ['children']));\n};\n\nvar render = function render(ctx, doc) {\n  addMetadata$1(ctx)(doc);\n  renderDocument(ctx)(doc);\n  ctx.end();\n  Font$1.reset(); // TODO: move outside\n\n  return ctx;\n};\n/**\n * Capitalize first letter of each word\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\n\n\nvar capitalize = function capitalize(value) {\n  if (!value) return value;\n  return value.replace(/(^|\\s)\\S/g, function (l) {\n    return l.toUpperCase();\n  });\n};\n/**\n * Capitalize first letter of string\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\n\n\nvar upperFirst = ifElse(isNil, identity, compose(join(''), juxt([compose(toUpper, head), tail])));\nvar upperFirst$1 = memoizeWith(identity, upperFirst);\n/**\n * Apply transformation to text string\n *\n * @param {String} text\n * @param {String} transformation type\n * @returns {String} transformed text\n */\n\nvar transformText = function transformText(text, transformation) {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n\n    case 'lowercase':\n      return text.toLowerCase();\n\n    case 'capitalize':\n      return capitalize(text);\n\n    case 'upperfirst':\n      return upperFirst$1(text);\n\n    default:\n      return text;\n  }\n};\n\nvar StandardFont = /*#__PURE__*/function () {\n  function StandardFont(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n\n  var _proto = StandardFont.prototype;\n\n  _proto.layout = function layout(str) {\n    var _this = this;\n\n    var _this$src$encode = this.src.encode(str),\n        encoded = _this$src$encode[0],\n        positions = _this$src$encode[1];\n\n    return {\n      positions: positions,\n      stringIndices: positions.map(function (_, i) {\n        return i;\n      }),\n      glyphs: encoded.map(function (g, i) {\n        var glyph = _this.getGlyph(parseInt(g, 16));\n\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  };\n\n  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {\n    var glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  };\n\n  _proto.getGlyph = function getGlyph(id) {\n    return {\n      id: id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  };\n\n  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  } // Based on empirical observation\n  ;\n\n  _createClass(StandardFont, [{\n    key: \"ascent\",\n    get: function get() {\n      return 900;\n    } // Based on empirical observation\n\n  }, {\n    key: \"descent\",\n    get: function get() {\n      switch (this.name) {\n        case 'Times-Roman':\n        case 'Times-Bold':\n        case 'Times-Italic':\n          return -220;\n\n        case 'Courier':\n        case 'Courier-Bold':\n        case 'Courier-Oblique':\n          return -230;\n\n        default:\n          return -200;\n      }\n    }\n  }, {\n    key: \"lineGap\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"unitsPerEm\",\n    get: function get() {\n      return 1000;\n    }\n  }]);\n\n  return StandardFont;\n}();\n\nvar fontCache = {};\nvar IGNORED_CODE_POINTS = [173];\nvar getFontSize = pathOr(12, ['attributes', 'fontSize']);\n\nvar getOrCreateFont = function getOrCreateFont(name) {\n  if (fontCache[name]) return fontCache[name];\n  var font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\n\nvar getFallbackFont = function getFallbackFont() {\n  return getOrCreateFont('Helvetica');\n};\n\nvar shouldFallbackToFont = function shouldFallbackToFont(codePoint, font) {\n  return !IGNORED_CODE_POINTS.includes(codePoint) && !font.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);\n};\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (_ref) {\n    var string = _ref.string,\n        runs = _ref.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n\n    for (var _iterator = runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var run = _ref2;\n\n      var _fontSize = getFontSize(run);\n\n      var defaultFont = typeof run.attributes.font === 'string' ? getOrCreateFont(run.attributes.font) : run.attributes.font;\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n\n      for (var _iterator2 = string.slice(run.start, run.end), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref3 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref3 = _i2.value;\n        }\n\n        var char = _ref3;\n        var codePoint = char.codePointAt();\n        var shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n        var font = shouldFallback ? getFallbackFont() : defaultFont; // If the default font does not have a glyph and the fallback font does, we use it\n\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n\n          lastFont = font;\n          lastIndex = index;\n        }\n\n        index += char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar engines = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine = layoutEngine(engines);\nvar layoutOptions = {\n  hyphenationCallback: Font$1.getHyphenationCallback(),\n  shrinkWhitespaceFactor: {\n    before: -0.5,\n    after: -0.5\n  }\n};\n\nvar getFragments = function getFragments(instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$props = instance.props,\n      _instance$props$fill = _instance$props.fill,\n      fill = _instance$props$fill === void 0 ? 'black' : _instance$props$fill,\n      _instance$props$fontF = _instance$props.fontFamily,\n      fontFamily = _instance$props$fontF === void 0 ? 'Helvetica' : _instance$props$fontF,\n      fontWeight = _instance$props.fontWeight,\n      fontStyle = _instance$props.fontStyle,\n      _instance$props$fontS = _instance$props.fontSize,\n      fontSize = _instance$props$fontS === void 0 ? 18 : _instance$props$fontS,\n      textDecoration = _instance$props.textDecoration,\n      textDecorationColor = _instance$props.textDecorationColor,\n      textDecorationStyle = _instance$props.textDecorationStyle,\n      textTransform = _instance$props.textTransform,\n      opacity = _instance$props.opacity;\n  var obj = Font$1.getFont({\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  });\n  var font = obj ? obj.data : fontFamily;\n  var attributes = {\n    font: font,\n    opacity: opacity,\n    fontSize: fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || fill,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill\n  };\n  instance.children.forEach(function (child) {\n    if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else {\n      if (child) {\n        fragments.push.apply(fragments, getFragments(child));\n      }\n    }\n  });\n  return fragments;\n};\n\nvar getAttributedString = function getAttributedString(instance) {\n  return AttributedString.fromFragments(getFragments(instance));\n};\n\nvar AlmostInfinity = 999999999999;\n\nvar layoutTspan = function layoutTspan(node) {\n  var attributedString = getAttributedString(node);\n  var x = pathOr(0, ['props', 'x'], node);\n  var y = pathOr(0, ['props', 'y'], node);\n  var container = {\n    x: x,\n    y: y,\n    width: AlmostInfinity,\n    height: AlmostInfinity\n  };\n  var lines = compose(reduce(concat, []), engine)(attributedString, container, layoutOptions);\n  return assoc('lines', lines, node);\n};\n\nvar layoutText = evolve({\n  children: map(layoutTspan)\n});\n/**\n * Checks if node is svg defs\n *\n * @param {Object} node\n * @returns {Boolean} is node svg defs?\n */\n\nvar isDefs = propEq('type', DEFS);\nvar getChildren = propOr([], 'children');\nvar getId = path(['props', 'id']);\nvar getDefs = compose(map(prop(0)), groupBy(getId), getChildren, defaultTo({}), find(isDefs), getChildren);\nvar isNotDefs = complement(isDefs);\nvar detachDefs = evolve({\n  children: filter(isNotDefs)\n});\nvar URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\n\nvar replaceDef = function replaceDef(defs) {\n  return compose(when(test(URL_REGEX), compose(prop(__, defs), prop(1), match(URL_REGEX))), defaultTo(''));\n};\n\nvar parseNodeDefs = function parseNodeDefs(defs) {\n  return function (node) {\n    return compose(evolve({\n      props: evolve({\n        fill: replaceDef(defs),\n        clipPath: replaceDef(defs)\n      })\n    }), evolve({\n      children: map(parseNodeDefs(defs))\n    }))(node);\n  };\n};\n\nvar parseDefs = function parseDefs(root) {\n  var defs = getDefs(root);\n  return evolve({\n    children: map(parseNodeDefs(defs))\n  }, root);\n};\n\nvar replaceDefs = compose(detachDefs, parseDefs);\n\nvar parseViewbox = function parseViewbox(value) {\n  if (!value) return null;\n  var values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return {\n    minX: values[0],\n    minY: values[1],\n    maxX: values[2],\n    maxY: values[3]\n  };\n};\n\nvar getContainer = function getContainer(node) {\n  var viewbox = parseViewbox(node.props.viewBox);\n\n  if (viewbox) {\n    return {\n      width: viewbox.maxX,\n      height: viewbox.maxY\n    };\n  }\n\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height)\n    };\n  }\n\n  return {\n    width: 0,\n    height: 0\n  };\n};\n\nvar getInheritProps = compose(pick(SVG_INHERITED_PROPS), propOr({}, 'props'));\n\nvar inheritProps = function inheritProps(node) {\n  var props = getInheritProps(node);\n  return evolve({\n    children: map(compose(inheritProps, evolve({\n      props: merge(props)\n    })))\n  })(node);\n};\n\nvar parseAspectRatio = function parseAspectRatio(value) {\n  var match = value.replace(/[\\s\\r\\t\\n]+/gm, ' ').replace(/^defer\\s/, '').split(' ');\n  var align = match[0] || 'xMidYMid';\n  var meetOrSlice = match[1] || 'meet';\n  return {\n    align: align,\n    meetOrSlice: meetOrSlice\n  };\n};\n\nvar isRgb = test(/rgb/g);\nvar isRgba = test(/rgba/g);\nvar isHsl = test(/hsl/g);\nvar isHsla = test(/hsla/g);\n/**\n * Transform rgb color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\nvar parseRgb = compose(colorString.to.hex, colorString.get.rgb);\n/**\n * Transform Hsl color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\nvar parseHsl = compose(toUpper, apply(hlsToHex), map(Math.round), colorString.get.hsl);\n/**\n * Transform given color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\nvar transformColor = function transformColor(value) {\n  return cond([[isRgba, parseRgb], [isRgb, parseRgb], [isHsla, parseHsl], [isHsl, parseHsl], [T, always(value)]])(value);\n};\n/**\n * Transform rbg and cmyk colors to hexa\n *\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\n\n\nvar transformColors = function transformColors(styles) {\n  return map(transformColor, styles);\n};\n\nvar STYLE_PROPS = ['width', 'height', 'color', 'stroke', 'strokeWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'fill', 'fillRule', 'clipPath', 'offset', 'transform', 'strokeLinejoin', 'strokeLinecap', 'strokeDasharray'];\nvar VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nvar HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\n\nvar transformPercent = function transformPercent(container) {\n  return mapObjIndexed(function (value, key) {\n    var match = matchPercent(value);\n\n    if (match && VERTICAL_PROPS.includes(key)) {\n      return match.percent * container.height;\n    }\n\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n      return match.percent * container.width;\n    }\n\n    return value;\n  });\n};\n\nvar parsePercent = function parsePercent(value) {\n  var match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\n\nvar parseProps = function parseProps(container) {\n  return compose(evolve({\n    props: o(evolve({\n      x: parseFloat,\n      x1: parseFloat,\n      x2: parseFloat,\n      y: parseFloat,\n      y1: parseFloat,\n      y2: parseFloat,\n      r: parseFloat,\n      rx: parseFloat,\n      ry: parseFloat,\n      cx: parseFloat,\n      cy: parseFloat,\n      width: parseFloat,\n      height: parseFloat,\n      offset: parsePercent,\n      fill: transformColor,\n      opacity: parsePercent,\n      stroke: transformColor,\n      stopOpacity: parsePercent,\n      stopColor: transformColor\n    }), transformPercent(container))\n  }));\n};\n\nvar mergeStyles = function mergeStyles(node) {\n  var style = propOr({}, 'style', node);\n  return evolve({\n    props: merge(style)\n  }, node);\n};\n\nvar removeNoneValues = evolve({\n  props: map(when(equals('none'), always(null)))\n});\n\nvar pickStyleProps = function pickStyleProps(node) {\n  var styleProps = o(pick(STYLE_PROPS), propOr({}, 'props'))(node);\n  return evolve({\n    style: merge(styleProps)\n  }, node);\n};\n\nvar parseSvgProps = evolve({\n  props: evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio\n  })\n});\n\nvar wrapBetweenTspan = function wrapBetweenTspan(node) {\n  return {\n    type: 'TSPAN',\n    props: {},\n    children: [node]\n  };\n};\n\nvar addMissingTspan = when(isText, evolve({\n  children: map(when(isTextInstance, wrapBetweenTspan))\n}));\n\nvar resolveSvgNode = function resolveSvgNode(container) {\n  return compose(parseProps(container), addMissingTspan, removeNoneValues, mergeStyles);\n};\n\nvar resolveChildren = function resolveChildren(container) {\n  return function (node) {\n    return evolve({\n      children: map(compose(resolveChildren(container), resolveSvgNode(container)))\n    })(node);\n  };\n};\n\nvar parseText = function parseText(node) {\n  return ifElse(isText, layoutText, evolve({\n    children: map(parseText)\n  }))(node);\n};\n\nvar resolveSvgRoot = function resolveSvgRoot(node) {\n  var container = getContainer(node);\n  return compose(replaceDefs, parseText, parseSvgProps, pickStyleProps, inheritProps, resolveChildren(container))(node);\n};\n\nvar resolveSvg = function resolveSvg(node) {\n  return compose(evolve({\n    children: map(resolveSvg)\n  }), when(isSvg, resolveSvgRoot))(node);\n};\n\nvar getZIndex = path(['style', 'zIndex']);\nvar isType = propEq('type');\nvar shouldNotSort = anyPass([isType(DOCUMENT), isType(SVG)]);\n\nvar sortZIndex = function sortZIndex(a, b) {\n  var za = getZIndex(a);\n  var zb = getZIndex(b);\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n  return zb - za;\n};\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar resolveZIndex = function resolveZIndex(node) {\n  return compose(evolve({\n    children: map(resolveZIndex)\n  }), unless(shouldNotSort, evolve({\n    children: sort(sortZIndex)\n  })))(node);\n};\n/**\n * Adjust page size given ruler props\n *\n * @param {Object} page\n * @returns {boolean} page with size altered by ruler props\n */\n\n\nvar adjustPageSize = compose(when(hasVerticalRuler, evolve({\n  box: {\n    height: add(RULER_WIDTH)\n  },\n  children: map(evolve({\n    box: {\n      top: add(RULER_WIDTH)\n    }\n  }))\n})), when(hasHorizontalRuler, evolve({\n  box: {\n    width: add(RULER_WIDTH)\n  },\n  children: map(evolve({\n    box: {\n      left: add(RULER_WIDTH)\n    }\n  }))\n})));\n/**\n * Adjust pages size given ruler props\n *\n * @param {Object} root\n * @returns {boolean} root with pages size altered by ruler props\n */\n\nvar resolveRulers = evolve({\n  children: map(adjustPageSize)\n});\nvar fs = {};\n\nPNG.isValid = function (data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n}; // Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\n\nvar MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\n\nvar JPEG = function JPEG(data) {\n  this.data = null;\n  this.width = null;\n  this.height = null;\n  this.data = data;\n\n  if (data.readUInt16BE(0) !== 0xffd8) {\n    throw new Error('SOI not found in JPEG');\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    throw new Error('Invalid JPEG.');\n  }\n\n  pos += 3;\n  this.height = data.readUInt16BE(pos);\n  pos += 2;\n  this.width = data.readUInt16BE(pos);\n};\n\nJPEG.isValid = function (data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar createCache = function createCache(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$limit = _ref.limit,\n      limit = _ref$limit === void 0 ? 100 : _ref$limit;\n\n  var cache = {};\n  var keys = [];\n  return {\n    get: function get(key) {\n      return cache[key];\n    },\n    set: function set(key, value) {\n      keys.push(key);\n\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n\n      cache[key] = value;\n    },\n    reset: function reset() {\n      cache = {};\n      keys = [];\n    },\n    length: function length() {\n      return keys.length;\n    }\n  };\n};\n\nvar IMAGE_CACHE = createCache({\n  limit: 30\n});\n\nvar getAbsoluteLocalPath = function getAbsoluteLocalPath(src) {\n  {\n    throw new Error('Cannot check local paths in client-side environment');\n  }\n\n  var _url$parse = fs.parse(src),\n      protocol = _url$parse.protocol,\n      auth = _url$parse.auth,\n      host = _url$parse.host,\n      port = _url$parse.port,\n      hostname = _url$parse.hostname,\n      pathname = _url$parse.path;\n\n  var absolutePath = fs.resolve(pathname);\n\n  if (protocol && protocol !== 'file:' || auth || host || port || hostname) {\n    return undefined;\n  }\n\n  return absolutePath;\n};\n\nvar fetchLocalFile = function fetchLocalFile(src) {\n  return new Promise(function (resolve, reject) {\n    try {\n      {\n        return reject(new Error('Cannot fetch local file in this environemnt'));\n      }\n      var absolutePath = getAbsoluteLocalPath(src);\n\n      if (!absolutePath) {\n        return reject(new Error(\"Cannot fetch non-local path: \" + src));\n      }\n\n      fs.readFile(absolutePath, function (err, data) {\n        return err ? reject(err) : resolve(data);\n      });\n    } catch (err) {\n      reject(err);\n    }\n  });\n};\n\nvar fetchRemoteFile = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(uri, options) {\n    var response, buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(uri, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchRemoteFile(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar isValidFormat = function isValidFormat(format) {\n  var lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nvar guessFormat = function guessFormat(buffer) {\n  var format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nvar isCompatibleBase64 = function isCompatibleBase64(_ref2) {\n  var uri = _ref2.uri;\n  return /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n};\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n\n    case 'png':\n      return new PNG(body);\n\n    default:\n      return null;\n  }\n}\n\nvar resolveBase64Image = function resolveBase64Image(_ref3) {\n  var uri = _ref3.uri;\n  var match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  var format = match[1];\n  var data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(\"Base64 image invalid format: \" + format);\n  }\n\n  return new Promise(function (resolve) {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nvar resolveImageFromData = function resolveImageFromData(src) {\n  if (src.data && src.format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(src.data, src.format));\n    });\n  }\n\n  throw new Error(\"Invalid data given for local file: \" + JSON.stringify(src));\n};\n\nvar resolveBufferImage = function resolveBufferImage(buffer) {\n  var format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(buffer, format));\n    });\n  }\n};\n\nvar getImageFormat = function getImageFormat(body) {\n  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;\n  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n  var extension = '';\n\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nvar resolveImageFromUrl = /*#__PURE__*/function () {\n  var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(src) {\n    var uri, body, headers, _src$method, method, data, extension;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            uri = src.uri, body = src.body, headers = src.headers, _src$method = src.method, method = _src$method === void 0 ? 'GET' : _src$method;\n            {\n              _context2.next = 7;\n              break;\n            }\n            _context2.next = 4;\n            return fetchLocalFile(uri);\n\n          case 4:\n            _context2.t0 = _context2.sent;\n            _context2.next = 10;\n            break;\n\n          case 7:\n            _context2.next = 9;\n            return fetchRemoteFile(uri, {\n              body: body,\n              headers: headers,\n              method: method\n            });\n\n          case 9:\n            _context2.t0 = _context2.sent;\n\n          case 10:\n            data = _context2.t0;\n            extension = getImageFormat(data);\n            return _context2.abrupt(\"return\", getImage(data, extension));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolveImageFromUrl(_x3) {\n    return _ref4.apply(this, arguments);\n  };\n}();\n\nvar resolveImage = function resolveImage(src, _temp) {\n  var _ref5 = _temp === void 0 ? {} : _temp,\n      _ref5$cache = _ref5.cache,\n      cache = _ref5$cache === void 0 ? true : _ref5$cache;\n\n  var cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  var image;\n\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nvar isNotNil = complement(isNil);\n/**\n * Takes a list of predicates and returns the first predicate result that returns true for a given list of arguments\n *\n * @param  {...any} predicates\n * @param  {any} value\n */\n\nvar firstPass = function firstPass() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function (value) {\n    var res;\n\n    for (var _i = 0; _i < fns.length; _i++) {\n      var fn = fns[_i];\n      res = fn(value);\n      if (isNotNil(res)) return res;\n    }\n\n    return res;\n  };\n};\n/**\n * Get image source\n *\n * @param {Object} image node\n * @returns {String} image src\n */\n\n\nvar getSource$1 = compose(when(is(String), function (src) {\n  return {\n    uri: src\n  };\n}), firstPass(path(['props', 'src']), path(['props', 'source']), path(['props', 'href'])));\n/**\n * Resolves async src if passed\n *\n * @param {string | Function} src\n * @returns {object} resolved src\n */\n\nvar resolveSrc = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(src) {\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (!(typeof src === 'function')) {\n              _context.next = 7;\n              break;\n            }\n\n            _context.next = 3;\n            return src();\n\n          case 3:\n            _context.t1 = _context.sent;\n            _context.t0 = {\n              uri: _context.t1\n            };\n            _context.next = 8;\n            break;\n\n          case 7:\n            _context.t0 = src;\n\n          case 8:\n            return _context.abrupt(\"return\", _context.t0);\n\n          case 9:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function resolveSrc(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\n\n\nvar fetchImage = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(node) {\n    var src, cache, source;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            src = getSource$1(node);\n            cache = node.props.cache;\n\n            if (src) {\n              _context2.next = 5;\n              break;\n            }\n\n            warning(false, 'Image should receive either a \"src\" or \"source\" prop');\n            return _context2.abrupt(\"return\");\n\n          case 5:\n            _context2.prev = 5;\n            _context2.next = 8;\n            return resolveSrc(src);\n\n          case 8:\n            source = _context2.sent;\n            _context2.next = 11;\n            return resolveImage(source, {\n              cache: cache\n            });\n\n          case 11:\n            node.image = _context2.sent;\n            _context2.next = 18;\n            break;\n\n          case 14:\n            _context2.prev = 14;\n            _context2.t0 = _context2[\"catch\"](5);\n            node.image = {\n              width: 0,\n              height: 0\n            };\n            console.warn(_context2.t0.message);\n\n          case 18:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[5, 14]]);\n  }));\n\n  return function fetchImage(_x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\nvar emojis = {};\nvar regex = emojiRegex();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(resolveImage);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== '️';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (char) {\n    return char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji) {\n  var _Font$getEmojiSource = Font$1.getEmojiSource(),\n      url = _Font$getEmojiSource.url,\n      format = _Font$getEmojiSource.format;\n\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string) {\n  var emojiSource = Font$1.getEmojiSource();\n  if (!emojiSource || !emojiSource.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i++) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var index = match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: _extends({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} root node\n * @returns {Array} asset promises\n */\n\n\nvar fetchAssets = function fetchAssets(node) {\n  var promises = [];\n  var listToExplore = node.children.slice(0);\n\n  while (listToExplore.length > 0) {\n    var _node = listToExplore.shift();\n\n    if (isImage(_node)) {\n      promises.push(fetchImage(_node));\n    }\n\n    if (_node.style && _node.style.fontFamily) {\n      promises.push(Font$1.load(_node.style));\n    }\n\n    if (typeof _node === 'string') {\n      promises.push.apply(promises, fetchEmojis(_node));\n    }\n\n    if (typeof _node.value === 'string') {\n      promises.push.apply(promises, fetchEmojis(_node.value));\n    }\n\n    if (_node.children) {\n      _node.children.forEach(function (childNode) {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n\n  return promises;\n};\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} root node\n * @returns {Object} root node\n */\n\n\nvar resolveAssets = function resolveAssets(node) {\n  return compose(then(always(node)), function (p) {\n    return Promise.all(p);\n  }, fetchAssets)(node);\n};\n/**\n * Checks if value is not an array\n *\n * @param {any} value\n * @returns {Boolean} isn't value an array\n */\n\n\nvar isNotArray = complement(is(Array));\n/**\n * Casts value to array\n *\n * @param {any} value\n * @returns {Array} casted value\n */\n\nvar castArray = when(isNotArray, function (v) {\n  return [v];\n});\n/**\n * Remove nil values from array\n *\n * @param {Array} array\n * @returns {Array} array without nils\n */\n\nvar compact = filter(Boolean);\n/**\n * Checks if value is array\n *\n * @param {any} value\n * @returns {Boolean} is value an array\n */\n\nvar isArray = is(Array);\n/**\n * Merges style objects array\n *\n * @param {Array} style objects array\n * @returns {Object} merged style object\n */\n\nvar mergeStyles$1 = function mergeStyles(styles) {\n  return styles.reduce(function (acc, style) {\n    var s = isArray(style) ? flatten(style) : style;\n    Object.keys(s).forEach(function (key) {\n      if (s[key] !== null && s[key] !== undefined) {\n        acc[key] = s[key];\n      }\n    });\n    return acc;\n  }, {});\n};\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Array} style objects array\n * @returns {Object} flatted style object\n */\n\n\nvar flatten = compose(mergeStyles$1, compact, castArray);\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n/**\n * Expand rules\n */\n\nvar styleShorthands = {\n  margin: {\n    marginTop: true,\n    marginRight: true,\n    marginBottom: true,\n    marginLeft: true\n  },\n  marginHorizontal: {\n    marginLeft: true,\n    marginRight: true\n  },\n  marginVertical: {\n    marginTop: true,\n    marginBottom: true\n  },\n  padding: {\n    paddingTop: true,\n    paddingRight: true,\n    paddingBottom: true,\n    paddingLeft: true\n  },\n  paddingHorizontal: {\n    paddingLeft: true,\n    paddingRight: true\n  },\n  paddingVertical: {\n    paddingTop: true,\n    paddingBottom: true\n  },\n  border: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true\n  },\n  borderTop: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true\n  },\n  borderRight: {\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true\n  },\n  borderBottom: {\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true\n  },\n  borderLeft: {\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true\n  },\n  borderColor: {\n    borderTopColor: true,\n    borderRightColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true\n  },\n  borderRadius: {\n    borderTopLeftRadius: true,\n    borderTopRightRadius: true,\n    borderBottomRightRadius: true,\n    borderBottomLeftRadius: true\n  },\n  borderStyle: {\n    borderTopStyle: true,\n    borderRightStyle: true,\n    borderBottomStyle: true,\n    borderLeftStyle: true\n  },\n  borderWidth: {\n    borderTopWidth: true,\n    borderRightWidth: true,\n    borderBottomWidth: true,\n    borderLeftWidth: true\n  },\n  objectPosition: {\n    objectPositionX: true,\n    objectPositionY: true\n  },\n  transformOrigin: {\n    transformOriginX: true,\n    transformOriginY: true\n  },\n  flex: {\n    flexGrow: true,\n    flexShrink: true,\n    flexBasis: true\n  }\n};\n/**\n * Expand the shorthand properties to isolate every declaration from the others.\n *\n * @param { Object } style object\n * @returns { Object } expanded style object\n */\n\nvar expandStyles = function expandStyles(style) {\n  if (!style) return style;\n  var propsArray = Object.keys(style);\n  var resolvedStyle = {};\n\n  for (var i = 0; i < propsArray.length; i++) {\n    var key = propsArray[i];\n    var value = style[key];\n\n    if (styleShorthands[key]) {\n      var expandedProps = styleShorthands[key];\n\n      for (var propName in expandedProps) {\n        if (hasOwnProperty.call(expandedProps, propName)) {\n          resolvedStyle[propName] = value;\n        }\n      }\n    } else {\n      resolvedStyle[key] = value;\n    }\n  }\n\n  return resolvedStyle;\n};\n\nvar MM_FACTOR = 1 / 25.4 * DPI;\nvar CM_FACTOR = 1 / 2.54 * DPI;\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {String} scalar value\n * @returns {Object} parsed value\n */\n\nvar parseValue = function parseValue(value) {\n  var match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value);\n  return match ? {\n    value: parseFloat(match[1], 10),\n    unit: match[2] || 'pt'\n  } : {\n    value: value,\n    unit: undefined\n  };\n};\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {String} styles value\n * @returns {Object} transformed value\n */\n\n\nvar transformUnit = curryN(2, function (container, value) {\n  var scalar = parseValue(value);\n\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * DPI;\n\n    case 'mm':\n      return scalar.value * MM_FACTOR;\n\n    case 'cm':\n      return scalar.value * CM_FACTOR;\n\n    case 'vh':\n      return scalar.value * (container.height / 100);\n\n    case 'vw':\n      return scalar.value * (container.width / 100);\n\n    default:\n      return scalar.value;\n  }\n});\n/**\n * Transform units on given styles object.\n * Container is given to calculate vh and vw\n *\n * @param {Object} container\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\n\nvar transformUnits = function transformUnits(container, styles) {\n  return map(transformUnit(container), styles);\n};\n\nvar transformUnits$1 = curryN(2, transformUnits);\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\n\nvar resolveMediaQueries = function resolveMediaQueries(container, styles) {\n  return Object.keys(styles).reduce(function (acc, key) {\n    var _extends2;\n\n    if (/@media/.test(key)) {\n      var _matchMedia;\n\n      return _extends({}, acc, matchMedia((_matchMedia = {}, _matchMedia[key] = styles[key], _matchMedia), container));\n    }\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[key] = styles[key], _extends2));\n  }, {});\n};\n\nvar resolveMediaQueries$1 = curryN(2, resolveMediaQueries);\nvar LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline'\n};\n/**\n * Filter styles with `none` value\n *\n * @param {Object} style object\n * @returns {Object} style without none values\n */\n\nvar filterNoneValues = reject(equals('none'));\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} node\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\n\nvar resolveStyles = function resolveStyles(container) {\n  return compose(transformUnits$1(container), transformColors, transformStyles, expandStyles, resolveMediaQueries$1(container), filterNoneValues, flatten);\n};\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\n\n\nvar resolveNodeStyles = function resolveNodeStyles(container) {\n  return function (node) {\n    return o(when(isLink, evolve({\n      style: merge(LINK_STYLES)\n    })), evolve({\n      style: resolveStyles(container),\n      children: map(resolveNodeStyles(container))\n    }))(node);\n  };\n};\n/**\n * Resolves page styles\n *\n * @param {Object} document page\n * @returns {Object} document page with resolved styles\n */\n\n\nvar resolvePageStyles = function resolvePageStyles(page) {\n  var box = prop('box', page);\n  var style = prop('style', page);\n  var container = isEmpty(box) ? style : box;\n  return evolve({\n    style: resolveStyles(container),\n    children: map(resolveNodeStyles(container))\n  })(page);\n};\n/**\n * Resolves root styles\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved styles\n */\n\n\nvar resolveStyles$1 = evolve({\n  children: map(resolvePageStyles)\n});\n\nvar getTransformStyle = function getTransformStyle(s) {\n  return pathOr('50%', ['style', s]);\n};\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {Object} node origin\n */\n\n\nvar getOrigin = function getOrigin(node) {\n  if (!node.box) return {};\n  var _node$box = node.box,\n      left = _node$box.left,\n      top = _node$box.top,\n      width = _node$box.width,\n      height = _node$box.height;\n  var transformOriginX = getTransformStyle('transformOriginX')(node);\n  var transformOriginY = getTransformStyle('transformOriginY')(node);\n  var percentX = matchPercent(transformOriginX);\n  var percentY = matchPercent(transformOriginY);\n  var offsetX = percentX ? width * percentX.percent : transformOriginX;\n  var offsetY = percentY ? height * percentY.percent : transformOriginY;\n  return {\n    left: left + offsetX,\n    top: top + offsetY\n  };\n};\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\n\n\nvar resolveNodeOrigin = function resolveNodeOrigin(node) {\n  return compose(evolve({\n    children: map(resolveNodeOrigin)\n  }), converge(assoc('origin'), [getOrigin, identity]))(node);\n};\n/**\n * Resolve document origins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root\n */\n\n\nvar resolveOrigin = evolve({\n  children: map(resolveNodeOrigin)\n});\nvar VALID_ORIENTATIONS = [PORTRAIT, LANDSCAPE];\n/**\n * Get page orientation. Defaults to landscape\n *\n * @param { Object } page object\n * @returns { String } page orientation\n */\n\nvar getOrientation = compose(ifElse(includes(__, VALID_ORIENTATIONS), identity, always(PORTRAIT)), pathOr(PORTRAIT, ['props', 'orientation']));\nvar isLandscape = compose(equals(LANDSCAPE), getOrientation);\n/**\n * Transforms array into size object\n *\n * @param {Array} array\n * @returns {Object} size object with width and height\n */\n\nvar toSizeObject = applySpec({\n  width: prop(0),\n  height: prop(1)\n});\n/**\n * Flip size object\n *\n * @param {Object} size object\n * @returns {Object} flipped size object\n */\n\nvar flipSizeObject = applySpec({\n  width: prop('height'),\n  height: prop('width')\n});\n/**\n * Returns size object from a given string\n *\n * @param {String} page size string\n * @returns {Object} size object with width and height\n */\n\nvar getStringSize = compose(toSizeObject, prop(__, PAGE_SIZES), toUpper);\n/**\n * Returns size object from a single number\n *\n * @param {Number} page size number\n * @returns {Object} size object with width and height\n */\n\nvar getNumberSize = compose(toSizeObject, function (v) {\n  return [v];\n});\n/**\n * Throws invalid size error\n *\n * @param {String} invalid page size input\n */\n\nvar throwInvalidError = function throwInvalidError(size) {\n  throw new Error(\"Invalid Page size: \" + JSON.stringify(size));\n};\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {Object} size object with width and height\n */\n\n\nvar getSize = function getSize(page) {\n  var size = compose(cond([[is(String), getStringSize], [is(Array), toSizeObject], [is(Number), getNumberSize], [is(Object), identity], [T, throwInvalidError]]), pathOr('A4', ['props', 'size']))(page);\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n/**\n * Add empt box prop if not present in node\n *\n * @param {Object} node\n * @returns {Object} node with box prop\n */\n\n\nvar assocIfNil = function assocIfNil(key, value, target) {\n  return when(compose(isNil, prop(key)), assoc(key, value))(target);\n};\n\nvar assocIfNil$1 = curryN(3, assocIfNil);\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\n\nvar resolvePageSize = function resolvePageSize(page) {\n  var size = getSize(page);\n  return evolve({\n    style: merge(__, size)\n  })(page);\n};\n/**\n * Resolves page sizes\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved page sizes\n */\n\n\nvar resolvePageSizes = evolve({\n  children: map(compose(resolvePageSize, assocIfNil$1('style', {})))\n});\n/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {Number} height\n */\n\nvar lineIndexAtHeight = function lineIndexAtHeight(node, height) {\n  var y = 0;\n  if (!node.lines) return 0;\n\n  for (var i = 0; i < node.lines.length; i++) {\n    var line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n\n  return node.lines.length;\n};\n/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {Number} index\n */\n\n\nvar heightAtLineIndex = function heightAtLineIndex(node, index) {\n  var counter = 0;\n  if (!node.lines) return counter;\n\n  for (var i = 0; i < index; i++) {\n    var line = node.lines[i];\n    if (!line) break;\n    counter += line.box.height;\n  }\n\n  return counter;\n};\n\nvar zero = always(0);\nvar getTop = pathOr(0, ['box', 'top']);\nvar getWidows = pathOr(2, ['props', 'widows']);\nvar getOrphans = pathOr(2, ['props', 'orphans']);\n\nvar getLineBreak = function getLineBreak(node, height) {\n  var top = getTop(node);\n  var widows = getWidows(node);\n  var orphans = getOrphans(node);\n  var linesQuantity = node.lines.length;\n  var slicedLine = lineIndexAtHeight(node, height - top);\n\n  if (slicedLine === 0) {\n    return 0;\n  } else if (linesQuantity < orphans) {\n    return linesQuantity;\n  } else if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  } else if (linesQuantity === orphans + widows) {\n    return orphans;\n  } else if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n\n  return slicedLine;\n};\n\nvar splitText = function splitText(node, height) {\n  var slicedLineIndex = getLineBreak(node, height);\n  var currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  var nextHeight = node.box.height - currentHeight;\n  var current = evolve({\n    lines: slice(0, slicedLineIndex),\n    style: evolve({\n      marginBottom: zero,\n      paddingBottom: zero,\n      borderBottomWidth: zero,\n      borderBottomLeftRadius: zero,\n      borderBottomRightRadius: zero\n    }),\n    box: {\n      height: always(currentHeight),\n      borderBottomWidth: zero\n    }\n  }, node);\n  var next = evolve({\n    lines: slice(slicedLineIndex, Infinity),\n    style: evolve({\n      marginTop: zero,\n      paddingTop: zero,\n      borderTopWidth: zero,\n      borderTopLeftRadius: zero,\n      borderTopRightRadius: zero\n    }),\n    box: {\n      top: zero,\n      height: always(nextHeight),\n      borderTopWidth: zero\n    }\n  }, node);\n  return [current, next];\n};\n\nvar zero$1 = always(0);\nvar getTop$1 = pathOr(0, ['box', 'top']);\nvar hasFixedHeight = hasPath(['style', 'height']);\n\nvar subtractHeight = function subtractHeight(value) {\n  return o(subtract(__, value), path(['box', 'height']));\n};\n\nvar splitNode = function splitNode(node, height) {\n  if (!node) return [null, null];\n  var nodeTop = getTop$1(node); // TODO: We should keep style untouched\n\n  var current = evolve({\n    style: evolve({\n      marginBottom: zero$1,\n      paddingBottom: zero$1,\n      borderBottomWidth: zero$1,\n      borderBottomLeftRadius: zero$1,\n      borderBottomRightRadius: zero$1\n    }),\n    box: {\n      height: always(height - nodeTop),\n      borderBottomWidth: zero$1\n    }\n  })(node);\n  var nextHeight = ifElse(hasFixedHeight, subtractHeight(height - nodeTop), always(null))(node); // TODO: We should keep style untouched\n\n  var next = evolve({\n    style: evolve({\n      marginTop: zero$1,\n      paddingTop: zero$1,\n      borderTopWidth: zero$1,\n      borderTopLeftRadius: zero$1,\n      borderTopRightRadius: zero$1\n    }),\n    box: {\n      top: zero$1,\n      height: always(nextHeight),\n      borderTopWidth: zero$1\n    }\n  })(node);\n  return [current, next];\n};\n\nvar isString = is(String);\nvar isNumber$1 = is(Number);\nvar isNotString = complement(isString);\n/**\n * Transforms a react element instance to internal element format\n *\n * @param {Object} React element\n * @returns {Object} parsed react element\n */\n\nvar createInstance = function createInstance(element) {\n  if (isString(element) || isNumber$1(element)) return {\n    type: TEXT_INSTANCE,\n    value: \"\" + element\n  };\n  if (isNotString(element.type)) return createInstance(element.type(element.props));\n\n  var type = element.type,\n      _element$props = element.props,\n      _element$props$style = _element$props.style,\n      style = _element$props$style === void 0 ? {} : _element$props$style,\n      _element$props$childr = _element$props.children,\n      children = _element$props$childr === void 0 ? [] : _element$props$childr,\n      props = _objectWithoutPropertiesLoose(_element$props, [\"style\", \"children\"]);\n\n  var nextChildren = compose(map(createInstance), castArray)(children);\n  return {\n    type: type,\n    style: style,\n    props: props,\n    box: {},\n    children: nextChildren\n  };\n};\n/**\n * Get many nodes height\n *\n * @param {Array} nodes\n * @return {number} nodes height\n */\n\n\nvar getNodesHeight = function getNodesHeight(nodes) {\n  var max = 0;\n  var min = Infinity;\n  if (isEmpty(nodes)) return 0;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    min = Math.min(min, node.box.top);\n    max = Math.max(max, node.box.top + node.box.height);\n  }\n\n  return max - min;\n};\n\nvar getWrap = ifElse(anyPass([isSvg, isNote, isImage, isCanvas]), always(false), pathOr(true, ['props', 'wrap']));\nvar getBreak = pathOr(false, ['props', 'break']);\nvar getMinPresenceAhead = path(['props', 'minPresenceAhead']);\n\nvar defaultPresenceAhead = function defaultPresenceAhead(element) {\n  return function (height) {\n    return Math.min(element.box.height, height);\n  };\n};\n\nvar getPresenceAhead = function getPresenceAhead(elements, height) {\n  var result = 0;\n\n  for (var i = 0; i < elements.length; i++) {\n    var element = elements[i];\n    if (!element.box) continue;\n    var isElementInside = height > element.box.top;\n    var presenceAhead = element.props.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.box.top);\n    }\n  }\n\n  return result;\n};\n\nvar shouldBreak = function shouldBreak(child, futureElements, height) {\n  var minPresenceAhead = getMinPresenceAhead(child);\n  var presenceAhead = getPresenceAhead(futureElements, height);\n  var futureHeight = getNodesHeight(futureElements);\n  var shouldSplit = height < child.box.top + child.box.height;\n  var shouldWrap = getWrap(child);\n  return getBreak(child) || !shouldWrap && shouldSplit || minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead;\n};\n\nvar getComputedPadding = function getComputedPadding(edge) {\n  return function (node) {\n    var yogaNode = node._yogaNode;\n    return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n  };\n};\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} paddings\n */\n\n\nvar getPadding = applySpec({\n  paddingTop: firstPass(getComputedPadding(Yoga.EDGE_TOP), path(['box', 'paddingTop']), path(['style', 'paddingTop']), path(['style', 'paddingVertical']), path(['style', 'padding']), always(0)),\n  paddingRight: firstPass(getComputedPadding(Yoga.EDGE_RIGHT), path(['box', 'paddingRight']), path(['style', 'paddingRight']), path(['style', 'paddingHorizontal']), path(['style', 'padding']), always(0)),\n  paddingBottom: firstPass(getComputedPadding(Yoga.EDGE_BOTTOM), path(['box', 'paddingBottom']), path(['style', 'paddingBottom']), path(['style', 'paddingVertical']), path(['style', 'padding']), always(0)),\n  paddingLeft: firstPass(getComputedPadding(Yoga.EDGE_LEFT), path(['box', 'paddingLeft']), path(['style', 'paddingLeft']), path(['style', 'paddingHorizontal']), path(['style', 'padding']), always(0))\n});\n\nvar getContentArea = function getContentArea(page) {\n  var _getPadding = getPadding(page),\n      paddingTop = _getPadding.paddingTop;\n\n  var height = path(['style', 'height'], page);\n  return height - paddingTop;\n};\n\nvar IGNORABLE_CODEPOINTS = [8232, // LINE_SEPARATOR\n8233];\n\nvar buildSubsetForFont = function buildSubsetForFont(font) {\n  return IGNORABLE_CODEPOINTS.reduce(function (acc, codePoint) {\n    if (font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n\n    return [].concat(acc, [String.fromCharCode(codePoint)]);\n  }, []);\n};\n\nvar ignoreChars = function ignoreChars(fragments) {\n  return fragments.map(function (fragment) {\n    var charSubset = buildSubsetForFont(fragment.attributes.font);\n    var subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes\n    };\n  });\n};\n\nvar PREPROCESSORS = [ignoreChars, embedEmojis];\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\n\nvar getFragments$1 = function getFragments(instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$style = instance.style,\n      _instance$style$color = _instance$style.color,\n      color = _instance$style$color === void 0 ? 'black' : _instance$style$color,\n      backgroundColor = _instance$style.backgroundColor,\n      _instance$style$fontF = _instance$style.fontFamily,\n      fontFamily = _instance$style$fontF === void 0 ? 'Helvetica' : _instance$style$fontF,\n      fontWeight = _instance$style.fontWeight,\n      fontStyle = _instance$style.fontStyle,\n      _instance$style$fontS = _instance$style.fontSize,\n      fontSize = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS,\n      _instance$style$textA = _instance$style.textAlign,\n      textAlign = _instance$style$textA === void 0 ? 'left' : _instance$style$textA,\n      lineHeight = _instance$style.lineHeight,\n      textDecoration = _instance$style.textDecoration,\n      textDecorationColor = _instance$style.textDecorationColor,\n      textDecorationStyle = _instance$style.textDecorationStyle,\n      textTransform = _instance$style.textTransform,\n      letterSpacing = _instance$style.letterSpacing,\n      textIndent = _instance$style.textIndent,\n      opacity = _instance$style.opacity;\n  var obj = Font$1.getFont({\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  });\n  var font = obj ? obj.data : fontFamily;\n  var attributes = {\n    font: font,\n    color: color,\n    opacity: opacity,\n    fontSize: fontSize,\n    backgroundColor: backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null\n  };\n  instance.children.forEach(function (child) {\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: _extends({}, attributes, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else {\n      if (child) {\n        var _fragments;\n\n        (_fragments = fragments).push.apply(_fragments, getFragments(child));\n      }\n    }\n  });\n\n  for (var _i = 0; _i < PREPROCESSORS.length; _i++) {\n    var preprocessor = PREPROCESSORS[_i];\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\n\n\nvar getAttributedString$1 = function getAttributedString(instance) {\n  return AttributedString.fromFragments(getFragments$1(instance));\n};\n\nvar engines$1 = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine$1 = layoutEngine(engines$1);\n/**\n * Get layout container for specific text node\n *\n * @param {Object} node\n * @param {Number} width\n * @param {Number} height\n * @returns {Object} layout container\n */\n\nvar getContainer$1 = function getContainer(node, width, height) {\n  var maxLines = path(['style', 'maxLines'], node);\n  var textOverflow = path(['style', 'textOverflow'], node);\n  return {\n    x: 0,\n    y: 0,\n    width: width,\n    maxLines: maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow\n  };\n};\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\n\n\nvar getLayoutOptions = function getLayoutOptions(node) {\n  return {\n    hyphenationPenalty: node.props.hyphenationPenalty,\n    hyphenationCallback: Font$1.getHyphenationCallback(),\n    shrinkWhitespaceFactor: {\n      before: -0.5,\n      after: -0.5\n    }\n  };\n};\n/**\n * Get text lines for given node\n *\n * @param {Object} node\n * @param {Number} container width\n * @param {Number} container height\n * @returns {Array} layout lines\n */\n\n\nvar layoutText$1 = compose(reduce(concat, []), converge(engine$1, [getAttributedString$1, getContainer$1, getLayoutOptions]));\nvar isNotSvg = complement(isSvg);\n\nvar hasLines = function hasLines(node) {\n  return node.props.fixed ? !isEmpty(node.lines) : !!node.lines;\n};\n\nvar shouldLayoutText = function shouldLayoutText(node) {\n  return isText(node) && !hasLines(node);\n};\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layouted node\n */\n\n\nvar resolveTextLayout = function resolveTextLayout(node) {\n  return compose(evolve({\n    children: map(when(isNotSvg, resolveTextLayout))\n  }), when(shouldLayoutText, compose(converge(assoc('lines'), [converge(layoutText$1, [identity, path(['box', 'width']), path(['box', 'height'])]), identity]))))(node);\n};\n/**\n * Get styles sub group of inherited properties\n *\n * @param {Object} style object\n * @returns {Object} style object only with inherited properties\n */\n\n\nvar getInheritStyles = compose(pick(INHERITED_PROPERTIES), propOr({}, 'style'));\n/**\n * Merges styles with node\n *\n * @param {Object} style object\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\n\nvar mergeStyles$2 = function mergeStyles(styles) {\n  return evolve({\n    style: merge(styles)\n  });\n};\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} document root\n * @returns {Object} document root with inheritance\n *\n */\n\n\nvar resolveInheritance = function resolveInheritance(node) {\n  if (isSvg(node)) return node;\n  var inheritStyles = getInheritStyles(node);\n  return evolve({\n    children: map(compose(resolveInheritance, mergeStyles$2(inheritStyles)))\n  })(node);\n};\n\nvar getComputedMargin = function getComputedMargin(edge) {\n  return function (node) {\n    var yogaNode = node._yogaNode;\n    return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n  };\n};\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} margins\n */\n\n\nvar getMargin = applySpec({\n  marginTop: firstPass(getComputedMargin(Yoga.EDGE_TOP), path(['box', 'marginTop']), path(['style', 'marginTop']), path(['style', 'marginVertical']), path(['style', 'margin']), always(0)),\n  marginRight: firstPass(getComputedMargin(Yoga.EDGE_RIGHT), path(['box', 'marginRight']), path(['style', 'marginRight']), path(['style', 'marginHorizontal']), path(['style', 'margin']), always(0)),\n  marginBottom: firstPass(getComputedMargin(Yoga.EDGE_BOTTOM), path(['box', 'marginBottom']), path(['style', 'marginBottom']), path(['style', 'marginVertical']), path(['style', 'margin']), always(0)),\n  marginLeft: firstPass(getComputedMargin(Yoga.EDGE_LEFT), path(['box', 'marginLeft']), path(['style', 'marginLeft']), path(['style', 'marginHorizontal']), path(['style', 'margin']), always(0))\n});\n\nvar getTop$2 = function getTop(yogaNode) {\n  return yogaNode ? yogaNode.getComputedTop() : 0;\n};\n\nvar getRight = function getRight(yogaNode) {\n  return yogaNode ? yogaNode.getComputedRight() : 0;\n};\n\nvar getBottom = function getBottom(yogaNode) {\n  return yogaNode ? yogaNode.getComputedBottom() : 0;\n};\n\nvar getLeft = function getLeft(yogaNode) {\n  return yogaNode ? yogaNode.getComputedLeft() : 0;\n};\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} position\n */\n\n\nvar getPosition = function getPosition(node) {\n  var yogaNode = node._yogaNode;\n  return applySpec({\n    top: getTop$2,\n    right: getRight,\n    bottom: getBottom,\n    left: getLeft\n  })(yogaNode);\n};\n\nvar DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0\n};\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} dimensions\n */\n\nvar getDimension = function getDimension(node) {\n  var yogaNode = node._yogaNode;\n  if (!yogaNode) return DEFAULT_DIMENSION;\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight()\n  };\n};\n\nvar getComputedBorder = function getComputedBorder(edge) {\n  return function (yogaNode) {\n    return yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n  };\n};\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} border widths\n */\n\n\nvar getBorderWidth = function getBorderWidth(node) {\n  var yogaNode = node._yogaNode;\n  return applySpec({\n    borderTopWidth: getComputedBorder(Yoga.EDGE_TOP),\n    borderRightWidth: getComputedBorder(Yoga.EDGE_RIGHT),\n    borderBottomWidth: getComputedBorder(Yoga.EDGE_BOTTOM),\n    borderLeftWidth: getComputedBorder(Yoga.EDGE_LEFT)\n  })(yogaNode);\n};\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {String} display\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setDisplay = function setDisplay(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      yogaNode.setDisplay(value === 'none' ? Yoga.DISPLAY_NONE : Yoga.DISPLAY_FLEX);\n    }\n  });\n};\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {String} overflow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setOverflow = function setOverflow(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      var yogaValue = cond([[equals('hidden'), always(Yoga.OVERFLOW_HIDDEN)], [equals('scroll'), always(Yoga.OVERFLOW_SCROLL)], [T, always(Yoga.OVERFLOW_VISIBLE)]])(value);\n      yogaNode.setOverflow(yogaValue);\n    }\n  });\n};\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {String} flex wrap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setFlexWrap = function setFlexWrap(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      var yogaValue = cond([[equals('wrap'), always(Yoga.WRAP_WRAP)], [equals('wrap-reverse'), always(Yoga.WRAP_WRAP_REVERSE)], [T, always(Yoga.WRAP_NO_WRAP)]])(value);\n      yogaNode.setFlexWrap(yogaValue);\n    }\n  });\n};\n\nvar isNotNil$1 = complement(isNil);\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {String} property\n * @param {Number} edge\n * @param {any} value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setYogaValue = function setYogaValue(attr, edge) {\n  return function (value) {\n    return tap(function (node) {\n      var yogaNode = node._yogaNode;\n\n      if (!isNil(value) && yogaNode) {\n        var hasEdge = isNotNil$1(edge);\n        var fixedMethod = \"set\" + upperFirst$1(attr);\n        var autoMethod = fixedMethod + \"Auto\";\n        var percentMethod = fixedMethod + \"Percent\";\n        var percent = matchPercent(value);\n\n        if (percent && !yogaNode[percentMethod]) {\n          throw new Error(\"You can't pass percentage values to \" + attr + \" property\");\n        }\n\n        if (percent) {\n          hasEdge ? yogaNode[percentMethod](edge, percent.value) : yogaNode[percentMethod](percent.value);\n        } else if (value === 'auto') {\n          hasEdge ? yogaNode[autoMethod](edge) : yogaNode[autoMethod]();\n        } else {\n          hasEdge ? yogaNode[fixedMethod](edge, value) : yogaNode[fixedMethod](value);\n        }\n      }\n    });\n  };\n};\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {Number} flex grow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setFlexGrow = compose(setYogaValue('flexGrow'), defaultTo(0));\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {Number} flex basis value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setFlexBasis = setYogaValue('flexBasis');\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {String} specific align property\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setAlign = function setAlign(attr) {\n  return function (value) {\n    return tap(function (node) {\n      var yogaNode = node._yogaNode;\n\n      if (yogaNode) {\n        var yogaValue = cond([[equals('flex-start'), always(Yoga.ALIGN_FLEX_START)], [equals('center'), always(Yoga.ALIGN_CENTER)], [equals('flex-end'), always(Yoga.ALIGN_FLEX_END)], [equals('stretch'), always(Yoga.ALIGN_STRETCH)], [equals('baseline'), always(Yoga.ALIGN_BASELINE)], [equals('space-between'), always(Yoga.ALIGN_SPACE_BETWEEN)], [equals('space-around'), always(Yoga.ALIGN_SPACE_AROUND)], [T, always(attr === 'items' ? Yoga.ALIGN_STRETCH : Yoga.ALIGN_AUTO)]])(value);\n        yogaNode[\"setAlign\" + upperFirst$1(attr)](yogaValue);\n      }\n    });\n  };\n};\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setAlignSelf = setAlign('self');\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setAlignItems = setAlign('items');\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {Number} flex shrink value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setFlexShrink = compose(setYogaValue('flexShrink'), defaultTo(1));\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {Number} ratio\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setAspectRatio = function setAspectRatio(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n  });\n};\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setAlignContent = setAlign('content');\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {String} position type\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionType = function setPositionType(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      yogaNode.setPositionType(value === 'absolute' ? Yoga.POSITION_TYPE_ABSOLUTE : Yoga.POSITION_TYPE_RELATIVE);\n    }\n  });\n};\n\nvar isRow = equals('row');\nvar isRowReverse = equals('row-reverse');\nvar isColumnReverse = equals('column-reverse');\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {String} flex direction value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setFlexDirection = function setFlexDirection(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      var yogaValue = cond([[isRow, always(Yoga.FLEX_DIRECTION_ROW)], [isRowReverse, always(Yoga.FLEX_DIRECTION_ROW_REVERSE)], [isColumnReverse, always(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)], [T, always(Yoga.FLEX_DIRECTION_COLUMN)]])(value);\n      yogaNode.setFlexDirection(yogaValue);\n    }\n  });\n};\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {String} justify content value\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setJustifyContent = function setJustifyContent(value) {\n  return tap(function (node) {\n    var yogaNode = node._yogaNode;\n\n    if (!isNil(value) && yogaNode) {\n      var yogaValue = cond([[equals('center'), always(Yoga.JUSTIFY_CENTER)], [equals('flex-end'), always(Yoga.JUSTIFY_FLEX_END)], [equals('space-between'), always(Yoga.JUSTIFY_SPACE_BETWEEN)], [equals('space-around'), always(Yoga.JUSTIFY_SPACE_AROUND)], [equals('space-evenly'), always(Yoga.JUSTIFY_SPACE_EVENLY)], [T, always(Yoga.JUSTIFY_FLEX_START)]])(value);\n      yogaNode.setJustifyContent(yogaValue);\n    }\n  });\n};\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {Number} margin top\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\n\nvar setMarginTop = setYogaValue('margin', Yoga.EDGE_TOP);\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {Number} margin right\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMarginRight = setYogaValue('margin', Yoga.EDGE_RIGHT);\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {Number} margin bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMarginBottom = setYogaValue('margin', Yoga.EDGE_BOTTOM);\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {Number} margin left\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMarginLeft = setYogaValue('margin', Yoga.EDGE_LEFT);\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {Number} padding top\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingTop = setYogaValue('padding', Yoga.EDGE_TOP);\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {Number} padding right\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingRight = setYogaValue('padding', Yoga.EDGE_RIGHT);\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {Number} padding bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingBottom = setYogaValue('padding', Yoga.EDGE_BOTTOM);\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {Number} padding left\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPaddingLeft = setYogaValue('padding', Yoga.EDGE_LEFT);\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {Number} border top width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderTop = setYogaValue('border', Yoga.EDGE_TOP);\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {Number} border right width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderRight = setYogaValue('border', Yoga.EDGE_RIGHT);\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {Number} border bottom width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderBottom = setYogaValue('border', Yoga.EDGE_BOTTOM);\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {Number} border left width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setBorderLeft = setYogaValue('border', Yoga.EDGE_LEFT);\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {Number} position top\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionTop = setYogaValue('position', Yoga.EDGE_TOP);\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {Number} position right\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionRight = setYogaValue('position', Yoga.EDGE_RIGHT);\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {Number} position bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionBottom = setYogaValue('position', Yoga.EDGE_BOTTOM);\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {Number} position left\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setPositionLeft = setYogaValue('position', Yoga.EDGE_LEFT);\n/**\n * Set width to node's Yoga instance\n *\n * @param {Number} width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setWidth = setYogaValue('width');\n/**\n * Set min width to node's Yoga instance\n *\n * @param {Number} min width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMinWidth = setYogaValue('minWidth');\n/**\n * Set max width to node's Yoga instance\n *\n * @param {Number} max width\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMaxWidth = setYogaValue('maxWidth');\n/**\n * Set height to node's Yoga instance\n *\n * @param {Number} height\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setHeight = setYogaValue('height');\n/**\n * Set min height to node's Yoga instance\n *\n * @param {Number} min height\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMinHeight = setYogaValue('minHeight');\n/**\n * Set max height to node's Yoga instance\n *\n * @param {Number} max height\n * @param {Object} node instance\n * @return {Object} node instance\n */\n\nvar setMaxHeight = setYogaValue('maxHeight');\n\nvar getAspectRatio = function getAspectRatio(viewbox) {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\n\n\nvar measureCanvas = function measureCanvas(page, node, width, widthMode, height, heightMode) {\n  var aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY || widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    return {\n      width: width,\n      height: width / aspectRatio\n    };\n  }\n\n  if (heightMode === Yoga.MEASURE_MODE_EXACTLY) {\n    return {\n      width: height * aspectRatio\n    };\n  }\n\n  return {};\n};\n\nvar measureSvg = curryN(6, measureCanvas);\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {Number} lines width\n */\n\nvar linesWidth = function linesWidth(node) {\n  if (!node.lines) return -1;\n  return Math.max.apply(Math, node.lines.map(function (line) {\n    return AttributedString.advanceWidth(line);\n  }));\n};\n/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {Number} lines height\n */\n\n\nvar linesHeight = function linesHeight(node) {\n  if (!node.lines) return -1;\n  return node.lines.reduce(function (acc, line) {\n    return acc + line.box.height;\n  }, 0);\n};\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} text width and height\n */\n\n\nvar measureText = function measureText(page, node, width, widthMode, height, heightMode) {\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n    if (!node.lines) node.lines = layoutText$1(node, width, height);\n    return {\n      height: linesHeight(node)\n    };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (!node.lines) node.lines = layoutText$1(node, width, height);\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node))\n    };\n  }\n\n  return {};\n};\n\nvar measureText$1 = curryN(6, measureText);\n/**\n * Get image ratio\n *\n * @param {Object} image node\n * @returns {Number} image ratio\n */\n\nvar getRatio = ifElse(hasPath(['image', 'data']), function (node) {\n  return node.image.width / node.image.height;\n}, always(1));\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {Boolean} is page height auto\n */\n\nvar isHeightAuto = pathSatisfies(isNil, ['box', 'height']);\nvar SAFETY_HEIGHT = 10;\n/**\n * Yoga image measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} image width and height\n */\n\nvar measureImage = function measureImage(page, node, width, widthMode, height, heightMode) {\n  var imageRatio = getRatio(node);\n  var imageMargin = getMargin(node);\n  var pagePadding = getPadding(page);\n  var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT; // Skip measure if image data not present yet\n\n  if (!node.image) return {\n    width: 0,\n    height: 0\n  };\n\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_UNDEFINED) {\n    var scaledHeight = width / imageRatio;\n    return {\n      height: Math.min(pageArea, scaledHeight)\n    };\n  }\n\n  if (heightMode === Yoga.MEASURE_MODE_EXACTLY && (widthMode === Yoga.MEASURE_MODE_AT_MOST || widthMode === Yoga.MEASURE_MODE_UNDEFINED)) {\n    return {\n      width: Math.min(height * imageRatio, width)\n    };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n    var _scaledHeight = width / imageRatio;\n\n    return {\n      height: Math.min(height, pageArea, _scaledHeight)\n    };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (imageRatio > 1) {\n      return {\n        width: width,\n        height: Math.min(width / imageRatio, height)\n      };\n    } else {\n      return {\n        width: Math.min(height * imageRatio, width),\n        height: height\n      };\n    }\n  }\n\n  return {\n    height: height,\n    width: width\n  };\n};\n\nvar measureImage$1 = curryN(6, measureImage);\nvar SAFETY_HEIGHT$1 = 10;\nvar getMax = reduce(max$1, -Infinity);\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\n\nvar measureCtx = function measureCtx() {\n  var ctx = {};\n  var points = [];\n\n  var nil = function nil() {\n    return ctx;\n  };\n\n  var addPoint = function addPoint(x, y) {\n    return points.push([x, y]);\n  };\n\n  var moveTo = compose(nil, addPoint);\n\n  var rect = function rect(x, y, w, h) {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n\n  var ellipse = function ellipse(x, y, rx, ry) {\n    ry = ry || rx;\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n    return ctx;\n  };\n\n  var polygon = function polygon() {\n    points.push.apply(points, arguments);\n    return nil();\n  }; // Change dimensions\n\n\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect; // To be implemented\n\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil; // These don't change dimensions\n\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n\n  ctx.getWidth = function () {\n    return compose(getMax, pluck(0))(points);\n  };\n\n  ctx.getHeight = function () {\n    return compose(getMax, pluck(1))(points);\n  };\n\n  return ctx;\n};\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\n\n\nvar measureCanvas$1 = function measureCanvas(page, node) {\n  var imageMargin = getMargin(node);\n  var pagePadding = getPadding(page);\n  var pageArea = isHeightAuto(page) ? Infinity : page.box.height - pagePadding.paddingTop - pagePadding.paddingBottom - imageMargin.marginTop - imageMargin.marginBottom - SAFETY_HEIGHT$1;\n  var ctx = measureCtx();\n  node.props.paint(ctx);\n  var width = ctx.getWidth();\n  var height = Math.min(pageArea, ctx.getHeight());\n  return {\n    height: height,\n    width: width\n  };\n};\n\nvar measureCanvas$2 = curryN(6, measureCanvas$1);\nvar YOGA_NODE = '_yogaNode';\nvar YOGA_CONFIG = Yoga.Config.create();\nYOGA_CONFIG.setPointScaleFactor(0);\n\nvar setNodeHeight = function setNodeHeight(node) {\n  return ifElse(isPage, setHeight(node.box.height), setHeight(node.box.height || node.style.height));\n};\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar setYogaValues = tap(function (node) {\n  compose(setNodeHeight(node), setWidth(node.style.width), setMinWidth(node.style.minWidth), setMaxWidth(node.style.maxWidth), setMinHeight(node.style.minHeight), setMaxHeight(node.style.maxHeight), setMarginTop(node.style.marginTop), setMarginRight(node.style.marginRight), setMarginBottom(node.style.marginBottom), setMarginLeft(node.style.marginLeft), setPaddingTop(node.style.paddingTop), setPaddingRight(node.style.paddingRight), setPaddingBottom(node.style.paddingBottom), setPaddingLeft(node.style.paddingLeft), setPositionType(node.style.position), setPositionTop(node.style.top), setPositionRight(node.style.right), setPositionBottom(node.style.bottom), setPositionLeft(node.style.left), setBorderTop(node.style.borderTopWidth), setBorderRight(node.style.borderRightWidth), setBorderBottom(node.style.borderBottomWidth), setBorderLeft(node.style.borderLeftWidth), setDisplay(node.style.display), setFlexDirection(node.style.flexDirection), setAlignSelf(node.style.alignSelf), setAlignContent(node.style.alignContent), setAlignItems(node.style.alignItems), setJustifyContent(node.style.justifyContent), setFlexWrap(node.style.flexWrap), setOverflow(node.style.overflow), setAspectRatio(node.style.aspectRatio), setFlexBasis(node.style.flexBasis), setFlexGrow(node.style.flexGrow), setFlexShrink(node.style.flexShrink))(node);\n});\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent\n * @param {Object} node\n * @param {Object} node\n */\n\nvar insertYogaNodes = function insertYogaNodes(parent) {\n  return tap(function (child) {\n    return parent.insertChild(child[YOGA_NODE], parent.getChildCount());\n  });\n};\n\nvar setMeasureFunc = function setMeasureFunc(page) {\n  return function (node) {\n    var yogaNode = node[YOGA_NODE];\n\n    if (isText(node)) {\n      yogaNode.setMeasureFunc(measureText$1(page, node));\n    }\n\n    if (isImage(node)) {\n      yogaNode.setMeasureFunc(measureImage$1(page, node));\n    }\n\n    if (isCanvas(node)) {\n      yogaNode.setMeasureFunc(measureCanvas$2(page, node));\n    }\n\n    if (isSvg(node)) {\n      yogaNode.setMeasureFunc(measureSvg(page, node));\n    }\n\n    return node;\n  };\n};\n\nvar isNotText = complement(isText);\nvar isNotNote = complement(isNote);\nvar isNotSvg$1 = complement(isSvg);\nvar isNotTextInstance = complement(isTextInstance);\nvar isLayoutElement = allPass([isNotText, isNotNote, isNotSvg$1]);\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\n\nvar createYogaNodes = function createYogaNodes(page) {\n  return function (node) {\n    var yogaNode = Yoga.Node.createWithConfig(YOGA_CONFIG);\n    return compose(setMeasureFunc(page), when(isLayoutElement, evolve({\n      children: map(compose(insertYogaNodes(yogaNode), createYogaNodes(page)))\n    })), setYogaValues, assoc(YOGA_NODE, yogaNode))(node);\n  };\n};\n/**\n * Performs yoga calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar calculateLayout = tap(function (page) {\n  return page[YOGA_NODE].calculateLayout();\n});\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\n\nvar persistDimensions = function persistDimensions(node) {\n  return evolve({\n    children: map(when(isNotTextInstance, persistDimensions)),\n    box: always(mergeAll([getPadding(node), getMargin(node), getBorderWidth(node), getPosition(node), getDimension(node)]))\n  })(node);\n};\n/**\n * Removes and destroys yoga node frm document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\n\n\nvar destroyYogaNodes = function destroyYogaNodes(node) {\n  return compose(dissoc(YOGA_NODE), tap(function (n) {\n    return Yoga.Node.destroy(n[YOGA_NODE]);\n  }), evolve({\n    children: map(when(isLayoutElement, destroyYogaNodes))\n  }))(node);\n};\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\n\n\nvar resolvePageDimensions = function resolvePageDimensions(page) {\n  return ifElse(isNil, always(null), compose(destroyYogaNodes, persistDimensions, calculateLayout, createYogaNodes(page)))(page);\n};\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} root object\n * @returns {Object} root object with correct 'box' layout attributes\n */\n\n\nvar resolveDimensions = function resolveDimensions(node) {\n  return evolve({\n    children: map(resolvePageDimensions)\n  })(node);\n};\n\nvar SAFTY_THRESHOLD = 0.001;\nvar assingChildren = assoc('children');\nvar getTop$3 = pathOr(0, ['box', 'top']);\nvar getHeight = path(['box', 'height']);\nvar getChildren$1 = propOr([], 'children');\nvar isElementOutside = useWith(lte, [identity, getTop$3]);\nvar isFixed = pathEq(['props', 'fixed'], true);\nvar allFixed = all(isFixed);\nvar isDynamic = hasPath(['props', 'render']);\nvar relayoutPage = compose(resolveTextLayout, resolveInheritance, resolvePageDimensions);\n\nvar splitView = function splitView(node, height) {\n  var _splitNode = splitNode(node, height),\n      currentNode = _splitNode[0],\n      nextNode = _splitNode[1];\n\n  var _splitChildren = splitChildren(height, node),\n      currentChilds = _splitChildren[0],\n      nextChildren = _splitChildren[1];\n\n  return [assingChildren(currentChilds)(currentNode), assingChildren(nextChildren)(nextNode)];\n};\n\nvar split = ifElse(isText, splitText, splitView);\n\nvar splitNodes = function splitNodes(height, nodes) {\n  var currentChildren = [];\n  var nextChildren = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var child = nodes[i];\n    var futureNodes = nodes.slice(i + 1);\n    var futureFixedNodes = filter(isFixed, futureNodes);\n    var nodeTop = getTop$3(child);\n    var nodeHeight = getHeight(child);\n    var isOutside = isElementOutside(height, child);\n    var shouldBreak$1 = shouldBreak(child, futureNodes, height);\n    var shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;\n\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n\n    if (isOutside) {\n      var next = evolve({\n        box: {\n          top: subtract(__, height)\n        }\n      })(child);\n      nextChildren.push(next);\n      continue;\n    }\n\n    if (shouldBreak$1) {\n      var _next = evolve({\n        box: {\n          top: subtract(__, height)\n        },\n        props: evolve({\n          break: always(false)\n        })\n      })(child);\n\n      currentChildren.push.apply(currentChildren, futureFixedNodes);\n      nextChildren.push.apply(nextChildren, [_next].concat(futureNodes));\n      break;\n    }\n\n    if (shouldSplit) {\n      var _split = split(child, height),\n          currentChild = _split[0],\n          nextChild = _split[1];\n\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n      continue;\n    }\n\n    currentChildren.push(child);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nvar splitChildren = function splitChildren(height, node) {\n  var children = getChildren$1(node);\n  var availableHeight = height - getTop$3(node);\n  return splitNodes(availableHeight, children);\n};\n\nvar splitPage = function splitPage(page, pageNumber) {\n  var contentArea = getContentArea(page);\n  var height = path(['style', 'height'], page);\n  var dynamicPage = resolveDynamicPage({\n    pageNumber: pageNumber\n  }, page);\n\n  var _splitNodes = splitNodes(contentArea, dynamicPage.children),\n      currentChilds = _splitNodes[0],\n      nextChilds = _splitNodes[1];\n\n  var currentPage = compose(relayoutPage, assingChildren(currentChilds), assocPath(['box', 'height'], height))(page);\n  if (isEmpty(nextChilds) || allFixed(nextChilds)) return [currentPage, null];\n  var nextPage = compose(relayoutPage, assingChildren(nextChilds), dissocPath(['box', 'height']))(page);\n  return [currentPage, nextPage];\n};\n\nvar shouldResolveDynamicNodes = function shouldResolveDynamicNodes(node) {\n  return either(isDynamic, compose(any(shouldResolveDynamicNodes), propOr([], 'children')))(node);\n};\n\nvar resolveDynamicPage = function resolveDynamicPage(props, page) {\n  return when(shouldResolveDynamicNodes, compose(relayoutPage, resolveDynamicNodes(props)))(page);\n};\n\nvar resolveDynamicNodes = function resolveDynamicNodes(props) {\n  return function (node) {\n    var isNodeDynamic = always(isDynamic(node));\n\n    var resolveRender = function resolveRender() {\n      var res = node.props.render(props);\n      return [createInstance(res)];\n    };\n\n    return evolve({\n      children: ifElse(isNodeDynamic, resolveRender, map(resolveDynamicNodes(props))),\n      lines: when(isNodeDynamic, always([]))\n    }, node);\n  };\n};\n\nvar paginate = function paginate(page, pageNumber) {\n  if (!page) return [];\n  var splittedPage = splitPage(page, pageNumber);\n  var pages = [splittedPage[0]];\n  var nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length);\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n\nvar resolvePageIndices = function resolvePageIndices(page, pageNumber, pages) {\n  var totalPages = pages.length;\n  return resolveDynamicPage({\n    pageNumber: pageNumber + 1,\n    totalPages: totalPages\n  }, page);\n};\n\nvar resolvePagination = function resolvePagination(doc) {\n  var pages = [];\n  var pageNumber = 1;\n\n  for (var i = 0; i < doc.children.length; i++) {\n    var page = doc.children[i];\n    var subpages = paginate(page, pageNumber);\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n\n  pages = pages.map(resolvePageIndices);\n  return assingChildren(pages, doc);\n};\n/**\n * Removes margins on node\n *\n * @param {Object} node\n * @returns {Object} node without margins\n */\n\n\nvar removeMargins = compose(dissocPath(['style', 'margin']), dissocPath(['style', 'marginTop']), dissocPath(['style', 'marginRight']), dissocPath(['style', 'marginBottom']), dissocPath(['style', 'marginLeft']), dissocPath(['style', 'marginHorizontal']), dissocPath(['style', 'marginVertical']));\n/**\n * Remove page margins\n *\n * @param {Object} document root\n * @returns {Object} document root without margins on pages\n */\n\nvar resolvePageMargins = evolve({\n  children: map(removeMargins)\n});\n/**\n * Get node underlying text value\n *\n * @param {Object} node\n * @returns {String} node text content\n */\n\nvar getNodeText = function getNodeText(node) {\n  return cond([[is(String), identity], [isTextInstance, prop('value')], [T, compose(getNodesText, propOr([], 'children'))]])(node);\n};\n/**\n * Get underlying text value of several nodes\n *\n * @param {Array} nodes\n * @returns {String} nodes text content\n */\n\n\nvar getNodesText = compose(join(''), map(getNodeText));\n/**\n * Transforms string to text instance\n *\n * @param {String} value\n * @returns {Array} text intance\n */\n\nvar wrapTextInstance = function wrapTextInstance(value) {\n  return [{\n    type: 'TEXT_INSTANCE',\n    value: value\n  }];\n};\n/**\n * Cast Note children as a text instance\n *\n * @param {Object} node\n * @returns {Object} node with resolved note children\n */\n\n\nvar resolveNoteChildren = function resolveNoteChildren(node) {\n  return ifElse(isNote, evolve({\n    children: compose(wrapTextInstance, getNodesText)\n  }), evolve({\n    children: map(resolveNoteChildren)\n  }))(node);\n};\n/*\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\n\n\nvar resolvePageHorizontalPadding = function resolvePageHorizontalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * container.width : value;\n  };\n};\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\n\n\nvar resolvePageVerticalPadding = function resolvePageVerticalPadding(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * container.height : value;\n  };\n};\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\n\n\nvar resolvePagePaddings = function resolvePagePaddings(page) {\n  var container = pathOr({}, ['props', 'size'], page);\n  return evolve({\n    style: evolve({\n      paddingLeft: resolvePageHorizontalPadding(container),\n      paddingRight: resolvePageHorizontalPadding(container),\n      paddingTop: resolvePageVerticalPadding(container),\n      paddingBottom: resolvePageVerticalPadding(container)\n    })\n  })(page);\n};\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} document root\n * @returns {Object} document root with translated page paddings\n */\n\n\nvar resolvePagePaddings$1 = evolve({\n  children: map(resolvePagePaddings)\n});\n/**\n *\n * @param {Object} container width and height\n * @param {String | Number} value border radius value\n * @returns {Number} fixed border radius value\n */\n\nvar resolveRadius = function resolveRadius(container) {\n  return function (value) {\n    var match = matchPercent(value);\n    return match ? match.percent * Math.min(container.width, container.height) : value;\n  };\n};\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\n\n\nvar resolvePercentRadius = function resolvePercentRadius(node) {\n  return evolve({\n    children: map(resolvePercentRadius),\n    style: evolve({\n      borderTopLeftRadius: resolveRadius(node.box),\n      borderTopRightRadius: resolveRadius(node.box),\n      borderBottomRightRadius: resolveRadius(node.box),\n      borderBottomLeftRadius: resolveRadius(node.box)\n    })\n  })(node);\n};\n/**\n * Transform percent height into fixed\n *\n * @param {String | number} height\n * @return {number} height\n */\n\n\nvar transformHeight = function transformHeight(pageArea) {\n  return function (height) {\n    var match = matchPercent(height);\n    return match ? match.percent * pageArea : height;\n  };\n};\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @return {number} page area\n */\n\n\nvar getPageArea = function getPageArea(page) {\n  var pageHeight = path(['style', 'height'], page);\n  var pagePaddingTop = pathOr(0, ['style', 'paddingTop'], page);\n  var pagePaddingBottom = pathOr(0, ['style', 'paddingBottom'], page);\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n/**\n * Checks if page has height\n *\n * @param {Object} page\n * @return {boolean} page has height\n */\n\n\nvar hasHeight = hasPath(['style', 'height']);\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @return {Object} transformed node\n */\n\nvar resolveNodePercentHeight = function resolveNodePercentHeight(page) {\n  return function (node) {\n    if (hasHeight(page)) {\n      var pageArea = getPageArea(page);\n      return evolve({\n        style: {\n          height: transformHeight(pageArea)\n        }\n      })(node);\n    }\n\n    return node;\n  };\n};\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @return {Object} transformed page\n */\n\n\nvar resolvePagePercentHeight = function resolvePagePercentHeight(page) {\n  return evolve({\n    children: map(resolveNodePercentHeight(page))\n  })(page);\n};\n/**\n * Transform all page immediate children with percent height to fixed\n *\n * @param {Object} document root\n * @return {Object} transformed document root\n */\n\n\nvar resolvePercentHeight = evolve({\n  children: map(resolvePagePercentHeight)\n});\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {Boolean} has render prop?\n */\n\nvar hasRenderProp = hasPath(['props', 'render']);\n/**\n * Checks if all children of node are text instances\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\n\nvar hasTextInstanceChilds = compose(all(isTextInstance), propOr([], 'children'));\n/**\n * If the Link has a string child or render prop, substitute the instance by a Text,\n * that will ultimately render the inline Link via the textkit PDF renderer.\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\n\nvar resolveLinkSubstitution = function resolveLinkSubstitution(node) {\n  return evolve({\n    children: map(ifElse(both(isLink, either(hasRenderProp, hasTextInstanceChilds)), assoc('type', TEXT), resolveLinkSubstitution))\n  })(node);\n};\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param  {...any} functions\n */\n\n\nvar asyncCompose = function asyncCompose() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(value) {\n      var _iterator, _isArray, _i, _ref2, fn;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iterator = reverse(fns), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();\n\n            case 1:\n              if (!_isArray) {\n                _context.next = 7;\n                break;\n              }\n\n              if (!(_i >= _iterator.length)) {\n                _context.next = 4;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 17);\n\n            case 4:\n              _ref2 = _iterator[_i++];\n              _context.next = 11;\n              break;\n\n            case 7:\n              _i = _iterator.next();\n\n              if (!_i.done) {\n                _context.next = 10;\n                break;\n              }\n\n              return _context.abrupt(\"break\", 17);\n\n            case 10:\n              _ref2 = _i.value;\n\n            case 11:\n              fn = _ref2;\n              _context.next = 14;\n              return fn(value);\n\n            case 14:\n              value = _context.sent;\n\n            case 15:\n              _context.next = 1;\n              break;\n\n            case 17:\n              return _context.abrupt(\"return\", value);\n\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function (_x) {\n      return _ref.apply(this, arguments);\n    };\n  }();\n}; // import * as R from 'ramda';\n// const endTimer = name => R.tap(() => console.timeEnd(name));\n\n\nvar layout = asyncCompose(resolveZIndex, resolveRulers, resolveOrigin, resolvePagination, resolveTextLayout, resolvePercentRadius, resolveDimensions, resolveSvg, resolveAssets, resolveInheritance, resolvePercentHeight, resolvePagePaddings$1, resolveStyles$1, resolveNoteChildren, resolveLinkSubstitution, resolvePageMargins, resolvePageSizes);\n/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\n\nvar propsEqual = function propsEqual(a, b) {\n  var oldPropsKeys = Object.keys(a);\n  var newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < oldPropsKeys.length; i++) {\n    var propName = oldPropsKeys[i];\n\n    if (propName === 'render') {\n      if (!a[propName] !== !b[propName]) {\n        return false;\n      }\n\n      continue;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (typeof a[propName] === 'object' && typeof b[propName] === 'object' && propsEqual(a[propName], b[propName])) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (propName === 'children' && (typeof a[propName] === 'string' || typeof b[propName] === 'string')) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nvar emptyObject = {};\n\nvar createRenderer = function createRenderer(_ref) {\n  var _ref$onChange = _ref.onChange,\n      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;\n  return ReactFiberReconciler({\n    schedulePassiveEffects: unstable_scheduleCallback,\n    cancelPassiveEffects: unstable_cancelCallback,\n    supportsMutation: true,\n    isPrimaryRenderer: false,\n    warnsIfNotActing: false,\n    appendInitialChild: function appendInitialChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n    createInstance: function createInstance(type, _ref2) {\n      var style = _ref2.style,\n          children = _ref2.children,\n          props = _objectWithoutPropertiesLoose(_ref2, [\"style\", \"children\"]);\n\n      return {\n        type: type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: []\n      };\n    },\n    createTextInstance: function createTextInstance(text, rootContainerInstance) {\n      return {\n        type: 'TEXT_INSTANCE',\n        value: text\n      };\n    },\n    finalizeInitialChildren: function finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n    getPublicInstance: function getPublicInstance(instance) {\n      return instance;\n    },\n    prepareForCommit: function prepareForCommit() {// Noop\n    },\n    prepareUpdate: function prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n    resetAfterCommit: onChange,\n    resetTextContent: function resetTextContent(element) {// Noop\n    },\n    getRootHostContext: function getRootHostContext() {\n      return emptyObject;\n    },\n    getChildHostContext: function getChildHostContext() {\n      return emptyObject;\n    },\n    shouldSetTextContent: function shouldSetTextContent(type, props) {\n      return false;\n    },\n    now: Date.now,\n    useSyncScheduling: true,\n    appendChild: function appendChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n    appendChildToContainer: function appendChildToContainer(parentInstance, child) {\n      if (parentInstance.type === 'ROOT') {\n        parentInstance.document = child;\n      } else {\n        parentInstance.children.push(child);\n      }\n    },\n    insertBefore: function insertBefore(parentInstance, child, beforeChild) {\n      var index = parentInstance.children.indexOf(beforeChild);\n      if (index !== -1 && child) parentInstance.children.splice(index, 0, child);\n    },\n    removeChild: function removeChild(parentInstance, child) {\n      var index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n    removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {\n      var index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n    commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n    },\n    commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      var style = newProps.style,\n          props = _objectWithoutPropertiesLoose(newProps, [\"style\"]);\n\n      instance.props = props;\n      instance.style = style;\n    }\n  });\n};\n\nvar create = function create(styles) {\n  return styles;\n};\n\nvar absoluteFillObject = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0\n};\nvar StyleSheet = {\n  hairlineWidth: 1,\n  create: create,\n  flatten: flatten,\n  absoluteFillObject: absoluteFillObject\n};\nvar version = \"2.0.0-beta.6\";\nvar View = VIEW;\nvar Text = TEXT;\nvar Link = LINK;\nvar Page = PAGE;\nvar Note = NOTE;\nvar Image = IMAGE;\nvar Document = DOCUMENT;\nvar Canvas = CANVAS;\nvar Svg = SVG;\nvar G = GROUP;\nvar Path = PATH;\nvar Rect = RECT;\nvar Line = LINE;\nvar Circle = CIRCLE;\nvar Ellipse = ELLIPSE;\nvar Polygon = POLYGON;\nvar Polyline = POLYLINE;\nvar Defs = DEFS;\nvar Tspan = TSPAN;\nvar ClipPath = CLIP_PATH;\nvar Stop = STOP;\nvar LinearGradient = LINEAR_GRADIENT;\nvar RadialGradient = RADIAL_GRADIENT;\n\nvar pdf = function pdf(_ref) {\n  var initialValue = _ref.initialValue,\n      onChange = _ref.onChange;\n  var container = {\n    type: 'ROOT',\n    document: null\n  };\n  var PDFRenderer = createRenderer({\n    onChange: onChange\n  });\n  var mountNode = PDFRenderer.createContainer(container);\n  if (initialValue) updateContainer(initialValue);\n\n  var render$1 = /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var ctx, layout$1;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              ctx = new PDFDocument({\n                autoFirstPage: false\n              });\n              console.time('layout');\n              _context.next = 4;\n              return layout(container.document);\n\n            case 4:\n              layout$1 = _context.sent;\n              console.timeEnd('layout');\n              return _context.abrupt(\"return\", render(ctx, layout$1));\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n\n    return function render() {\n      return _ref2.apply(this, arguments);\n    };\n  }();\n\n  var layout$1 = /*#__PURE__*/function () {\n    var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", layout(container));\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n\n    return function layout() {\n      return _ref3.apply(this, arguments);\n    };\n  }();\n\n  function updateContainer(doc) {\n    PDFRenderer.updateContainer(doc, mountNode, null);\n  }\n\n  function callOnRender(params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (container.document.props.onRender) {\n      container.document.props.onRender(params);\n    }\n  }\n\n  function toBlob() {\n    return _toBlob.apply(this, arguments);\n  }\n\n  function _toBlob() {\n    _toBlob = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      var instance, stream;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return render$1();\n\n            case 2:\n              instance = _context3.sent;\n              stream = instance.pipe(BlobStream());\n              return _context3.abrupt(\"return\", new Promise(function (resolve, reject) {\n                stream.on('finish', function () {\n                  try {\n                    var blob = stream.toBlob('application/pdf');\n                    callOnRender({\n                      blob: blob\n                    });\n                    resolve(blob);\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n                stream.on('error', reject);\n              }));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }));\n    return _toBlob.apply(this, arguments);\n  }\n\n  function toBuffer() {\n    return _toBuffer.apply(this, arguments);\n  }\n\n  function _toBuffer() {\n    _toBuffer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              callOnRender();\n              return _context4.abrupt(\"return\", render$1());\n\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n    return _toBuffer.apply(this, arguments);\n  }\n\n  function toString() {\n    var result = '';\n    var instance = render$1();\n    return new Promise(function (resolve, reject) {\n      try {\n        instance.on('data', function (buffer) {\n          result += buffer;\n        });\n        instance.on('end', function () {\n          resolve(result);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    layout: layout$1,\n    container: container,\n    updateContainer: updateContainer,\n    toBuffer: toBuffer,\n    toBlob: toBlob,\n    toString: toString\n  };\n};\n\nvar svgpath = require('svgpath');\n\nvar queue = require('queue');\n\nvar canvasInstance = function canvasInstance(canvas) {\n  var instance = {};\n  var images = {};\n  var ctx = canvas.getContext('2d');\n  var fillColor = 'white';\n\n  var nil = function nil() {\n    return instance;\n  };\n\n  instance.info = {};\n  instance.end = nil;\n  instance.font = nil;\n\n  instance.translate = function (x, y) {\n    ctx.translate(x, y);\n    return instance;\n  };\n\n  instance.addPage = function (_ref) {\n    var size = _ref.size;\n    canvas.width = size[0];\n    canvas.height = size[1];\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  instance.save = function () {\n    ctx.save();\n    return instance;\n  };\n\n  instance.restore = function () {\n    ctx.restore();\n    return instance;\n  };\n\n  instance.moveTo = function (x, y) {\n    ctx.moveTo(x, y);\n    return instance;\n  };\n\n  instance.lineTo = function (x, y) {\n    ctx.lineTo(x, y);\n    return instance;\n  };\n\n  instance.bezierCurveTo = function (a, b, c, d, e, f) {\n    ctx.bezierCurveTo(a, b, c, d, e, f);\n    return instance;\n  };\n\n  instance.closePath = function () {\n    ctx.closePath();\n    return instance;\n  };\n\n  instance.clip = function () {\n    ctx.clip();\n    return instance;\n  };\n\n  instance.fillColor = function (color) {\n    fillColor = color;\n    return instance;\n  };\n\n  instance.rect = function (a, b, c, d) {\n    ctx.rect(a, b, c, d);\n    return instance;\n  };\n\n  instance.fill = function () {\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    return instance;\n  };\n\n  instance.fillOpacity = function (opacity) {\n    ctx.globalAlpha = opacity;\n    return instance;\n  };\n\n  instance._addGlyphs = function (glyphs, positions) {\n    var xAdvance = 0;\n    var fontSize = 20;\n    var unitsPerEm = 2048;\n\n    for (var i = 0; i < glyphs.length; i++) {\n      var glyph = glyphs[i];\n      var position = positions[i];\n      var path = svgpath(glyph.path.toSVG()).scale(1, -1).scale(fontSize / unitsPerEm).translate(xAdvance, 0).toString();\n      xAdvance += position.xAdvance;\n      ctx.fillStyle = '#000';\n      var p = new Path2D(path);\n      ctx.stroke(p);\n      ctx.fill(p);\n    }\n\n    return instance;\n  };\n\n  instance.image = function (data, x, y, _ref2) {\n    var width = _ref2.width,\n        height = _ref2.height;\n    var base64Data = btoa(String.fromCharCode.apply(null, data));\n\n    if (images[base64Data]) {\n      ctx.drawImage(images[base64Data], x, y, width, height);\n    } else {\n      var img = document.createElement('img');\n      img.src = 'data:image/png;base64,' + base64Data;\n      images[base64Data] = img;\n\n      img.onload = function () {\n        ctx.drawImage(img, x, y, width, height);\n      };\n    }\n\n    return instance;\n  };\n\n  instance.clear = function () {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  return instance;\n};\n\nvar CanvasViewer = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose(CanvasViewer, _React$Component);\n\n  function CanvasViewer() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;\n    _this.ctx = null;\n    _this.instance = pdf();\n    _this.renderQueue = queue({\n      autostart: true,\n      concurrency: 1\n    });\n    _this.state = {\n      layout: null,\n      error: null\n    };\n\n    _this.onRenderFailed = function (error) {\n      _this.setState({\n        error: error\n      });\n\n      console.error(error);\n    };\n\n    _this.onRenderSuccessful = function (layout) {\n      _this.setState({\n        layout: layout\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = CanvasViewer.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.ctx = canvasInstance(this.canvas);\n    this.queueDocumentRender(this.props.children);\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n    if (prevProps.children !== this.props.children) {\n      this.queueDocumentRender(this.props.children);\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.renderQueue.end();\n  };\n\n  _proto.queueDocumentRender = function queueDocumentRender(doc) {\n    var _this2 = this;\n\n    this.renderQueue.splice(0, this.renderQueue.length, function () {\n      _this2.instance.updateContainer(doc);\n\n      if (_this2.instance.isDirty() && !_this2.state.error) {\n        return _this2.instance.renderWithContext(_this2.ctx);\n      }\n\n      return Promise.resolve();\n    });\n  };\n\n  _proto.render = function render() {\n    var _this3 = this;\n\n    return React.createElement(\"canvas\", {\n      height: 900,\n      id: \"myCanvas\",\n      ref: function ref(_ref3) {\n        return _this3.canvas = _ref3;\n      },\n      style: {\n        border: '1px solid black'\n      },\n      width: 900\n    });\n  };\n\n  return CanvasViewer;\n}(React.Component);\n\nvar queue$1 = require('queue');\n\nvar flatStyles = function flatStyles(stylesArray) {\n  return stylesArray.reduce(function (acc, style) {\n    return _extends({}, acc, style);\n  }, {});\n};\n\nvar Document$1 = function Document$1(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return React.createElement(Document, props, children);\n};\n\nvar InternalBlobProvider = /*#__PURE__*/function (_React$PureComponent) {\n  _inheritsLoose(InternalBlobProvider, _React$PureComponent);\n\n  function InternalBlobProvider() {\n    var _this;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;\n    _this.renderQueue = queue$1({\n      autostart: true,\n      concurrency: 1\n    });\n    _this.state = {\n      blob: null,\n      url: null,\n      loading: true,\n      error: null\n    };\n\n    _this.queueDocumentRender = function () {\n      _this.renderQueue.splice(0, _this.renderQueue.length, function () {\n        return _this.state.error ? Promise.resolve() : _this.instance.toBlob();\n      });\n    };\n\n    _this.onRenderFailed = function (error) {\n      _this.setState({\n        error: error\n      });\n\n      console.error(error);\n    };\n\n    _this.onRenderSuccessful = function (blob) {\n      var oldBlobUrl = _this.state.url;\n\n      _this.setState({\n        blob: blob,\n        url: URL.createObjectURL(blob),\n        loading: false\n      }, function () {\n        return URL.revokeObjectURL(oldBlobUrl);\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = InternalBlobProvider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.instance = pdf({\n      onChange: this.queueDocumentRender\n    });\n    this.instance.updateContainer(this.props.document);\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.instance.updateContainer(this.props.document);\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.renderQueue.end();\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.state);\n  };\n\n  return InternalBlobProvider;\n}(React.PureComponent);\n\nvar BlobProvider = function BlobProvider(_ref2) {\n  var doc = _ref2.document,\n      children = _ref2.children;\n\n  if (!doc) {\n    warning(false, 'You should pass a valid document to BlobProvider');\n    return null;\n  }\n\n  return React.createElement(InternalBlobProvider, {\n    document: doc\n  }, children);\n};\n\nvar PDFViewer = function PDFViewer(_ref3) {\n  var className = _ref3.className,\n      style = _ref3.style,\n      children = _ref3.children,\n      innerRef = _ref3.innerRef,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"className\", \"style\", \"children\", \"innerRef\"]);\n\n  return React.createElement(InternalBlobProvider, {\n    document: children\n  }, function (_ref4) {\n    var url = _ref4.url;\n    return React.createElement(\"iframe\", _extends({\n      className: className,\n      ref: innerRef,\n      src: url,\n      style: Array.isArray(style) ? flatStyles(style) : style\n    }, props));\n  });\n};\n\nvar PDFDownloadLink = function PDFDownloadLink(_ref5) {\n  var doc = _ref5.document,\n      className = _ref5.className,\n      style = _ref5.style,\n      children = _ref5.children,\n      _ref5$fileName = _ref5.fileName,\n      fileName = _ref5$fileName === void 0 ? 'document.pdf' : _ref5$fileName;\n\n  if (!doc) {\n    warning(false, 'You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n\n  var downloadOnIE = function downloadOnIE(blob) {\n    return function () {\n      if (window.navigator.msSaveBlob) {\n        window.navigator.msSaveBlob(blob, fileName);\n      }\n    };\n  };\n\n  return React.createElement(InternalBlobProvider, {\n    document: doc\n  }, function (params) {\n    return React.createElement(\"a\", {\n      className: className,\n      download: fileName,\n      href: params.url,\n      onClick: downloadOnIE(params.blob),\n      style: Array.isArray(style) ? flatStyles(style) : style\n    }, typeof children === 'function' ? children(params) : children);\n  });\n};\n\nvar dom = {\n  pdf: pdf,\n  View: View,\n  Text: Text,\n  Link: Link,\n  Page: Page,\n  Font: Font$1,\n  Note: Note,\n  Image: Image,\n  Canvas: Canvas,\n  Svg: Svg,\n  G: G,\n  Path: Path,\n  Rect: Rect,\n  Line: Line,\n  Circle: Circle,\n  Ellipse: Ellipse,\n  Polygon: Polygon,\n  Polyline: Polyline,\n  Defs: Defs,\n  Tspan: Tspan,\n  ClipPath: ClipPath,\n  Stop: Stop,\n  LinearGradient: LinearGradient,\n  RadialGradient: RadialGradient,\n  version: version,\n  Document: Document$1,\n  PDFViewer: PDFViewer,\n  StyleSheet: StyleSheet,\n  CanvasViewer: CanvasViewer,\n  BlobProvider: BlobProvider,\n  PDFDownloadLink: PDFDownloadLink\n};\nexport default dom;\nexport { Document$1 as Document, BlobProvider, PDFViewer, PDFDownloadLink, pdf, View, Text, Link, Page, Font$1 as Font, Note, Image, Canvas, Svg, G, Path, Rect, Line, Circle, Ellipse, Polygon, Polyline, Defs, Tspan, ClipPath, Stop, LinearGradient, RadialGradient, version, StyleSheet, CanvasViewer };","map":{"version":3,"sources":["../src/constants.js","../src/stylesheet/transformStyles.js","../src/font/font.js","../src/font/emoji.js","../src/font/standard.js","../src/font/hyphenation.js","../src/font/index.js","../src/render/save.js","../src/utils/url.js","../src/render/setLink.js","../src/render/restore.js","../src/node/isSvg.js","../src/node/isText.js","../src/node/isPage.js","../src/node/isLink.js","../src/node/isNote.js","../src/node/isImage.js","../src/node/isCanvas.js","../src/render/clipNode.js","../src/render/renderPath.js","../src/render/renderRect.js","../src/render/renderLine.js","../src/render/renderEllipse.js","../src/render/renderCircle.js","../src/render/renderSvgText.js","../src/svg/parsePoints.js","../src/render/renderPolyline.js","../src/render/renderPolygon.js","../src/utils/warning.js","../src/render/renderSvgImage.js","../src/render/applyTransformations.js","../src/node/isPath.js","../src/node/isRect.js","../src/node/isLine.js","../src/node/isTspan.js","../src/node/isGroup.js","../src/node/isCircle.js","../src/node/isTextInstance.js","../src/render/renderGroup.js","../src/node/isEllipse.js","../src/node/isPolygon.js","../src/node/isPolyline.js","../src/svg/normalizePath.js","../src/svg/getBoundingBox.js","../src/render/renderSvg.js","../src/render/renderText.js","../src/render/renderPage.js","../src/render/renderNote.js","../src/utils/matchPercent.js","../src/image/resolveObjectFit.js","../src/render/renderImage.js","../src/canvas/painter.js","../src/render/renderCanvas.js","../src/node/hasVerticalRuler.js","../src/node/hasHorizontalRuler.js","../src/render/renderRulers.js","../src/render/addMetadata.js","../src/render/renderDebug.js","../src/render/renderBorders.js","../src/render/setDestination.js","../src/render/renderBackground.js","../src/render/index.js","../src/utils/capitalize.js","../src/utils/upperFirst.js","../src/text/transformText.js","../src/text/standardFont.js","../src/text/fontSubstitution.js","../src/svg/layoutText.js","../src/node/isDefs.js","../src/svg/getDefs.js","../src/svg/replaceDefs.js","../src/svg/parseViewbox.js","../src/svg/getContainer.js","../src/svg/inheritProps.js","../src/svg/parseAspectRatio.js","../src/stylesheet/transformColors.js","../src/layout/resolveSvg.js","../src/layout/resolveZIndex.js","../src/layout/resolveRulers.js","../src/utils/png.js","../src/utils/jpeg.js","../src/utils/cache.js","../src/image/resolveImage.js","../src/utils/firstPass.js","../src/image/getSource.js","../src/image/fetchImage.js","../src/text/emoji.js","../src/layout/resolveAssets.js","../src/utils/castArray.js","../src/stylesheet/flatten.js","../src/stylesheet/expandStyles.js","../src/stylesheet/transformUnits.js","../src/stylesheet/resolveMediaQueries.js","../src/layout/resolveStyles.js","../src/node/getOrigin.js","../src/layout/resolveOrigins.js","../src/page/getOrientation.js","../src/page/isLandscape.js","../src/page/getSize.js","../src/utils/assocIfNil.js","../src/layout/resolvePageSizes.js","../src/text/lineIndexAtHeight.js","../src/text/heightAtLineIndex.js","../src/text/splitText.js","../src/node/splitNode.js","../src/node/createInstance.js","../src/node/getNodesHeight.js","../src/node/shouldBreak.js","../src/node/getPadding.js","../src/page/getContentArea.js","../src/text/ignorableChars.js","../src/text/getAttributedString.js","../src/text/layoutText.js","../src/layout/resolveTextLayout.js","../src/layout/resolveInheritance.js","../src/node/getMargin.js","../src/node/getPosition.js","../src/node/getDimension.js","../src/node/getBorderWidth.js","../src/node/setDisplay.js","../src/node/setOverflow.js","../src/node/setFlexWrap.js","../src/node/setYogaValue.js","../src/node/setFlexGrow.js","../src/node/setFlexBasis.js","../src/node/setAlign.js","../src/node/setAlignSelf.js","../src/node/setAlignItems.js","../src/node/setFlexShrink.js","../src/node/setAspectRatio.js","../src/node/setAlignContent.js","../src/node/setPositionType.js","../src/node/setFlexDirection.js","../src/node/setJustifyContent.js","../src/node/setMargin.js","../src/node/setPadding.js","../src/node/setBorderWidth.js","../src/node/setPosition.js","../src/node/setDimension.js","../src/svg/measureSvg.js","../src/text/linesWidth.js","../src/text/linesHeight.js","../src/text/measureText.js","../src/image/getRatio.js","../src/page/isHeightAuto.js","../src/image/measureImage.js","../src/canvas/measureCanvas.js","../src/layout/resolveDimensions.js","../src/layout/resolvePagination.js","../src/node/removeMargins.js","../src/layout/resolvePageMargins.js","../src/layout/resolveNoteChildren.js","../src/layout/resolvePagePaddings.js","../src/layout/resolvePercentRadius.js","../src/layout/resolvePercentHeight.js","../src/layout/resolveLinkSubstitution.js","../src/utils/asyncCompose.js","../src/layout/index.js","../src/utils/propsEqual.js","../src/renderer.js","../src/stylesheet/index.js","../src/index.js","../src/canvas.js","../src/dom.js"],"names":["VIEW","TEXT","LINK","PAGE","NOTE","IMAGE","DOCUMENT","CANVAS","TEXT_INSTANCE","SVG","GROUP","PATH","RECT","LINE","CIRCLE","ELLIPSE","POLYGON","POLYLINE","DEFS","TSPAN","CLIP_PATH","STOP","LINEAR_GRADIENT","RADIAL_GRADIENT","DPI","FONT_WEIGHTS","thin","hairline","ultralight","extralight","light","normal","medium","semibold","demibold","bold","ultrabold","extrabold","heavy","black","PAGE_SIZES","A0","A1","A2","A3","A4","A5","A6","A7","A8","A9","A10","B0","B1","B2","B3","B4","B5","B6","B7","B8","B9","B10","C0","C1","C2","C3","C4","C5","C6","C7","C8","C9","C10","RA0","RA1","RA2","RA3","RA4","SRA0","SRA1","SRA2","SRA3","SRA4","EXECUTIVE","FOLIO","LEGAL","LETTER","TABLOID","PORTRAIT","LANDSCAPE","INHERITED_PROPERTIES","SVG_INHERITED_PROPS","RULER_WIDTH","RULER_COLOR","RULER_FONT_SIZE","DEFAULT_RULER_STEPS","LINE_WIDTH","LINE_COLOR","GRID_COLOR","BOX_MODEL_REGEX","OBJECT_POSITION_REGEX","BORDER_SHORTHAND_REGEX","TRANSFORM_ORIGIN_REGEX","matchBoxModel","R","matchObjectPosition","matchBorderShorthand","matchTransformOrigin","isNumber","isFontWeightStyle","key","isBorderStyle","isBoxModelStyle","isObjectPositionStyle","isTransformOriginStyle","isFlexGrow","isFlexShrink","isFlexBasis","processBorders","match","processBoxModel","processFontWeight","value","processObjectPosition","transformOffsetKeywords","processTransformOrigin","result","processFlexGrow","matches","processFlexShrink","processFlexBasis","keepSame","matchNumber","castFloat","parseFloat","transformStyle","transformStyles","fetchFont","response","fetch","buffer","Buffer","FontSource","fontStyle","load","headers","body","method","data","fontkit","err","reject","resolve","Font","create","register","src","fontWeight","options","descriptor","styleSources","s","exactFit","leftOffset","rightOffset","fit","res","lt","gt","registerEmojiSource","url","format","emojiSource","getEmojiSource","registerHyphenationCallback","hyphenationCallback","getHyphenationCallback","fonts","family","font","i","getRegisteredFonts","getRegisteredFontFamilies","Object","getFont","fontFamily","isStandard","standardFonts","reset","clear","save","ctx","PROTOCOL_REGEXP","DEST_REGEXP","getURL","isSrcId","getSource","setLink","top","left","width","height","node","instanceMethod","restore","isSvg","isText","isPage","hasSource","isLink","isNote","isImage","isCanvas","KAPPA","Math","clipNode","borderTopLeftRadius","borderTopRightRadius","borderBottomRightRadius","borderBottomLeftRadius","rtr","ctr","rbr","cbr","rbl","cbl","rtl","ctl","renderPath","d","getProp","renderRect","x","y","rx","ry","krx","kry","renderLine","x1","y1","x2","y2","drawEllipse","cx","cy","ox","oy","xe","ye","xm","ym","renderEllipse","renderCircle","r","renderRun","runAdvanceWidth","runWidth","fontSize","color","opacity","run","position","glyph","console","renderSpan","lineWidth","line","renderSvgText","span","isOdd","lengthIsOdd","parsePoints","drawPolyline","points","p","renderPolyline","closePath","renderPolygon","args","argIndex","message","__DEV__","process","warning","printWarning","drawImage","paddingTop","paddingLeft","renderImage","getRotation","getTranslateX","matchX","matchGeneric","getTranslateY","matchY","getScaleX","getScaleY","getMatrix","applySingleTransformation","origin","applyTransformations","re","transform","isPath","isRect","isLine","isTspan","isGroup","isCircle","isTextInstance","renderGroup","isEllipse","isPolygon","isPolyline","normalizePath","bezierX","bezierY","startX","startY","quadX","quadY","len","path","seg","command","curves","arcToCurve","px","py","xAxisRotation","largeArcFlag","sweepFlag","j","c","prev","quadratic","getPathBoundingBox","bounds","l","getCircleBoundingBox","getEllipseBoundingBox","getLineBoundingBox","getRectBoundingBox","max","min","getPolylineBoundingBox","xValues","yValues","getBoundingBox","warnUnsupportedNode","setStrokeWidth","setStrokeColor","strokeColor","setOpacity","setFillOpacity","fillOpacity","setStrokeOpacity","strokeOpacity","setLineJoin","lineJoin","setLineCap","lineCap","setLineDash","dashArray","space","hasLinearGradientFill","hasRadialGradientFill","setLinearGradientFill","bbox","gradient","m0","m3","m4","m5","gx1","gy1","gx2","gy2","grad","stop","setRadialGradientFill","fx","fy","gr","gcx","gcy","gfx","gfy","setFillColor","fillColor","setFill","draw","props","renderNode","renderSvgImage","drawNode","clipPath","drawChildren","defaultsZero","preserveAspectRatio","viewBox","meetOrSlice","align","logicalWidth","logicalHeight","logicalRatio","physicalRatio","scaleX","scaleY","moveToOrigin","renderSvg","renderText","initialY","PDFRenderer","renderPage","size","margin","renderNote","isPercent","matchPercent","percent","absValue","absPercent","isNumeric","isNaN","isFinite","applyContainObjectFit","cr","cw","ir","iw","pxp","pyp","pxv","pyv","yOffset","xOffset","ch","applyNoneObjectFit","applyCoverObjectFit","applyScaleDownObjectFit","containDimension","noneDimension","applyFillObjectFit","resolveObjectFit","type","objectPositionX","objectPositionY","paddingRight","paddingBottom","availableMethods","painter","renderCanvas","availableWidth","availableHeight","hasVerticalRuler","hasHorizontalRuler","range","length","matchPercentage","getVerticalSteps","page","percentage","getHorizontalSteps","renderVerticalRuler","offset","hRange","step","renderHorizontalRuler","renderRulers","getDocumentProp","setPDFMetadata","target","addMetadata","setProp","title","author","subject","keywords","creator","producer","CONTENT_COLOR","PADDING_COLOR","MARGIN_COLOR","shouldDebug","debugContent","borderLeftWidth","borderTopWidth","borderRightWidth","borderBottomWidth","debugPadding","debugMargin","marginLeft","marginTop","marginRight","marginBottom","debugText","roundedWidth","roundedHeight","debugOrigin","renderDebug","clipBorderTop","layout","style","c0","topRightYCoord","innerTopRightRadiusX","innerTopRightRadiusY","c1","c2","innerTopLeftRadiusX","innerTopLeftRadiusY","c3","c4","topLeftYCoord","c5","trSlope","fillBorderTop","borderTopColor","borderTopStyle","clipBorderRight","topBottomXCoord","innerBottomRightRadiusX","innerBottomRightRadiusY","topRightXCoord","brSlope","fillBorderRight","borderRightColor","borderRightStyle","clipBorderBottom","bottomLeftYCoord","innerBottomLeftRadiusX","innerBottomLeftRadiusY","bottomRightYCoord","fillBorderBottom","borderBottomColor","borderBottomStyle","clipBorderLeft","topLeftCoordX","bottomLeftXCoord","fillBorderLeft","borderLeftColor","borderLeftStyle","shouldRenderBorders","renderBorders","setDestination","drawBackground","shouldRenderBackground","renderBackground","shouldRenderChildren","renderChildren","renderDocument","render","capitalize","upperFirst","transformText","text","StandardFont","PDFFont","encoded","positions","stringIndices","glyphs","parseInt","glyphForCodePoint","getGlyph","id","_font","codePoints","isLigature","name","hasGlyphForCodePoint","fontCache","IGNORED_CODE_POINTS","getFontSize","getOrCreateFont","getFallbackFont","shouldFallbackToFont","fontSubstitution","string","runs","lastFont","lastIndex","index","defaultFont","start","end","attributes","char","codePoint","shouldFallback","scale","engines","linebreaker","justification","textDecoration","scriptItemizer","wordHyphenation","engine","layoutEngine","layoutOptions","shrinkWhitespaceFactor","before","after","getFragments","fragments","fill","textDecorationColor","textDecorationStyle","textTransform","instance","obj","underlineStyle","underline","underlineColor","strike","strikeStyle","strikeColor","child","getAttributedString","AttributedString","AlmostInfinity","layoutTspan","attributedString","container","lines","layoutText","children","isDefs","getChildren","getId","getDefs","isNotDefs","detachDefs","URL_REGEX","replaceDef","parseNodeDefs","parseDefs","defs","replaceDefs","parseViewbox","values","minX","minY","maxX","maxY","getContainer","viewbox","parseViewBox","getInheritProps","inheritProps","parseAspectRatio","isRgb","isRgba","isHsl","isHsla","parseRgb","colorString","parseHsl","transformColor","transformColors","STYLE_PROPS","VERTICAL_PROPS","HORIZONTAL_PROPS","transformPercent","parsePercent","parseProps","stroke","stopOpacity","stopColor","mergeStyles","removeNoneValues","pickStyleProps","styleProps","parseSvgProps","wrapBetweenTspan","addMissingTspan","resolveSvgNode","resolveChildren","parseText","resolveSvgRoot","resolveSvg","getZIndex","isType","shouldNotSort","sortZIndex","za","zb","resolveZIndex","adjustPageSize","box","resolveRulers","PNG","MARKERS","JPEG","pos","marker","createCache","limit","cache","keys","get","set","IMAGE_CACHE","getAbsoluteLocalPath","protocol","auth","host","port","hostname","pathname","absolutePath","fetchLocalFile","fs","fetchRemoteFile","isValidFormat","lower","guessFormat","isCompatibleBase64","uri","extension","resolveBase64Image","getImage","resolveImageFromData","JSON","resolveBufferImage","getImageFormat","isPng","isJpg","resolveImageFromUrl","resolveImage","cacheKey","image","isNotNil","firstPass","fns","fn","resolveSrc","fetchImage","source","emojis","regex","emojiRegex","reflect","makeFetchEmojiImage","_removeNoColor","getCodePoints","buildEmojiUrl","fetchEmojis","promises","emoji","emojiUrl","loading","fetchEmojiImage","embedEmojis","fragment","emojiSize","chunk","String","attachment","fetchAssets","listToExplore","resolveAssets","Promise","isNotArray","castArray","compact","isArray","flatten","acc","hasOwnProperty","styleShorthands","marginHorizontal","marginVertical","padding","paddingHorizontal","paddingVertical","border","borderTop","borderRight","borderBottom","borderLeft","borderColor","borderRadius","borderStyle","borderWidth","objectPosition","transformOrigin","transformOriginX","transformOriginY","flex","flexGrow","flexShrink","flexBasis","expandStyles","propsArray","resolvedStyle","expandedProps","MM_FACTOR","CM_FACTOR","parseValue","unit","undefined","transformUnit","scalar","transformUnits","resolveMediaQueries","matchMedia","styles","LINK_STYLES","filterNoneValues","resolveStyles","resolveNodeStyles","resolvePageStyles","getTransformStyle","getOrigin","percentX","percentY","offsetX","offsetY","resolveNodeOrigin","resolveOrigin","VALID_ORIENTATIONS","getOrientation","isLandscape","toSizeObject","flipSizeObject","getStringSize","getNumberSize","throwInvalidError","getSize","assocIfNil","resolvePageSize","getPageSize","resolvePageSizes","lineIndexAtHeight","heightAtLineIndex","counter","zero","getTop","getWidows","getOrphans","getLineBreak","widows","orphans","linesQuantity","slicedLine","splitText","slicedLineIndex","currentHeight","nextHeight","current","next","hasFixedHeight","subtractHeight","splitNode","nodeTop","isString","isNotString","createInstance","element","nextChildren","getNodesHeight","nodes","getWrap","getBreak","getMinPresenceAhead","defaultPresenceAhead","getPresenceAhead","elements","isElementInside","presenceAhead","shouldBreak","minPresenceAhead","futureHeight","shouldSplit","shouldWrap","getComputedPadding","yogaNode","getPadding","Yoga","getContentArea","IGNORABLE_CODEPOINTS","buildSubsetForFont","ignoreChars","charSubset","subsetRegex","PREPROCESSORS","backgroundColor","textAlign","lineHeight","letterSpacing","textIndent","indent","link","characterSpacing","preprocessor","maxLines","textOverflow","truncateMode","getLayoutOptions","hyphenationPenalty","isNotSvg","hasLines","shouldLayoutText","resolveTextLayout","getInheritStyles","resolveInheritance","inheritStyles","getComputedMargin","getMargin","getRight","getBottom","getLeft","getPosition","right","bottom","DEFAULT_DIMENSION","getDimension","getComputedBorder","getBorderWidth","setDisplay","setOverflow","yogaValue","setFlexWrap","setYogaValue","hasEdge","fixedMethod","autoMethod","percentMethod","setFlexGrow","setFlexBasis","setAlign","attr","setAlignSelf","setAlignItems","setFlexShrink","setAspectRatio","setAlignContent","setPositionType","isRow","isRowReverse","isColumnReverse","setFlexDirection","setJustifyContent","setMarginTop","setMarginRight","setMarginBottom","setMarginLeft","setPaddingTop","setPaddingRight","setPaddingBottom","setPaddingLeft","setBorderTop","setBorderRight","setBorderBottom","setBorderLeft","setPositionTop","setPositionRight","setPositionBottom","setPositionLeft","setWidth","setMinWidth","setMaxWidth","setHeight","setMinHeight","setMaxHeight","getAspectRatio","measureCanvas","aspectRatio","widthMode","heightMode","linesWidth","linesHeight","measureText","getRatio","isHeightAuto","SAFETY_HEIGHT","measureImage","imageRatio","imageMargin","pagePadding","pageArea","scaledHeight","getMax","measureCtx","nil","addPoint","moveTo","rect","ellipse","polygon","YOGA_NODE","YOGA_CONFIG","setNodeHeight","setYogaValues","insertYogaNodes","parent","setMeasureFunc","measureSvg","isNotText","isNotNote","isNotTextInstance","isLayoutElement","createYogaNodes","calculateLayout","persistDimensions","destroyYogaNodes","n","resolvePageDimensions","resolveDimensions","SAFTY_THRESHOLD","assingChildren","getHeight","isElementOutside","isFixed","allFixed","isDynamic","relayoutPage","splitView","currentNode","nextNode","currentChilds","splitChildren","split","splitNodes","currentChildren","futureNodes","futureFixedNodes","nodeHeight","isOutside","shouldNodeBreak","break","currentChild","nextChild","splitPage","contentArea","dynamicPage","resolveDynamicPage","pageNumber","nextChilds","currentPage","nextPage","shouldResolveDynamicNodes","resolveDynamicNodes","isNodeDynamic","resolveRender","paginate","splittedPage","pages","resolvePageIndices","totalPages","resolvePagination","doc","subpages","removeMargins","resolvePageMargins","getNodeText","getNodesText","wrapTextInstance","resolveNoteChildren","resolvePageHorizontalPadding","resolvePageVerticalPadding","resolvePagePaddings","resolveRadius","resolvePercentRadius","transformHeight","getPageArea","pageHeight","pagePaddingTop","pagePaddingBottom","hasHeight","resolveNodePercentHeight","resolvePagePercentHeight","resolvePercentHeight","hasRenderProp","hasTextInstanceChilds","resolveLinkSubstitution","asyncCompose","propsEqual","oldPropsKeys","newPropsKeys","propName","a","b","emptyObject","createRenderer","onChange","ReactFiberReconciler","schedulePassiveEffects","cancelPassiveEffects","supportsMutation","isPrimaryRenderer","warnsIfNotActing","appendInitialChild","parentInstance","createTextInstance","finalizeInitialChildren","getPublicInstance","prepareForCommit","prepareUpdate","resetAfterCommit","resetTextContent","getRootHostContext","getChildHostContext","shouldSetTextContent","now","Date","useSyncScheduling","appendChild","appendChildToContainer","insertBefore","removeChild","removeChildFromContainer","commitTextUpdate","textInstance","commitUpdate","newProps","absoluteFillObject","hairlineWidth","View","Text","Link","Page","Note","Image","Document","Canvas","Svg","G","Path","Rect","Line","Circle","Ellipse","Polygon","Polyline","Defs","Tspan","ClipPath","Stop","LinearGradient","RadialGradient","pdf","initialValue","document","mountNode","updateContainer","autoFirstPage","layoutDocument","renderPDF","params","stream","BlobStream","blob","callOnRender","toBuffer","toBlob","toString","svgpath","require","queue","canvasInstance","images","canvas","xAdvance","unitsPerEm","base64Data","btoa","img","CanvasViewer","React","autostart","concurrency","error","componentDidMount","componentDidUpdate","prevProps","componentWillUnmount","queueDocumentRender","flatStyles","InternalBlobProvider","PureComponent","renderQueue","state","onRenderFailed","onRenderSuccessful","oldBlobUrl","URL","BlobProvider","PDFViewer","className","innerRef","Array","PDFDownloadLink","fileName","downloadOnIE","window","version","StyleSheet"],"mappings":"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","sourcesContent":["export const VIEW = 'VIEW';\nexport const TEXT = 'TEXT';\nexport const LINK = 'LINK';\nexport const PAGE = 'PAGE';\nexport const NOTE = 'NOTE';\nexport const IMAGE = 'IMAGE';\nexport const DOCUMENT = 'DOCUMENT';\nexport const CANVAS = 'CANVAS';\nexport const TEXT_INSTANCE = 'TEXT_INSTANCE';\nexport const SVG = 'SVG';\nexport const GROUP = 'G';\nexport const PATH = 'PATH';\nexport const RECT = 'RECT';\nexport const LINE = 'LINE';\nexport const CIRCLE = 'CIRCLE';\nexport const ELLIPSE = 'ELLIPSE';\nexport const POLYGON = 'POLYGON';\nexport const POLYLINE = 'POLYLINE';\nexport const DEFS = 'DEFS';\nexport const TSPAN = 'TSPAN';\nexport const CLIP_PATH = 'CLIP_PATH';\nexport const STOP = 'STOP';\nexport const LINEAR_GRADIENT = 'LINEAR_GRADIENT';\nexport const RADIAL_GRADIENT = 'RADIAL_GRADIENT';\n\nexport const DPI = 72; // 72pt per inch.\n\n// https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping\nexport const FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900,\n};\n\nexport const PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0],\n};\n\nexport const PORTRAIT = 'portrait';\nexport const LANDSCAPE = 'landscape';\n\nexport const INHERITED_PROPERTIES = [\n  'color',\n  'fontFamily',\n  'fontSize',\n  'fontStyle',\n  'fontWeight',\n  'letterSpacing',\n  'opacity',\n  'textDecoration',\n  'lineHeight',\n  'textAlign',\n  'visibility',\n  'wordSpacing',\n];\n\nexport const SVG_INHERITED_PROPS = [\n  'x',\n  'y',\n  'clipPath',\n  'clipRule',\n  'opacity',\n  'fill',\n  'fillOpacity',\n  'fillRule',\n  'stroke',\n  'strokeLinecap',\n  'strokeLinejoin',\n  'strokeOpacity',\n  'strokeWidth',\n  'textAnchor',\n  ...INHERITED_PROPERTIES,\n];\n\nexport const RULER_WIDTH = 13;\nexport const RULER_COLOR = 'white';\nexport const RULER_FONT_SIZE = 6;\nexport const DEFAULT_RULER_STEPS = 50;\nexport const LINE_WIDTH = 0.5;\nexport const LINE_COLOR = 'gray';\nexport const GRID_COLOR = '#ababab';\n","import * as R from 'ramda';\n\nimport { FONT_WEIGHTS } from '../constants';\n\nconst BOX_MODEL_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nconst OBJECT_POSITION_REGEX = /\\d+(px|in|mm|cm|pt|%|vw|vh|px)?/g;\nconst BORDER_SHORTHAND_REGEX = /(\\d+(px|in|mm|cm|pt|vw|vh|px)?)\\s(\\S+)\\s(\\S+)/;\nconst TRANSFORM_ORIGIN_REGEX = /(-?\\d+(px|in|mm|cm|pt|%|vw|vh|px)?)|top|right|bottom|left|center/g;\n\nconst matchBoxModel = R.match(BOX_MODEL_REGEX);\nconst matchObjectPosition = R.match(OBJECT_POSITION_REGEX);\nconst matchBorderShorthand = R.match(BORDER_SHORTHAND_REGEX);\nconst matchTransformOrigin = R.match(TRANSFORM_ORIGIN_REGEX);\n\nconst isNumber = R.is(Number);\n\nconst isFontWeightStyle = key => key.match(/^fontWeight/);\n\nconst isBorderStyle = (key, value) =>\n  key.match(/^border(Top|Right|Bottom|Left)(Color|Width|Style)/) &&\n  typeof value === 'string';\n\nconst isBoxModelStyle = (key, value) =>\n  key.match(/^(margin)|(padding)/) && typeof value === 'string';\n\nconst isObjectPositionStyle = (key, value) =>\n  key.match(/^objectPosition/) && typeof value === 'string';\n\nconst isTransformOriginStyle = (key, value) =>\n  key.match(/^transformOrigin/) && typeof value === 'string';\n\nconst isFlexGrow = key => key === 'flexGrow';\n\nconst isFlexShrink = key => key === 'flexShrink';\n\nconst isFlexBasis = key => key === 'flexBasis';\n\nconst processBorders = (key, value) => {\n  const match = matchBorderShorthand(value);\n\n  if (match) {\n    if (key.match(/Color$/)) {\n      return match[4] || value;\n    } else if (key.match(/Style$/)) {\n      return match[3] || value;\n    } else if (key.match(/Width$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nconst processBoxModel = (key, value) => {\n  const match = matchBoxModel(value);\n\n  if (match) {\n    if (key.match(/Top$/)) {\n      return match[0];\n    } else if (key.match(/Right$/)) {\n      return match[1] || match[0];\n    } else if (key.match(/Bottom$/)) {\n      return match[2] || match[0];\n    } else if (key.match(/Left$/)) {\n      return match[3] || match[1] || match[0];\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nexport const processFontWeight = (key, value) => {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  return FONT_WEIGHTS[value.toLowerCase()];\n};\n\nexport const processObjectPosition = (key, value) => {\n  const match = matchObjectPosition(value);\n\n  if (match) {\n    if (key.match(/X$/)) {\n      return match[0] || value;\n    } else if (key.match(/Y$/)) {\n      return match[1] || value;\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n  }\n\n  return value;\n};\n\nconst transformOffsetKeywords = value => {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n    case 'right':\n    case 'bottom':\n      return '100%';\n    case 'center':\n      return '50%';\n    default:\n      return value;\n  }\n};\n\n// Transforms shorthand transformOrigin values\nconst processTransformOrigin = (key, value) => {\n  const match = matchTransformOrigin(value);\n\n  if (match) {\n    let result;\n\n    if (key.match(/X$/)) {\n      result = match[0] || value;\n    } else if (key.match(/Y$/)) {\n      result = match[1] || match[0] || value;\n    } else {\n      throw new Error(`StyleSheet: Invalid '${value}' for '${key}'`);\n    }\n\n    return transformOffsetKeywords(result);\n  }\n\n  return value;\n};\n\nconst processFlexGrow = (key, value) => {\n  if (isNumber(value)) return value;\n  const matches = value.split(' ');\n  return matches[0];\n};\n\nconst processFlexShrink = (key, value) => {\n  if (isNumber(value)) return value;\n  const matches = value.split(' ');\n  return matches[1];\n};\n\nconst processFlexBasis = (key, value) => {\n  if (isNumber(value)) return value;\n  const matches = value.split(' ');\n  return matches[2];\n};\n\nconst keepSame = (key, value) => value;\n\nconst matchNumber = R.when(R.is(String), R.test(/^-?\\d*\\.?\\d*$/));\n\nconst castFloat = R.when(matchNumber, v => parseFloat(v, 10));\n\n/**\n * Transforms style key-value\n *\n * @param {String} key style key\n * @param {String} value style value\n * @returns {String | Number} transformed style values\n */\nconst transformStyle = R.compose(\n  castFloat,\n  R.cond([\n    [isBorderStyle, processBorders],\n    [isBoxModelStyle, processBoxModel],\n    [isObjectPositionStyle, processObjectPosition],\n    [isTransformOriginStyle, processTransformOrigin],\n    [isFontWeightStyle, processFontWeight],\n    [isFlexGrow, processFlexGrow],\n    [isFlexShrink, processFlexShrink],\n    [isFlexBasis, processFlexBasis],\n    [R.T, keepSame],\n  ]),\n);\n\n/**\n * Transforms already expanded styles shortcuts into appropiate values\n * Ex. marginTopWidth: '2 solid red' -> marginTopWidth: 2\n *\n * @param {Object} styles expanded object\n * @returns {Object} transformed styles\n */\nconst transformStyles = R.mapObjIndexed(R.flip(transformStyle));\n\nexport default transformStyles;\n","import isUrl from 'is-url';\nimport fontkit from '@react-pdf/fontkit';\nimport fetch from 'cross-fetch';\n\nimport { processFontWeight } from '../stylesheet/transformStyles';\n\nconst fetchFont = async (src, options) => {\n  const response = await fetch(src, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nclass FontSource {\n  constructor(src, fontFamily, fontStyle, fontWeight, options) {\n    this.src = src;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = processFontWeight(fontWeight) || 400;\n\n    this.data = null;\n    this.loading = false;\n    this.options = options;\n  }\n\n  async load() {\n    this.loading = true;\n\n    if (BROWSER || isUrl(this.src)) {\n      const { headers, body, method = 'GET' } = this.options;\n      const data = await fetchFont(this.src, { method, body, headers });\n      this.data = fontkit.create(data);\n    } else {\n      this.data = await new Promise((resolve, reject) =>\n        fontkit.open(this.src, (err, data) =>\n          err ? reject(err) : resolve(data),\n        ),\n      );\n    }\n\n    this.loading = false;\n  }\n}\n\nclass Font {\n  static create(family) {\n    return new Font(family);\n  }\n\n  constructor(family) {\n    this.family = family;\n    this.sources = [];\n  }\n\n  register({ src, fontWeight, fontStyle, ...options }) {\n    this.sources.push(\n      new FontSource(src, this.fontFamily, fontStyle, fontWeight, options),\n    );\n  }\n\n  resolve(descriptor) {\n    const { fontWeight = 400, fontStyle = 'normal' } = descriptor;\n    const styleSources = this.sources.filter(s => s.fontStyle === fontStyle);\n\n    // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n    const exactFit = styleSources.find(s => s.fontWeight === fontWeight);\n\n    if (exactFit) return exactFit;\n\n    let res;\n\n    if (fontWeight >= 400 && fontWeight <= 500) {\n      const leftOffset = styleSources.filter(s => s.fontWeight <= fontWeight);\n      const rightOffset = styleSources.filter(s => s.fontWeight > 500);\n      const fit = styleSources.filter(\n        s => s.fontWeight >= fontWeight && s.fontWeight < 500,\n      );\n\n      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];\n    }\n\n    const lt = styleSources.filter(s => s.fontWeight < fontWeight);\n    const gt = styleSources.filter(s => s.fontWeight > fontWeight);\n\n    if (fontWeight < 400) {\n      res = lt[lt.length - 1] || gt[0];\n    }\n\n    if (fontWeight > 500) {\n      res = gt[0] || lt[lt.length - 1];\n    }\n\n    if (!res) {\n      throw new Error(\n        `Could not resolve font for ${\n          this.fontFamily\n        }, fontWeight ${fontWeight}`,\n      );\n    }\n\n    return res;\n  }\n}\n\nexport default Font;\n","let emojiSource;\n\nexport const registerEmojiSource = ({ url, format = 'png' }) => {\n  emojiSource = { url, format };\n};\n\nexport const getEmojiSource = () => emojiSource;\n\nexport default {\n  registerEmojiSource,\n  getEmojiSource,\n};\n","export default [\n  'Courier',\n  'Courier-Bold',\n  'Courier-Oblique',\n  'Helvetica',\n  'Helvetica-Bold',\n  'Helvetica-Oblique',\n  'Times-Roman',\n  'Times-Bold',\n  'Times-Italic',\n];\n","let hyphenationCallback;\n\nexport const registerHyphenationCallback = callback => {\n  hyphenationCallback = callback;\n};\n\nexport const getHyphenationCallback = () => hyphenationCallback;\n\nexport default {\n  registerHyphenationCallback,\n  getHyphenationCallback,\n};\n","import font from './font';\nimport emoji from './emoji';\nimport standardFonts from './standard';\nimport hyphenation from './hyphenation';\n\nlet fonts = {};\n\nconst register = data => {\n  const { family } = data;\n\n  if (!fonts[family]) {\n    fonts[family] = font.create(family);\n  }\n\n  // Bulk loading\n  if (data.fonts) {\n    for (let i = 0; i < data.fonts.length; i++) {\n      fonts[family].register({ family, ...data.fonts[i] });\n    }\n  } else {\n    fonts[family].register(data);\n  }\n};\n\nconst getRegisteredFonts = () => fonts;\n\nconst getRegisteredFontFamilies = () => Object.keys(fonts);\n\nconst getFont = descriptor => {\n  const { fontFamily } = descriptor;\n  const isStandard = standardFonts.includes(fontFamily);\n\n  if (isStandard) return null;\n\n  if (!fonts[fontFamily]) {\n    throw new Error(\n      `Font family not registered: ${fontFamily}. Please register it calling Font.register() method.`,\n    );\n  }\n\n  return fonts[fontFamily].resolve(descriptor);\n};\n\nconst load = async function(descriptor) {\n  const { fontFamily } = descriptor;\n  const isStandard = standardFonts.includes(fontFamily);\n\n  if (isStandard) return;\n\n  const font = getFont(descriptor);\n\n  // We cache the font to avoid fetching it many times\n  if (!font.data && !font.loading) {\n    await font.load();\n  }\n};\n\nconst reset = function() {\n  for (const font in fonts) {\n    if (fonts.hasOwnProperty(font)) {\n      fonts[font].data = null;\n    }\n  }\n};\n\nconst clear = function() {\n  fonts = {};\n};\n\nexport default {\n  register,\n  getRegisteredFonts,\n  getRegisteredFontFamilies,\n  getFont,\n  load,\n  clear,\n  reset,\n  ...emoji,\n  ...hyphenation,\n};\n","import * as R from 'ramda';\n\nconst save = (ctx, node) => {\n  ctx.save();\n  return node;\n};\n\nexport default R.curryN(2, save);\n","const PROTOCOL_REGEXP = /^([a-z]+\\:(\\/\\/)?)/i;\nconst DEST_REGEXP = /^#.+/;\n\n/**\n * Add protocol th URL if valid\n *\n * @param {String} value url\n * @returns {String} corrected url\n */\nexport const getURL = value => {\n  if (!value) return '';\n\n  if (isSrcId(value)) return value; // don't modify it if it is an id\n\n  if (typeof value === 'string' && !value.match(PROTOCOL_REGEXP)) {\n    return `http://${value}`;\n  }\n\n  return value;\n};\n\nexport const isSrcId = src => src.match(DEST_REGEXP);\n\nexport const setLink = node => {\n  if (!node.src) {\n    return;\n  }\n\n  const { top, left, width, height } = node.getAbsoluteLayout();\n  const instanceMethod = isSrcId(node.src) ? 'goTo' : 'link';\n  const nodeSrc = isSrcId(node.src) ? node.src.slice(1) : node.src;\n\n  node.root.instance[instanceMethod](left, top, width, height, nodeSrc);\n};\n\nexport const setDestination = node => {\n  if (!node.props.id) {\n    return;\n  }\n\n  const { top } = node.getAbsoluteLayout();\n  node.root.instance.addNamedDestination(node.props.id, 'XYZ', null, top, null);\n};\n","import * as R from 'ramda';\n\nimport { getURL } from '../utils/url';\n\nconst DEST_REGEXP = /^#.+/;\n\nconst isSrcId = R.test(DEST_REGEXP);\n\nconst getSource = R.compose(\n  R.either(R.path(['props', 'src']), R.path(['props', 'href'])),\n);\n\nconst setLink = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n  const src = getSource(node);\n  const instanceMethod = isSrcId(src) ? 'goTo' : 'link';\n  const value = isSrcId(src) ? src.slice(1) : getURL(src);\n\n  if (value) {\n    ctx[instanceMethod](left, top, width, height, value);\n  }\n\n  return node;\n};\n\nexport default R.curryN(2, setLink);\n","import * as R from 'ramda';\n\nconst restore = (ctx, node) => {\n  ctx.restore();\n  return node;\n};\n\nexport default R.curryN(2, restore);\n","import * as R from 'ramda';\n\nimport { SVG } from '../constants';\n\n/**\n * Checks if node is svg\n *\n * @param {Object} node\n * @returns {Boolean} is node svg?\n */\nconst isSvg = R.propEq('type', SVG);\n\nexport default isSvg;\n","import * as R from 'ramda';\n\nimport { TEXT } from '../constants';\n\n/**\n * Checks if node is text\n *\n * @param {Object} node\n * @returns {Boolean} is node text?\n */\nconst isText = R.propEq('type', TEXT);\n\nexport default isText;\n","import * as R from 'ramda';\n\nimport { PAGE } from '../constants';\n\n/**\n * Checks if node is page\n *\n * @param {Object} node\n * @returns {Boolean} is node page?\n */\nconst isPage = R.propEq('type', PAGE);\n\nexport default isPage;\n","import * as R from 'ramda';\n\nimport { LINK, TEXT } from '../constants';\n\n/**\n * Checks if node has valid source prop\n *\n * @param {Object} node\n * @returns {Boolean} does node have source prop?\n */\nconst hasSource = R.either(\n  R.hasPath(['props', 'src']),\n  R.hasPath(['props', 'href']),\n);\n\n/**\n * Checks if node is link\n *\n * @param {Object} node\n * @returns {Boolean} is node link?\n */\nconst isLink = R.either(\n  R.propEq('type', LINK),\n  R.both(R.propEq('type', TEXT), hasSource),\n);\n\nexport default isLink;\n","import * as R from 'ramda';\n\nimport { NOTE } from '../constants';\n\n/**\n * Checks if node is note\n *\n * @param {Object} node\n * @returns {Boolean} is node note?\n */\nconst isNote = R.propEq('type', NOTE);\n\nexport default isNote;\n","import * as R from 'ramda';\n\nimport { IMAGE } from '../constants';\n\n/**\n * Checks if node is image\n *\n * @param {Object} node\n * @returns {Boolean} is node image?\n */\nconst isImage = R.propEq('type', IMAGE);\n\nexport default isImage;\n","import * as R from 'ramda';\n\nimport { CANVAS } from '../constants';\n\n/**\n * Checks if node is canvas\n *\n * @param {Object} node\n * @returns {Boolean} is node canvas?\n */\nconst isCanvas = R.propEq('type', CANVAS);\n\nexport default isCanvas;\n","import * as R from 'ramda';\n\n// This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipNode = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n\n  const {\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomRightRadius = 0,\n    borderBottomLeftRadius = 0,\n  } = node.style;\n\n  // Border top\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const ctr = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + rtr, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - ctr,\n    top,\n    left + width,\n    top + ctr,\n    left + width,\n    top + rtr,\n  );\n\n  // Border right\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const cbr = rbr * (1.0 - KAPPA);\n\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - cbr,\n    left + width - cbr,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  // Border bottom\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  const cbl = rbl * (1.0 - KAPPA);\n\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + cbl,\n    top + height,\n    left,\n    top + height - cbl,\n    left,\n    top + height - rbl,\n  );\n\n  // Border left\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const ctl = rtl * (1.0 - KAPPA);\n\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  return node;\n};\n\nexport default R.curryN(2, clipNode);\n","import * as R from 'ramda';\n\nconst renderPath = ctx =>\n  R.tap(node => {\n    const d = R.path(['props', 'd'], node);\n    if (d) ctx.path(node.props.d);\n  });\n\nexport default renderPath;\n","import * as R from 'ramda';\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst getProp = (d, p, v) => R.pathOr(d, ['props', p], v);\n\nconst renderRect = ctx => node => {\n  const x = getProp(0, 'x', node);\n  const y = getProp(0, 'y', node);\n  const rx = getProp(0, 'rx', node);\n  const ry = getProp(0, 'ry', node);\n  const width = getProp(0, 'width', node);\n  const height = getProp(0, 'height', node);\n\n  if (!width || !height) return node;\n\n  if (rx && ry) {\n    const krx = rx * KAPPA;\n    const kry = ry * KAPPA;\n\n    ctx.moveTo(x + rx, y);\n    ctx.lineTo(x - rx + width, y);\n    ctx.bezierCurveTo(\n      x - rx + width + krx,\n      y,\n      x + width,\n      y + ry - kry,\n      x + width,\n      y + ry,\n    );\n    ctx.lineTo(x + width, y + height - ry);\n    ctx.bezierCurveTo(\n      x + width,\n      y + height - ry + kry,\n      x - rx + width + krx,\n      y + height,\n      x - rx + width,\n      y + height,\n    );\n    ctx.lineTo(x + rx, y + height);\n    ctx.bezierCurveTo(\n      x + rx - krx,\n      y + height,\n      x,\n      y + height - ry + kry,\n      x,\n      y + height - ry,\n    );\n    ctx.lineTo(x, y + ry);\n    ctx.bezierCurveTo(x, y + ry - kry, x + rx - krx, y, x + rx, y);\n  } else {\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n  }\n\n  ctx.closePath();\n\n  return node;\n};\n\nexport default renderRect;\n","import * as R from 'ramda';\n\nconst getProp = (p, v) => R.path(['props', p], v);\n\nconst renderLine = ctx => node => {\n  const x1 = getProp('x1', node);\n  const y1 = getProp('y1', node);\n  const x2 = getProp('x2', node);\n  const y2 = getProp('y2', node);\n\n  ctx.moveTo(x1, y1);\n  ctx.lineTo(x2, y2);\n\n  return node;\n};\n\nexport default renderLine;\n","import * as R from 'ramda';\n\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst getProp = (p, v) => R.path(['props', p], v);\n\nexport const drawEllipse = (ctx, cx, cy, rx, ry) => {\n  const x = cx - rx;\n  const y = cy - ry;\n  const ox = rx * KAPPA;\n  const oy = ry * KAPPA;\n  const xe = x + rx * 2;\n  const ye = y + ry * 2;\n  const xm = x + rx;\n  const ym = y + ry;\n\n  ctx.moveTo(x, ym);\n  ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n  ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n  ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n  ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n  ctx.closePath();\n};\n\nconst renderEllipse = ctx =>\n  R.tap(node => {\n    const cx = getProp('cx', node);\n    const cy = getProp('cy', node);\n    const rx = getProp('rx', node);\n    const ry = getProp('ry', node);\n\n    drawEllipse(ctx, cx, cy, rx, ry);\n  });\n\nexport default renderEllipse;\n","import * as R from 'ramda';\n\nimport { drawEllipse } from './renderEllipse';\n\nconst getProp = (p, v) => R.path(['props', p], v);\n\nconst renderCircle = ctx =>\n  R.tap(node => {\n    const cx = getProp('cx', node);\n    const cy = getProp('cy', node);\n    const r = getProp('r', node);\n\n    drawEllipse(ctx, cx, cy, r, r);\n  });\n\nexport default renderCircle;\n","import * as R from 'ramda';\n\nimport runWidth from '@react-pdf/textkit/run/advanceWidth';\nimport lineWidth from '@react-pdf/textkit/attributedString/advanceWidth';\n\nconst renderRun = (ctx, run) => {\n  const runAdvanceWidth = runWidth(run);\n  const { font, fontSize, color, opacity } = run.attributes;\n\n  ctx.fillColor(color);\n  ctx.fillOpacity(opacity);\n\n  if (font.sbix || (font.COLR && font.CPAL)) {\n    ctx.save();\n    ctx.translate(0, -run.ascent);\n\n    for (let i = 0; i < run.glyphs.length; i++) {\n      const position = run.positions[i];\n      const glyph = run.glyphs[i];\n\n      ctx.save();\n      ctx.translate(position.xOffset, position.yOffset);\n\n      glyph.render(ctx, fontSize);\n\n      ctx.restore();\n      ctx.translate(position.xAdvance, position.yAdvance);\n    }\n\n    ctx.restore();\n  } else {\n    ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n    try {\n      ctx._addGlyphs(run.glyphs, run.positions, 0, 0);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  ctx.translate(runAdvanceWidth, 0);\n};\n\nconst renderSpan = (ctx, line, textAnchor) => {\n  ctx.save();\n\n  const x = R.pathOr(0, ['box', 'x'], line);\n  const y = R.pathOr(0, ['box', 'y'], line);\n  const width = lineWidth(line);\n\n  switch (textAnchor) {\n    case 'middle':\n      ctx.translate(x - width / 2, y);\n      break;\n    case 'end':\n      ctx.translate(x - width, y);\n      break;\n    default:\n      ctx.translate(x, y);\n      break;\n  }\n\n  for (const run of line.runs) {\n    renderRun(ctx, run);\n  }\n\n  ctx.restore();\n};\n\nconst renderSvgText = ctx => node => {\n  for (const span of node.children) {\n    renderSpan(ctx, span.lines[0], span.props.textAnchor);\n  }\n\n  return node;\n};\n\nexport default renderSvgText;\n","import * as R from 'ramda';\n\nconst isOdd = x => x % 2 !== 0;\n\nconst lengthIsOdd = R.o(isOdd, R.prop('length'));\n\nconst parsePoints = R.compose(\n  R.splitEvery(2),\n  R.map(parseFloat),\n  R.when(lengthIsOdd, R.slice(0, -1)),\n  R.split(/\\s+/),\n  R.replace(/(\\d)-(\\d)/g, '$1 -$2'),\n  R.replace(/,/g, ' '),\n  R.trim,\n);\n\nexport default parsePoints;\n","import * as R from 'ramda';\n\nimport parsePoints from '../svg/parsePoints';\n\nexport const drawPolyline = ctx => points => {\n  if (points.length > 0) {\n    ctx.moveTo(points[0][0], points[0][1]);\n    points.slice(1).forEach(p => ctx.lineTo(p[0], p[1]));\n  }\n};\n\nconst renderPolyline = ctx =>\n  R.tap(\n    R.compose(\n      drawPolyline(ctx),\n      parsePoints,\n      R.pathOr('', ['props', 'points']),\n    ),\n  );\n\nexport default renderPolyline;\n","import * as R from 'ramda';\n\nimport renderPolyline from './renderPolyline';\n\nconst closePath = ctx => R.tap(() => ctx.closePath());\n\nconst renderPolygon = ctx =>\n  R.compose(\n    closePath(ctx),\n    renderPolyline(ctx),\n  );\n\nexport default renderPolygon;\n","function printWarning(format, ...args) {\n  let argIndex = 0;\n  const message = 'Warning: ' + format.replace(/%s/g, () => args[argIndex++]);\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n}\n\nconst __DEV__ = process.env.NODE_ENV !== 'production';\n\nconst warning = __DEV__\n  ? (condition, format, ...args) => {\n      if (format === undefined) {\n        throw new Error(\n          '`warning(condition, format, ...args)` requires a warning ' +\n            'message argument',\n        );\n      }\n      if (!condition) {\n        printWarning(format, ...args);\n      }\n    }\n  : () => {};\n\nexport default warning;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport warning from '../utils/warning';\n\nconst drawImage = ctx => node => {\n  const { x, y } = node.props;\n  const { width, height, opacity } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      ctx\n        .fillOpacity(opacity || 1)\n        .image(node.image.data, x + paddingLeft, y + paddingTop, {\n          width,\n          height,\n        });\n    } else {\n      warning(\n        false,\n        `Image with src '${node.props.href}' skipped due to invalid dimensions`,\n      );\n    }\n  }\n\n  return node;\n};\n\nconst renderImage = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawImage(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderImage);\n","import * as R from 'ramda';\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\n\nconst getRotation = transform => {\n  const match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    const value = match[1];\n    return match[2] === 'rad' ? (value * 180) / Math.PI : value;\n  }\n\n  return 0;\n};\n\nconst getTranslateX = transform => {\n  const matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?d*).*(,|\\s)\\s*(-?\\d+\\.?d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n\n  return 0;\n};\n\nconst getTranslateY = transform => {\n  const matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /translate\\((-?\\d+\\.?\\d*).*(,|\\s)\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[3]) return matchGeneric[3];\n\n  return 0;\n};\n\nconst getScaleX = transform => {\n  const matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n\n  return 1;\n};\n\nconst getScaleY = transform => {\n  const matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  const matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,?\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(\n    transform,\n  );\n\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n\n  return 1;\n};\n\nconst getMatrix = transform => {\n  const match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(\n    transform,\n  );\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nconst applySingleTransformation = (ctx, transform, origin) => {\n  if (/rotate/g.test(transform)) {\n    ctx.rotate(getRotation(transform), { origin });\n  } else if (/scaleX/g.test(transform)) {\n    ctx.scale(getScaleX(transform), 1, { origin });\n  } else if (/scaleY/g.test(transform)) {\n    ctx.scale(1, getScaleY(transform), { origin });\n  } else if (/scale/g.test(transform)) {\n    ctx.scale(getScaleX(transform), getScaleY(transform), {\n      origin,\n    });\n  } else if (/translateX/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), 1, { origin });\n  } else if (/translateY/g.test(transform)) {\n    ctx.translate(1, getTranslateY(transform), { origin });\n  } else if (/translate/g.test(transform)) {\n    ctx.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin,\n    });\n  } else if (/matrix/g.test(transform)) {\n    ctx.transform(...getMatrix(transform));\n  }\n};\n\nconst applyTransformations = (ctx, node) => {\n  if (!node.origin) return node;\n\n  let match;\n  const re = /[a-zA-Z]+\\([^)]+\\)/g;\n  const origin = [node.origin.left, node.origin.top];\n  const transform =\n    (node.style && node.style.transform) ||\n    (node.props && node.props.transform) ||\n    '';\n\n  while ((match = re.exec(transform)) != null) {\n    applySingleTransformation(ctx, match[0], origin);\n  }\n\n  return node;\n};\n\nexport default R.curryN(2, applyTransformations);\n","import * as R from 'ramda';\n\nimport { PATH } from '../constants';\n\n/**\n * Checks if node is path\n *\n * @param {Object} node\n * @returns {Boolean} is node path?\n */\nconst isPath = R.propEq('type', PATH);\n\nexport default isPath;\n","import * as R from 'ramda';\n\nimport { RECT } from '../constants';\n\n/**\n * Checks if node is rect\n *\n * @param {Object} node\n * @returns {Boolean} is node rect?\n */\nconst isRect = R.propEq('type', RECT);\n\nexport default isRect;\n","import * as R from 'ramda';\n\nimport { LINE } from '../constants';\n\n/**\n * Checks if node is line\n *\n * @param {Object} node\n * @returns {Boolean} is node line?\n */\nconst isLine = R.propEq('type', LINE);\n\nexport default isLine;\n","import * as R from 'ramda';\n\nimport { TSPAN } from '../constants';\n\n/**\n * Checks if node is tspan\n *\n * @param {Object} node\n * @returns {Boolean} is node tspan?\n */\nconst isTspan = R.propEq('type', TSPAN);\n\nexport default isTspan;\n","import * as R from 'ramda';\n\nimport { GROUP } from '../constants';\n\n/**\n * Checks if node is group\n *\n * @param {Object} node\n * @returns {Boolean} is node group?\n */\nconst isGroup = R.propEq('type', GROUP);\n\nexport default isGroup;\n","import * as R from 'ramda';\n\nimport { CIRCLE } from '../constants';\n\n/**\n * Checks if node is circle\n *\n * @param {Object} node\n * @returns {Boolean} is node circle?\n */\nconst isCircle = R.propEq('type', CIRCLE);\n\nexport default isCircle;\n","import * as R from 'ramda';\n\nimport { TEXT_INSTANCE } from '../constants';\n\n/**\n * Checks if node is text intance\n *\n * @param {Object} node\n * @returns {Boolean} is node text intance?\n */\nconst isTextInstance = R.propEq('type', TEXT_INSTANCE);\n\nexport default isTextInstance;\n","import * as R from 'ramda';\n\nconst renderGroup = () => R.identity;\n\nexport default renderGroup;\n","import * as R from 'ramda';\n\nimport { ELLIPSE } from '../constants';\n\n/**\n * Checks if node is ellipse\n *\n * @param {Object} node\n * @returns {Boolean} is node ellipse?\n */\nconst isEllipse = R.propEq('type', ELLIPSE);\n\nexport default isEllipse;\n","import * as R from 'ramda';\n\nimport { POLYGON } from '../constants';\n\n/**\n * Checks if node is polygon\n *\n * @param {Object} node\n * @returns {Boolean} is node polygon?\n */\nconst isPolygon = R.propEq('type', POLYGON);\n\nexport default isPolygon;\n","import * as R from 'ramda';\n\nimport { POLYLINE } from '../constants';\n\n/**\n * Checks if node is polyline\n *\n * @param {Object} node\n * @returns {Boolean} is node polyline?\n */\nconst isPolyline = R.propEq('type', POLYLINE);\n\nexport default isPolyline;\n","import arcToCurve from 'svg-arc-to-cubic-bezier';\n\n// From https://github.com/jkroso/normalize-svg-path/blob/master/index.js\n// Copied here because an import issue with 'svg-arc-to-cubic-bezier'\nconst normalizePath = path => {\n  const result = [];\n\n  let prev;\n  let bezierX = 0;\n  let bezierY = 0;\n  let startX = 0;\n  let startY = 0;\n  let quadX = null;\n  let quadY = null;\n  let x = 0;\n  let y = 0;\n\n  for (let i = 0, len = path.length; i < len; i++) {\n    let seg = path[i];\n    const command = seg[0];\n\n    switch (command) {\n      case 'M':\n        startX = seg[1];\n        startY = seg[2];\n        break;\n      case 'A':\n        const curves = arcToCurve({\n          px: x,\n          py: y,\n          cx: seg[6],\n          cy: seg[7],\n          rx: seg[1],\n          ry: seg[2],\n          xAxisRotation: seg[3],\n          largeArcFlag: seg[4],\n          sweepFlag: seg[5],\n        });\n\n        // null-curves\n        if (!curves.length) continue;\n\n        for (let j = 0, c; j < curves.length; j++) {\n          c = curves[j];\n          seg = ['C', c.x1, c.y1, c.x2, c.y2, c.x, c.y];\n          if (j < curves.length - 1) result.push(seg);\n        }\n\n        break;\n      case 'S':\n        // default control point\n        let cx = x;\n        let cy = y;\n        if (prev === 'C' || prev === 'S') {\n          cx += cx - bezierX; // reflect the previous command's control\n          cy += cy - bezierY; // point relative to the current point\n        }\n        seg = ['C', cx, cy, seg[1], seg[2], seg[3], seg[4]];\n        break;\n      case 'T':\n        if (prev === 'Q' || prev === 'T') {\n          quadX = x * 2 - quadX; // as with 'S' reflect previous control point\n          quadY = y * 2 - quadY;\n        } else {\n          quadX = x;\n          quadY = y;\n        }\n        seg = quadratic(x, y, quadX, quadY, seg[1], seg[2]);\n        break;\n      case 'Q':\n        quadX = seg[1];\n        quadY = seg[2];\n        seg = quadratic(x, y, seg[1], seg[2], seg[3], seg[4]);\n        break;\n      case 'L':\n        seg = line(x, y, seg[1], seg[2]);\n        break;\n      case 'H':\n        seg = line(x, y, seg[1], y);\n        break;\n      case 'V':\n        seg = line(x, y, x, seg[1]);\n        break;\n      case 'Z':\n        seg = line(x, y, startX, startY);\n        break;\n      default:\n        break;\n    }\n\n    // update state\n    prev = command;\n    x = seg[seg.length - 2];\n    y = seg[seg.length - 1];\n    if (seg.length > 4) {\n      bezierX = seg[seg.length - 4];\n      bezierY = seg[seg.length - 3];\n    } else {\n      bezierX = x;\n      bezierY = y;\n    }\n    result.push(seg);\n  }\n\n  return result;\n};\n\nconst line = (x1, y1, x2, y2) => {\n  return ['C', x1, y1, x2, y2, x2, y2];\n};\n\nconst quadratic = (x1, y1, cx, cy, x2, y2) => {\n  return [\n    'C',\n    x1 / 3 + (2 / 3) * cx,\n    y1 / 3 + (2 / 3) * cy,\n    x2 / 3 + (2 / 3) * cx,\n    y2 / 3 + (2 / 3) * cy,\n    x2,\n    y2,\n  ];\n};\n\nexport default normalizePath;\n","import * as R from 'ramda';\nimport absPath from 'abs-svg-path';\nimport parsePath from 'parse-svg-path';\n\nimport isRect from '../node/isRect';\nimport isLine from '../node/isLine';\nimport isPath from '../node/isPath';\nimport isCircle from '../node/isCircle';\nimport isPolygon from '../node/isPolygon';\nimport isEllipse from '../node/isEllipse';\nimport isPolyline from '../node/isPolyline';\nimport normalizePath from '../svg/normalizePath';\nimport parsePoints from './parsePoints';\n\n// From https://github.com/dy/svg-path-bounds/blob/master/index.js\nconst getPathBoundingBox = node => {\n  const path = R.compose(\n    normalizePath,\n    absPath,\n    parsePath,\n    R.pathOr('', ['props', 'd']),\n  )(node);\n\n  if (!path.length) return [0, 0, 0, 0];\n\n  const bounds = [Infinity, Infinity, -Infinity, -Infinity];\n\n  for (let i = 0, l = path.length; i < l; i++) {\n    const points = path[i].slice(1);\n\n    for (let j = 0; j < points.length; j += 2) {\n      if (points[j + 0] < bounds[0]) bounds[0] = points[j + 0];\n      if (points[j + 1] < bounds[1]) bounds[1] = points[j + 1];\n      if (points[j + 0] > bounds[2]) bounds[2] = points[j + 0];\n      if (points[j + 1] > bounds[3]) bounds[3] = points[j + 1];\n    }\n  }\n\n  return bounds;\n};\n\nconst getCircleBoundingBox = node => {\n  const r = R.pathOr(0, ['props', 'r'], node);\n  const cx = R.pathOr(0, ['props', 'cx'], node);\n  const cy = R.pathOr(0, ['props', 'cy'], node);\n\n  return [cx - r, cy - r, cx + r, cy + r];\n};\n\nconst getEllipseBoundingBox = node => {\n  const cx = R.pathOr(0, ['props', 'cx'], node);\n  const cy = R.pathOr(0, ['props', 'cy'], node);\n  const rx = R.pathOr(0, ['props', 'rx'], node);\n  const ry = R.pathOr(0, ['props', 'ry'], node);\n\n  return [cx - rx, cy - ry, cx + rx, cy + ry];\n};\n\nconst getLineBoundingBox = node => {\n  const x1 = R.pathOr(0, ['props', 'x1'], node);\n  const y1 = R.pathOr(0, ['props', 'y1'], node);\n  const x2 = R.pathOr(0, ['props', 'x2'], node);\n  const y2 = R.pathOr(0, ['props', 'y2'], node);\n\n  return [R.min(x1, x2), R.min(y1, y2), R.max(x1, x2), R.max(y1, y2)];\n};\n\nconst getRectBoundingBox = node => {\n  const x = R.pathOr(0, ['props', 'x'], node);\n  const y = R.pathOr(0, ['props', 'y'], node);\n  const width = R.pathOr(0, ['props', 'width'], node);\n  const height = R.pathOr(0, ['props', 'height'], node);\n\n  return [x, y, x + width, y + height];\n};\n\nconst max = R.reduce(R.max, -Infinity);\nconst min = R.reduce(R.min, Infinity);\n\nconst getPolylineBoundingBox = node => {\n  const points = R.compose(\n    parsePoints,\n    R.pathOr([], ['props', 'points']),\n  )(node);\n\n  const xValues = R.pluck(0, points);\n  const yValues = R.pluck(1, points);\n\n  return [min(xValues), min(yValues), max(xValues), max(yValues)];\n};\n\nconst getBoundingBox = R.cond([\n  [isRect, getRectBoundingBox],\n  [isLine, getLineBoundingBox],\n  [isPath, getPathBoundingBox],\n  [isCircle, getCircleBoundingBox],\n  [isEllipse, getEllipseBoundingBox],\n  [isPolygon, getPolylineBoundingBox],\n  [isPolyline, getPolylineBoundingBox],\n  [R.T, R.always([0, 0, 0, 0])],\n]);\n\nexport default getBoundingBox;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\nimport renderPath from './renderPath';\nimport renderRect from './renderRect';\nimport renderLine from './renderLine';\nimport renderCircle from './renderCircle';\nimport renderSvgText from './renderSvgText';\nimport renderEllipse from './renderEllipse';\nimport renderPolygon from './renderPolygon';\nimport renderPolyline from './renderPolyline';\nimport renderSvgImage from './renderSvgImage';\nimport applyTransformations from './applyTransformations';\nimport isPath from '../node/isPath';\nimport isText from '../node/isText';\nimport isRect from '../node/isRect';\nimport isLine from '../node/isLine';\nimport isTspan from '../node/isTspan';\nimport isImage from '../node/isImage';\nimport isGroup from '../node/isGroup';\nimport isCircle from '../node/isCircle';\nimport isTextInstance from '../node/isTextInstance';\nimport renderGroup from './renderGroup';\nimport isEllipse from '../node/isEllipse';\nimport isPolygon from '../node/isPolygon';\nimport isPolyline from '../node/isPolyline';\nimport getBoundingBox from '../svg/getBoundingBox';\nimport { LINEAR_GRADIENT, RADIAL_GRADIENT } from '../constants';\n\nconst warnUnsupportedNode = R.tap(node => {\n  console.warn(`SVG node of type ${node.type} is not currenty supported`);\n});\n\nconst getProp = (d, p, v) => R.pathOr(d, ['props', p], v);\n\nconst setStrokeWidth = ctx => node => {\n  const lineWidth = getProp(0, 'strokeWidth', node);\n  if (lineWidth) ctx.lineWidth(lineWidth);\n  return node;\n};\n\nconst setStrokeColor = ctx => node => {\n  const strokeColor = getProp(null, 'stroke', node);\n  if (strokeColor) ctx.strokeColor(strokeColor);\n  return node;\n};\n\nconst setOpacity = ctx => node => {\n  const opacity = getProp(null, 'opacity', node);\n  if (opacity) ctx.opacity(opacity);\n  return node;\n};\n\nconst setFillOpacity = ctx => node => {\n  const fillOpacity = getProp(null, 'fillOpacity', node);\n  if (fillOpacity) ctx.fillOpacity(fillOpacity);\n  return node;\n};\n\nconst setStrokeOpacity = ctx => node => {\n  const strokeOpacity = getProp(null, 'strokeOpacity', node);\n  if (strokeOpacity) ctx.strokeOpacity(strokeOpacity);\n  return node;\n};\n\nconst setLineJoin = ctx => node => {\n  const lineJoin = getProp(null, 'strokeLinejoin', node);\n  if (lineJoin) ctx.lineJoin(lineJoin);\n  return node;\n};\n\nconst setLineCap = ctx => node => {\n  const lineCap = getProp(null, 'strokeLinecap', node);\n  if (lineCap) ctx.lineCap(lineCap);\n  return node;\n};\n\nconst setLineDash = ctx => node => {\n  const value = getProp(null, 'strokeDasharray', node);\n\n  if (value) {\n    const dashArray = R.compose(\n      R.map(R.o(parseFloat, R.trim)),\n      R.split(','),\n    )(value);\n\n    ctx.dash(dashArray[0], { space: dashArray[1] });\n  }\n  return node;\n};\n\nconst hasLinearGradientFill = R.pathEq(\n  ['props', 'fill', 'type'],\n  LINEAR_GRADIENT,\n);\n\nconst hasRadialGradientFill = R.pathEq(\n  ['props', 'fill', 'type'],\n  RADIAL_GRADIENT,\n);\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L104\nconst setLinearGradientFill = ctx =>\n  R.tap(node => {\n    const bbox = getBoundingBox(node);\n    const gradient = getProp(null, 'fill', node);\n\n    const x1 = R.pathOr(0, ['props', 'x1'], gradient);\n    const y1 = R.pathOr(0, ['props', 'y1'], gradient);\n    const x2 = R.pathOr(1, ['props', 'x2'], gradient);\n    const y2 = R.pathOr(0, ['props', 'y2'], gradient);\n\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n\n    const gx1 = m0 * x1 + m4;\n    const gy1 = m3 * y1 + m5;\n    const gx2 = m0 * x2 + m4;\n    const gy2 = m3 * y2 + m5;\n\n    const grad = ctx.linearGradient(gx1, gy1, gx2, gy2);\n\n    gradient.children.forEach(stop => {\n      grad.stop(\n        stop.props.offset,\n        stop.props.stopColor,\n        stop.props.stopOpacity,\n      );\n    });\n\n    ctx.fill(grad);\n  });\n\n// Math simplified from https://github.com/devongovett/svgkit/blob/master/src/elements/SVGGradient.js#L155\nconst setRadialGradientFill = ctx =>\n  R.tap(node => {\n    const bbox = getBoundingBox(node);\n    const gradient = getProp(null, 'fill', node);\n\n    const cx = R.pathOr(0.5, ['props', 'cx'], gradient);\n    const cy = R.pathOr(0.5, ['props', 'cy'], gradient);\n    const fx = R.pathOr(cx, ['props', 'fx'], gradient);\n    const fy = R.pathOr(cy, ['props', 'fy'], gradient);\n    const r = R.pathOr(0.5, ['props', 'r'], gradient);\n\n    const m0 = bbox[2] - bbox[0];\n    const m3 = bbox[3] - bbox[1];\n    const m4 = bbox[0];\n    const m5 = bbox[1];\n\n    const gr = r * m0;\n    const gcx = m0 * cx + m4;\n    const gcy = m3 * cy + m5;\n    const gfx = m0 * fx + m4;\n    const gfy = m3 * fy + m5;\n\n    const grad = ctx.radialGradient(gfx, gfy, 0, gcx, gcy, gr);\n\n    gradient.children.forEach(stop => {\n      grad.stop(\n        stop.props.offset,\n        stop.props.stopColor,\n        stop.props.stopOpacity,\n      );\n    });\n\n    ctx.fill(grad);\n  });\n\nconst setFillColor = ctx =>\n  R.tap(node => {\n    const fillColor = getProp(null, 'fill', node);\n    if (fillColor) ctx.fillColor(fillColor);\n  });\n\nconst setFill = ctx =>\n  R.cond([\n    [hasLinearGradientFill, setLinearGradientFill(ctx)],\n    [hasRadialGradientFill, setRadialGradientFill(ctx)],\n    [R.T, setFillColor(ctx)],\n  ]);\n\nconst draw = ctx => node => {\n  const props = R.propOr({}, 'props', node);\n\n  if (props.fill && props.stroke) {\n    ctx.fillAndStroke(props.fillRule);\n  } else if (props.fill) {\n    ctx.fill(props.fillRule);\n  } else if (props.stroke) {\n    ctx.stroke();\n  } else {\n    ctx.save();\n    ctx.opacity(0);\n    ctx.fill(null);\n    ctx.restore();\n  }\n\n  return node;\n};\n\nconst renderNode = ctx =>\n  R.cond([\n    [isTspan, R.identity],\n    [isTextInstance, R.identity],\n    [isPath, renderPath(ctx)],\n    [isRect, renderRect(ctx)],\n    [isLine, renderLine(ctx)],\n    [isGroup, renderGroup(ctx)],\n    [isText, renderSvgText(ctx)],\n    [isCircle, renderCircle(ctx)],\n    [isImage, renderSvgImage(ctx)],\n    [isEllipse, renderEllipse(ctx)],\n    [isPolygon, renderPolygon(ctx)],\n    [isPolyline, renderPolyline(ctx)],\n    [R.T, warnUnsupportedNode],\n  ]);\n\nconst drawNode = ctx =>\n  R.compose(\n    draw(ctx),\n    renderNode(ctx),\n    applyTransformations(ctx),\n    setOpacity(ctx),\n    setFillOpacity(ctx),\n    setStrokeOpacity(ctx),\n    setFill(ctx),\n    setStrokeColor(ctx),\n    setStrokeWidth(ctx),\n    setLineJoin(ctx),\n    setLineDash(ctx),\n    setLineCap(ctx),\n  );\n\nconst clipPath = ctx => node => {\n  const value = R.path(['props', 'clipPath'], node);\n\n  if (value) {\n    R.compose(\n      () => ctx.clip(),\n      R.forEach(renderNode(ctx)),\n      R.propOr([], 'children'),\n    )(value);\n  }\n\n  return node;\n};\n\nconst drawChildren = ctx => node =>\n  R.compose(\n    R.map(\n      R.compose(\n        restore(ctx),\n        drawChildren(ctx),\n        drawNode(ctx),\n        clipPath(ctx),\n        save(ctx),\n      ),\n    ),\n    R.propOr([], 'children'),\n  )(node);\n\nconst defaultsZero = R.pathOr(0);\n\nconst preserveAspectRatio = ctx => node => {\n  const { width, height } = node.box;\n  const { viewBox, preserveAspectRatio = {} } = node.props;\n  const { meetOrSlice = 'meet', align = 'xMidYMid' } = preserveAspectRatio;\n\n  if (viewBox == null || width == null || height == null) return node;\n\n  const x = viewBox ? viewBox.minX : 0;\n  const y = viewBox ? viewBox.minY : 0;\n  const logicalWidth = viewBox ? viewBox.maxX : width;\n  const logicalHeight = viewBox ? viewBox.maxY : height;\n\n  const logicalRatio = logicalWidth / logicalHeight;\n  const physicalRatio = width / height;\n  const scaleX = width / logicalWidth;\n  const scaleY = height / logicalHeight;\n\n  if (align === 'none') {\n    ctx.scale(scaleX, scaleY);\n    ctx.translate(-x, -y);\n    return node;\n  }\n\n  if (\n    (logicalRatio < physicalRatio && meetOrSlice === 'meet') ||\n    (logicalRatio >= physicalRatio && meetOrSlice === 'slice')\n  ) {\n    ctx.scale(scaleY, scaleY);\n\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMinYMid':\n      case 'xMinYMax':\n        ctx.translate(-x, -y);\n        break;\n\n      case 'xMidYMin':\n      case 'xMidYMid':\n      case 'xMidYMax':\n        ctx.translate(\n          -x - (logicalWidth - (width * logicalHeight) / height) / 2,\n          -y,\n        );\n        break;\n\n      default:\n        ctx.translate(\n          -x - (logicalWidth - (width * logicalHeight) / height),\n          -y,\n        );\n    }\n  } else {\n    ctx.scale(scaleX, scaleX);\n\n    switch (align) {\n      case 'xMinYMin':\n      case 'xMidYMin':\n      case 'xMaxYMin':\n        ctx.translate(-x, -y);\n        break;\n\n      case 'xMinYMid':\n      case 'xMidYMid':\n      case 'xMaxYMid':\n        ctx.translate(\n          -x,\n          -y - (logicalHeight - (height * logicalWidth) / width) / 2,\n        );\n        break;\n\n      default:\n        ctx.translate(\n          -x,\n          -y - (logicalHeight - (height * logicalWidth) / width),\n        );\n    }\n  }\n\n  return node;\n};\n\nconst moveToOrigin = ctx => node => {\n  const { top, left } = node.box;\n\n  const paddingLeft = defaultsZero('paddingLeft', node.box);\n  const paddingTop = defaultsZero('paddingTop', node.box);\n\n  ctx.translate(left + paddingLeft, top + paddingTop);\n\n  return node;\n};\n\nconst renderSvg = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawChildren(ctx),\n    preserveAspectRatio(ctx),\n    moveToOrigin(ctx),\n    clipNode(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderSvg);\n","import * as R from 'ramda';\nimport PDFRenderer from '@react-pdf/textkit/renderers/pdf';\n\nconst renderText = (ctx, node) => {\n  const { top, left } = node.box;\n  const paddingTop = R.pathOr(0, ['box', 'paddingTop'], node);\n  const paddingLeft = R.pathOr(0, ['box', 'paddingLeft'], node);\n  const initialY = node.lines[0] ? node.lines[0].box.y : 0;\n\n  ctx.save();\n  ctx.translate(left + paddingLeft, top + paddingTop - initialY);\n\n  PDFRenderer.render(ctx, [node.lines]);\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderText);\n","import * as R from 'ramda';\n\nconst renderPage = (ctx, node) => {\n  const { width, height } = node.box;\n\n  ctx.addPage({ size: [width, height], margin: 0 });\n\n  return node;\n};\n\nexport default R.curryN(2, renderPage);\n","import * as R from 'ramda';\n\nconst renderNote = (ctx, node) => {\n  const { top, left } = node.box;\n  const value = node.children[0] ? node.children[0].value : '';\n\n  ctx.note(left, top, 0, 0, value);\n\n  return node;\n};\n\nexport default R.curryN(2, renderNote);\n","const isPercent = value => /((-)?\\d+\\.?\\d*)%/g.exec(value);\n\n/**\n * Get percentage value of input\n *\n * @param {String} value\n * @returns {Object} percent value (if matches)\n */\nconst matchPercent = value => {\n  const match = isPercent(value);\n\n  if (match) {\n    const value = parseFloat(match[1], 10);\n    const percent = value / 100;\n\n    return {\n      value,\n      percent,\n      absValue: Math.abs(value),\n      absPercent: Math.abs(percent),\n    };\n  }\n\n  return null;\n};\n\nexport default matchPercent;\n","import matchPercent from '../utils/matchPercent';\n\nconst isNumeric = n => {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nconst applyContainObjectFit = (cw, ch, iw, ih, px, py) => {\n  const cr = cw / ch;\n  const ir = iw / ih;\n\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const height = ch;\n    const width = height * ir;\n    const yOffset = isNumeric(py) ? py : 0;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n\n    return { width, height, xOffset, yOffset };\n  } else {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n\n    return { width, height, yOffset, xOffset };\n  }\n};\n\nconst applyNoneObjectFit = (cw, ch, iw, ih, px, py) => {\n  const width = iw;\n  const height = ih;\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n  const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n\n  return { width, height, xOffset, yOffset };\n};\n\nconst applyCoverObjectFit = (cw, ch, iw, ih, px, py) => {\n  const ir = iw / ih;\n  const cr = cw / ch;\n\n  const pxp = matchPercent(px);\n  const pyp = matchPercent(py);\n  const pxv = pxp ? pxp.percent : 0.5;\n  const pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    const width = cw;\n    const height = width / ir;\n    const xOffset = isNumeric(px) ? px : 0;\n    const yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return { width, height, yOffset, xOffset };\n  } else {\n    const height = ch;\n    const width = height * ir;\n    const xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    const yOffset = isNumeric(py) ? py : 0;\n    return { width, height, xOffset, yOffset };\n  }\n};\n\nconst applyScaleDownObjectFit = (cw, ch, iw, ih, px, py) => {\n  const containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  const noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n  return containDimension.width < noneDimension.width\n    ? containDimension\n    : noneDimension;\n};\n\nconst applyFillObjectFit = (cw, ch, px, py) => {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0,\n  };\n};\n\nconst resolveObjectFit = (type = 'fill', cw, ch, iw, ih, px, py) => {\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nexport default resolveObjectFit;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\nimport warning from '../utils/warning';\nimport resolveObjectFit from '../image/resolveObjectFit';\n\nconst drawImage = ctx => node => {\n  const { left, top } = node.box;\n  const { opacity, objectPositionX, objectPositionY } = node.style;\n  const paddingTop = node.box.paddingLeft || 0;\n  const paddingRight = node.box.paddingRight || 0;\n  const paddingBottom = node.box.paddingBottom || 0;\n  const paddingLeft = node.box.paddingLeft || 0;\n\n  const { width, height, xOffset, yOffset } = resolveObjectFit(\n    node.style.objectFit,\n    node.box.width - paddingLeft - paddingRight,\n    node.box.height - paddingTop - paddingBottom,\n    node.image.width,\n    node.image.height,\n    objectPositionX,\n    objectPositionY,\n  );\n\n  if (node.image.data) {\n    if (width !== 0 && height !== 0) {\n      ctx\n        .fillOpacity(opacity || 1)\n        .image(\n          node.image.data,\n          left + paddingLeft + xOffset,\n          top + paddingTop + yOffset,\n          {\n            width,\n            height,\n          },\n        );\n    } else {\n      warning(\n        false,\n        `Image with src '${node.props.src}' skipped due to invalid dimensions`,\n      );\n    }\n  }\n\n  return node;\n};\n\nconst renderImage = (ctx, node) => {\n  R.compose(\n    restore(ctx),\n    drawImage(ctx),\n    clipNode(ctx),\n    save(ctx),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderImage);\n","export const availableMethods = [\n  'dash',\n  'clip',\n  'save',\n  'path',\n  'fill',\n  'font',\n  'text',\n  'rect',\n  'scale',\n  'moveTo',\n  'lineTo',\n  'stroke',\n  'rotate',\n  'circle',\n  'lineCap',\n  'opacity',\n  'ellipse',\n  'polygon',\n  'restore',\n  'lineJoin',\n  'fontSize',\n  'fillColor',\n  'lineWidth',\n  'translate',\n  'miterLimit',\n  'strokeColor',\n  'fillOpacity',\n  'roundedRect',\n  'strokeOpacity',\n  'bezierCurveTo',\n  'quadraticCurveTo',\n  'linearGradient',\n  'radialGradient',\n];\n\nconst painter = function(ctx) {\n  const p = availableMethods.reduce(\n    (acc, prop) => ({\n      ...acc,\n      [prop]: (...args) => {\n        ctx[prop](...args);\n        return p;\n      },\n    }),\n    {},\n  );\n\n  return p;\n};\n\nexport default painter;\n","import * as R from 'ramda';\n\nimport painter from '../canvas/painter';\nimport warning from '../utils/warning';\n\nconst defaultsZero = R.pathOr(0);\n\nconst renderCanvas = (ctx, node) => {\n  const { top, left, width, height } = node.box;\n\n  const paddingLeft = defaultsZero('paddingLeft', node.box);\n  const paddingRight = defaultsZero('paddingRight', node.box);\n  const paddingTop = defaultsZero('paddingTop', node.box);\n  const paddingBottom = defaultsZero('paddingBottom', node.box);\n\n  const availableWidth = width - paddingLeft - paddingRight;\n  const availableHeight = height - paddingTop - paddingBottom;\n\n  warning(\n    availableWidth && availableHeight,\n    'Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.',\n  );\n\n  ctx.save().translate(left + paddingLeft, top + paddingTop);\n\n  if (node.props.paint) {\n    node.props.paint(painter(ctx), availableWidth, availableHeight);\n  }\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderCanvas);\n","import * as R from 'ramda';\n\n/**\n * Checks if page should render vertical ruler\n *\n * @param {Object} page\n * @returns {boolean} has vertical ruler\n */\nconst hasVerticalRuler = R.either(\n  R.hasPath(['props', 'ruler']),\n  R.hasPath(['props', 'verticalRuler']),\n);\n\nexport default hasVerticalRuler;\n","import * as R from 'ramda';\n\n/**\n * Checks if page should render horizontal ruler\n *\n * @param {Object} page\n * @returns {boolean} has horizontal ruler\n */\nconst hasHorizontalRuler = R.either(\n  R.hasPath(['props', 'ruler']),\n  R.hasPath(['props', 'horizontalRuler']),\n);\n\nexport default hasHorizontalRuler;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\nimport hasVerticalRuler from '../node/hasVerticalRuler';\nimport hasHorizontalRuler from '../node/hasHorizontalRuler';\nimport {\n  RULER_WIDTH,\n  RULER_COLOR,\n  LINE_COLOR,\n  GRID_COLOR,\n  LINE_WIDTH,\n  RULER_FONT_SIZE,\n  DEFAULT_RULER_STEPS,\n} from '../constants';\n\nconst range = (max, steps) =>\n  Array.from({ length: Math.ceil(max / steps) }, (_, i) => i * steps);\n\nconst matchPercentage = value => {\n  const match = matchPercent(value);\n  return match ? 100 / match.value : null;\n};\n\nconst getVerticalSteps = page => {\n  const value =\n    page.props.horizontalRulerSteps ||\n    page.props.rulerSteps ||\n    DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    const percentage = matchPercentage(value);\n    if (percentage) {\n      const width = page.box.width - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return width / percentage;\n    }\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nconst getHorizontalSteps = page => {\n  const value =\n    page.props.verticalRulerSteps ||\n    page.props.rulerSteps ||\n    DEFAULT_RULER_STEPS;\n\n  if (typeof value === 'string') {\n    const percentage = matchPercentage(value);\n    if (percentage) {\n      const height =\n        page.box.height - (hasVerticalRuler(page) ? RULER_WIDTH : 0);\n      return height / percentage;\n    }\n    throw new Error('Page: Invalid horizontal steps value');\n  }\n\n  return value;\n};\n\nconst renderVerticalRuler = ctx => page => {\n  const width = page.box.width;\n  const height = page.box.height;\n  const offset = hasHorizontalRuler(page) ? RULER_WIDTH : 0;\n  const hRange = range(width, getVerticalSteps(page));\n\n  ctx\n    .rect(offset, 0, width, RULER_WIDTH)\n    .fill(RULER_COLOR)\n    .moveTo(offset, RULER_WIDTH)\n    .lineTo(width, RULER_WIDTH)\n    .stroke(LINE_COLOR);\n\n  hRange.map(step => {\n    ctx\n      .moveTo(offset + step, 0)\n      .lineTo(offset + step, RULER_WIDTH)\n      .stroke(LINE_COLOR)\n      .fillColor('black')\n      .text(`${Math.round(step)}`, offset + step + 1, 1);\n\n    if (step !== 0) {\n      ctx\n        .moveTo(offset + step, RULER_WIDTH)\n        .lineTo(offset + step, height)\n        .stroke(GRID_COLOR);\n    }\n  });\n\n  return page;\n};\n\nconst renderHorizontalRuler = ctx => page => {\n  const width = page.box.width;\n  const height = page.box.height;\n  const offset = hasVerticalRuler(page) ? RULER_WIDTH : 0;\n  const hRange = range(height, getHorizontalSteps(page));\n\n  ctx\n    .rect(0, offset, RULER_WIDTH, height)\n    .fill(RULER_COLOR)\n    .moveTo(RULER_WIDTH, hasHorizontalRuler(page) ? RULER_WIDTH : 0)\n    .lineTo(RULER_WIDTH, height)\n    .stroke(LINE_COLOR);\n\n  hRange.map(step => {\n    ctx\n      .moveTo(0, offset + step)\n      .lineTo(RULER_WIDTH, offset + step)\n      .stroke(LINE_COLOR)\n      .fillColor('black')\n      .text(`${Math.round(step)}`, 1, offset + step + 1);\n\n    if (step !== 0) {\n      ctx\n        .moveTo(RULER_WIDTH, offset + step)\n        .lineTo(width, offset + step)\n        .stroke(GRID_COLOR);\n    }\n  });\n\n  return page;\n};\n\nconst renderRulers = (ctx, page) => {\n  ctx\n    .save()\n    .lineWidth(LINE_WIDTH)\n    .fontSize(RULER_FONT_SIZE)\n    .opacity(1);\n\n  R.compose(\n    R.when(hasVerticalRuler, renderVerticalRuler(ctx)),\n    R.when(hasHorizontalRuler, renderHorizontalRuler(ctx)),\n  )(page);\n\n  ctx.restore();\n\n  return page;\n};\n\nexport default R.curryN(2, renderRulers);\n","import * as R from 'ramda';\n\nconst getDocumentProp = target => (or, prop) =>\n  R.pathOr(or, ['props', prop], target);\n\nconst setPDFMetadata = target => (key, value) => {\n  if (value) target.info[key] = value;\n};\n\n/**\n * Set document instance metadata\n *\n * @param {Object} ctx document instance\n * @param {Object} doc document root\n */\nconst addMetadata = (ctx, doc) => {\n  const getProp = getDocumentProp(doc);\n  const setProp = setPDFMetadata(ctx);\n\n  const title = getProp(null, 'title');\n  const author = getProp(null, 'author');\n  const subject = getProp(null, 'subject');\n  const keywords = getProp(null, 'keywords');\n  const creator = getProp('react-pdf', 'creator');\n  const producer = getProp('react-pdf', 'producer');\n\n  setProp('Title', title);\n  setProp('Author', author);\n  setProp('Subject', subject);\n  setProp('Keywords', keywords);\n  setProp('Creator', creator);\n  setProp('Producer', producer);\n\n  return doc;\n};\n\nexport default R.curryN(2, addMetadata);\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\n\nconst CONTENT_COLOR = '#a1c6e7';\nconst PADDING_COLOR = '#c4deb9';\nconst MARGIN_COLOR = '#f8cca1';\n\nconst shouldDebug = R.pathEq(['props', 'debug'], true);\n\n// TODO: Draw debug boxes using clipping to enhance quality\n\nconst debugContent = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      paddingLeft,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      borderLeftWidth,\n      borderTopWidth,\n      borderRightWidth,\n      borderBottomWidth,\n    } = node.box;\n\n    ctx\n      .fillColor(CONTENT_COLOR)\n      .opacity(0.5)\n      .rect(\n        left + paddingLeft + borderLeftWidth,\n        top + paddingTop + borderTopWidth,\n        width - paddingLeft - paddingRight - borderRightWidth - borderLeftWidth,\n        height -\n          paddingTop -\n          paddingBottom -\n          borderTopWidth -\n          borderBottomWidth,\n      )\n      .fill();\n  });\n\nconst debugPadding = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      paddingLeft,\n      paddingTop,\n      paddingRight,\n      paddingBottom,\n      borderLeftWidth,\n      borderTopWidth,\n      borderRightWidth,\n      borderBottomWidth,\n    } = node.box;\n\n    ctx.fillColor(PADDING_COLOR).opacity(0.5);\n\n    // Padding top\n    ctx\n      .rect(\n        left + paddingLeft + borderLeftWidth,\n        top + borderTopWidth,\n        width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth,\n        paddingTop,\n      )\n      .fill();\n\n    // Padding left\n    ctx\n      .rect(\n        left + borderLeftWidth,\n        top + borderTopWidth,\n        paddingLeft,\n        height - borderTopWidth - borderBottomWidth,\n      )\n      .fill();\n\n    // Padding right\n    ctx\n      .rect(\n        left + width - paddingRight - borderRightWidth,\n        top + borderTopWidth,\n        paddingRight,\n        height - borderTopWidth - borderBottomWidth,\n      )\n      .fill();\n\n    // Padding bottom\n    ctx\n      .rect(\n        left + paddingLeft + borderLeftWidth,\n        top + height - paddingBottom - borderBottomWidth,\n        width - paddingRight - paddingLeft - borderLeftWidth - borderRightWidth,\n        paddingBottom,\n      )\n      .fill();\n  });\n\nconst debugMargin = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      marginLeft,\n      marginTop,\n      marginRight,\n      marginBottom,\n    } = node.box;\n    ctx.fillColor(MARGIN_COLOR).opacity(0.5);\n\n    // Margin top\n    ctx.rect(left, top - marginTop, width, marginTop).fill();\n\n    // Margin left\n    ctx\n      .rect(\n        left - marginLeft,\n        top - marginTop,\n        marginLeft,\n        height + marginTop + marginBottom,\n      )\n      .fill();\n\n    // Margin right\n    ctx\n      .rect(\n        left + width,\n        top - marginTop,\n        marginRight,\n        height + marginTop + marginBottom,\n      )\n      .fill();\n\n    // Margin bottom\n    ctx.rect(left, top + height, width, marginBottom).fill();\n  });\n\nconst debugText = ctx =>\n  R.tap(node => {\n    const {\n      left,\n      top,\n      width,\n      height,\n      marginLeft,\n      marginTop,\n      marginRight,\n      marginBottom,\n    } = node.box;\n\n    const roundedWidth = Math.round(width + marginLeft + marginRight);\n    const roundedHeight = Math.round(height + marginTop + marginBottom);\n\n    ctx\n      .fontSize(4)\n      .opacity(1)\n      .fillColor('black')\n      .text(\n        `${roundedWidth} x ${roundedHeight}`,\n        left - marginLeft,\n        Math.max(top - marginTop - 4, 1),\n      );\n  });\n\nconst debugOrigin = ctx =>\n  R.tap(node => {\n    if (node.origin) {\n      ctx\n        .circle(node.origin.left, node.origin.top, 3)\n        .fill('red')\n        .circle(node.origin.left, node.origin.top, 5)\n        .stroke('red');\n    }\n  });\n\nconst renderDebug = ctx =>\n  R.tap(\n    R.when(\n      shouldDebug,\n      R.compose(\n        restore(ctx),\n        debugOrigin(ctx),\n        debugText(ctx),\n        debugMargin(ctx),\n        debugPadding(ctx),\n        debugContent(ctx),\n        save(ctx),\n      ),\n    ),\n  );\n\nexport default renderDebug;\n","import * as R from 'ramda';\n\n// Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\nconst KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nconst clipBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderRightWidth, borderLeftWidth } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width - c0,\n    top,\n    left + width,\n    top + c0,\n    left + width,\n    top + rtr,\n  );\n\n  // Move down in case the margin exceedes the radius\n  const topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord);\n\n  // Clip inner top right cap\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth,\n    top + borderTopWidth + c2,\n    left + width - borderRightWidth - c1,\n    top + borderTopWidth,\n    left + width - borderRightWidth - innerTopRightRadiusX,\n    top + borderTopWidth,\n  );\n\n  // Clip inner top border edge\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  const topLeftYCoord = top + Math.max(borderTopWidth, rtl);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth + c3,\n    top + borderTopWidth,\n    left + borderLeftWidth,\n    top + borderTopWidth + c4,\n    left + borderLeftWidth,\n    topLeftYCoord,\n  );\n  ctx.lineTo(left, topLeftYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border top cap joins\n  if (borderRightWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderTop = (ctx, layout, style, rtr, rtl) => {\n  const { top, left, width } = layout;\n  const {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderRightWidth,\n    borderLeftWidth,\n  } = style;\n\n  const c0 = rtl * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - c1,\n    top,\n    left + width,\n    top + c1,\n    left + width,\n    top + rtr,\n  );\n\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(\n    Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2,\n  );\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, { space: borderTopWidth * 1.2 });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, { space: borderTopWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderRightWidth, borderBottomWidth } = style;\n\n  // Clip outer right border edge\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer bottom right cap\n  const c0 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c0,\n    left + width - c0,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  // Move left in case the margin exceedes the radius\n  const topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height);\n\n  // Clip inner bottom right cap\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth);\n\n  // Ellipse coefficients inner bottom right cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomRightRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth - c1,\n    top + height - borderBottomWidth,\n    left + width - borderRightWidth,\n    top + height - borderBottomWidth - c2,\n    left + width - borderRightWidth,\n    top + height - Math.max(rbr, borderBottomWidth),\n  );\n\n  // Clip inner right border edge\n  ctx.lineTo(\n    left + width - borderRightWidth,\n    top + Math.max(rtr, borderTopWidth),\n  );\n\n  // Ellipse coefficients inner top right cap\n  const innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  const innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  const c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  const topRightXCoord = left + width - Math.max(rtr, borderRightWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth,\n    top + borderTopWidth + c4,\n    left + width - borderRightWidth - c3,\n    top + borderTopWidth,\n    topRightXCoord,\n    top + borderTopWidth,\n  );\n  ctx.lineTo(topRightXCoord, top);\n\n  // Move right in case the margin exceedes the radius\n  ctx.lineTo(left + width - rtr, top);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rtr * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + width - c5,\n    top,\n    left + width,\n    top + c5,\n    left + width,\n    top + rtr,\n  );\n\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderTopWidth) {\n    const trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderRight = (ctx, layout, style, rtr, rbr) => {\n  const { top, left, width, height } = layout;\n  const {\n    borderRightColor,\n    borderRightStyle,\n    borderRightWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = style;\n\n  const c0 = rbr * (1.0 - KAPPA);\n  const c1 = rtr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(\n    left + width - c1,\n    top,\n    left + width,\n    top + c1,\n    left + width,\n    top + rtr,\n  );\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c0,\n    left + width - c0,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(\n    Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2,\n  );\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, { space: borderRightWidth * 1.2 });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, { space: borderRightWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const { top, left, width, height } = layout;\n  const { borderBottomWidth, borderRightWidth, borderLeftWidth } = style;\n\n  // Clip outer top border edge\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c0 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n\n  // Move up in case the margin exceedes the radius\n  const bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord);\n\n  // Clip inner bottom left cap\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord);\n\n  // Ellipse coefficients inner top right cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner bottom left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth,\n    top + height - borderBottomWidth - c2,\n    left + borderLeftWidth + c1,\n    top + height - borderBottomWidth,\n    left + borderLeftWidth + innerBottomLeftRadiusX,\n    top + height - borderBottomWidth,\n  );\n\n  // Clip inner bottom border edge\n  ctx.lineTo(\n    left + width - Math.max(rbr, borderRightWidth),\n    top + height - borderBottomWidth,\n  );\n\n  // Ellipse coefficients inner top left cap\n  const innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  const innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  const c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  const bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + width - borderRightWidth - c3,\n    top + height - borderBottomWidth,\n    left + width - borderRightWidth,\n    top + height - borderBottomWidth - c4,\n    left + width - borderRightWidth,\n    bottomRightYCoord,\n  );\n  ctx.lineTo(left + width, bottomRightYCoord);\n\n  // Move down in case the margin exceedes the radius\n  ctx.lineTo(left + width, top + height - rbr);\n\n  // Ellipse coefficients outer top left cap\n  const c5 = rbr * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c5,\n    left + width - c5,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border bottom cap joins\n  if (borderRightWidth) {\n    const brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderBottom = (ctx, layout, style, rbl, rbr) => {\n  const { top, left, width, height } = layout;\n  const {\n    borderBottomColor,\n    borderBottomStyle,\n    borderBottomWidth,\n    borderRightWidth,\n    borderLeftWidth,\n  } = style;\n\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rbr * (1.0 - KAPPA);\n\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(\n    left + width,\n    top + height - c1,\n    left + width - c1,\n    top + height,\n    left + width - rbr,\n    top + height,\n  );\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(\n    Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2,\n  );\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, { space: borderBottomWidth * 1.2 });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, { space: borderBottomWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst clipBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const { top, left, width, height } = layout;\n  const { borderTopWidth, borderLeftWidth, borderBottomWidth } = style;\n\n  // Clip outer left border edge\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n\n  // Ellipse coefficients outer top left cap\n  const c0 = rtl * (1.0 - KAPPA);\n\n  // Clip outer top left cap\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n\n  // Move right in case the margin exceedes the radius\n  const topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top);\n\n  // Clip inner top left cap\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth);\n\n  // Ellipse coefficients inner top left cap\n  const innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  const innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  const c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  const c2 = innerTopLeftRadiusY * (1.0 - KAPPA);\n\n  // Clip inner top right cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth + c1,\n    top + borderTopWidth,\n    left + borderLeftWidth,\n    top + borderTopWidth + c2,\n    left + borderLeftWidth,\n    top + Math.max(rtl, borderTopWidth),\n  );\n\n  // Clip inner left border edge\n  ctx.lineTo(\n    left + borderLeftWidth,\n    top + height - Math.max(rbl, borderBottomWidth),\n  );\n\n  // Ellipse coefficients inner bottom left cap\n  const innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  const innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  const c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  const c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  const bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth);\n\n  // Clip inner top left cap\n  ctx.bezierCurveTo(\n    left + borderLeftWidth,\n    top + height - borderBottomWidth - c4,\n    left + borderLeftWidth + c3,\n    top + height - borderBottomWidth,\n    bottomLeftXCoord,\n    top + height - borderBottomWidth,\n  );\n  ctx.lineTo(bottomLeftXCoord, top + height);\n\n  // Move left in case the margin exceedes the radius\n  ctx.lineTo(left + rbl, top + height);\n\n  // Ellipse coefficients outer top right cap\n  const c5 = rbl * (1.0 - KAPPA);\n\n  // Clip outer top right cap\n  ctx.bezierCurveTo(\n    left + c5,\n    top + height,\n    left,\n    top + height - c5,\n    left,\n    top + height - rbl,\n  );\n\n  ctx.closePath();\n  ctx.clip();\n\n  // Clip border right cap joins\n  if (borderBottomWidth) {\n    const trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    const trSlope = -borderTopWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nconst fillBorderLeft = (ctx, layout, style, rbl, rtl) => {\n  const { top, left, height } = layout;\n  const {\n    borderLeftColor,\n    borderLeftStyle,\n    borderLeftWidth,\n    borderTopWidth,\n    borderBottomWidth,\n  } = style;\n\n  const c0 = rbl * (1.0 - KAPPA);\n  const c1 = rtl * (1.0 - KAPPA);\n\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(\n    left + c0,\n    top + height,\n    left,\n    top + height - c0,\n    left,\n    top + height - rbl,\n  );\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(\n    Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2,\n  );\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, { space: borderLeftWidth * 1.2 });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, { space: borderLeftWidth * 1.2 });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nconst shouldRenderBorders = node =>\n  node.box &&\n  (node.box.borderTopWidth ||\n    node.box.borderRightWidth ||\n    node.box.borderBottomWidth ||\n    node.box.borderLeftWidth);\n\nconst renderBorders = (ctx, node) => {\n  if (!shouldRenderBorders(node)) return node;\n\n  const {\n    width,\n    height,\n    borderTopWidth,\n    borderLeftWidth,\n    borderRightWidth,\n    borderBottomWidth,\n  } = node.box;\n\n  const {\n    opacity,\n    borderTopLeftRadius = 0,\n    borderTopRightRadius = 0,\n    borderBottomLeftRadius = 0,\n    borderBottomRightRadius = 0,\n    borderTopColor = 'black',\n    borderTopStyle = 'solid',\n    borderLeftColor = 'black',\n    borderLeftStyle = 'solid',\n    borderRightColor = 'black',\n    borderRightStyle = 'solid',\n    borderBottomColor = 'black',\n    borderBottomStyle = 'solid',\n  } = node.style;\n\n  const style = {\n    borderTopColor,\n    borderTopWidth,\n    borderTopStyle,\n    borderLeftColor,\n    borderLeftWidth,\n    borderLeftStyle,\n    borderRightColor,\n    borderRightWidth,\n    borderRightStyle,\n    borderBottomColor,\n    borderBottomWidth,\n    borderBottomStyle,\n    borderTopLeftRadius,\n    borderTopRightRadius,\n    borderBottomLeftRadius,\n    borderBottomRightRadius,\n  };\n\n  const rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  const rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  const rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  const rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n\n  ctx.save();\n  ctx.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    ctx.save();\n    clipBorderTop(ctx, node.box, style, rtr, rtl);\n    fillBorderTop(ctx, node.box, style, rtr, rtl);\n    ctx.restore();\n  }\n\n  if (borderRightWidth) {\n    ctx.save();\n    clipBorderRight(ctx, node.box, style, rtr, rbr);\n    fillBorderRight(ctx, node.box, style, rtr, rbr);\n    ctx.restore();\n  }\n\n  if (borderBottomWidth) {\n    ctx.save();\n    clipBorderBottom(ctx, node.box, style, rbl, rbr);\n    fillBorderBottom(ctx, node.box, style, rbl, rbr);\n    ctx.restore();\n  }\n\n  if (borderLeftWidth) {\n    ctx.save();\n    clipBorderLeft(ctx, node.box, style, rbl, rtl);\n    fillBorderLeft(ctx, node.box, style, rbl, rtl);\n    ctx.restore();\n  }\n\n  ctx.restore();\n\n  return node;\n};\n\nexport default R.curryN(2, renderBorders);\n","import * as R from 'ramda';\n\nconst setDestination = ctx =>\n  R.tap(node => {\n    if (node.props.id) {\n      ctx.addNamedDestination(node.props.id, 'XYZ', null, node.box.top, null);\n    }\n  });\n\nexport default setDestination;\n","import * as R from 'ramda';\n\nimport save from './save';\nimport restore from './restore';\nimport clipNode from './clipNode';\n\nconst drawBackground = ctx => node => {\n  if (node.box && node.style.backgroundColor) {\n    const { top, left, width, height } = node.box;\n\n    ctx\n      .fillOpacity(node.style.opacity || 1)\n      .fillColor(node.style.backgroundColor)\n      .rect(left, top, width, height)\n      .fill();\n  }\n\n  return node;\n};\n\nconst shouldRenderBackground = R.hasPath(['style', 'backgroundColor']);\n\nconst renderBackground = (ctx, node) => {\n  R.when(\n    shouldRenderBackground,\n    R.compose(\n      restore(ctx),\n      drawBackground(ctx),\n      clipNode(ctx),\n      save(ctx),\n    ),\n  )(node);\n\n  return node;\n};\n\nexport default R.curryN(2, renderBackground);\n","import * as R from 'ramda';\n\nimport Font from '../font';\nimport save from './save';\nimport setLink from './setLink';\nimport restore from './restore';\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\nimport isPage from '../node/isPage';\nimport isLink from '../node/isLink';\nimport isNote from '../node/isNote';\nimport isImage from '../node/isImage';\nimport isCanvas from '../node/isCanvas';\nimport renderSvg from './renderSvg';\nimport renderText from './renderText';\nimport renderPage from './renderPage';\nimport renderNote from './renderNote';\nimport renderImage from './renderImage';\nimport renderCanvas from './renderCanvas';\nimport renderRulers from './renderRulers';\nimport addMetadata from './addMetadata';\nimport renderDebug from './renderDebug';\nimport renderBorders from './renderBorders';\nimport setDestination from './setDestination';\nimport renderBackground from './renderBackground';\nimport applyTransformations from './applyTransformations';\n\nconst shouldRenderChildren = v => !isText(v) && !isSvg(v);\n\nconst renderChildren = ctx => node => {\n  save(ctx, node);\n\n  ctx.translate(node.box.left, node.box.top);\n\n  R.compose(\n    R.forEach(renderNode(ctx)),\n    R.pathOr([], ['children']),\n  )(node);\n\n  restore(ctx, node);\n\n  return node;\n};\n\nconst renderNode = ctx => node =>\n  R.compose(\n    restore(ctx),\n    renderDebug(ctx),\n    setDestination(ctx),\n    R.when(shouldRenderChildren, renderChildren(ctx)),\n    R.when(R.either(isText, isLink), setLink(ctx)),\n    R.cond([\n      [isText, renderText(ctx)],\n      [isNote, renderNote(ctx)],\n      [isImage, renderImage(ctx)],\n      [isCanvas, renderCanvas(ctx)],\n      [isSvg, renderSvg(ctx)],\n      [R.T, R.identity],\n    ]),\n    renderBorders(ctx),\n    renderBackground(ctx),\n    applyTransformations(ctx),\n    save(ctx),\n    R.when(isPage, renderPage(ctx)),\n  )(node);\n\nconst renderDocument = ctx =>\n  R.compose(\n    R.forEach(\n      R.compose(\n        renderRulers(ctx),\n        renderNode(ctx),\n      ),\n    ),\n    R.pathOr([], ['children']),\n  );\n\nconst render = (ctx, doc) => {\n  addMetadata(ctx)(doc);\n  renderDocument(ctx)(doc);\n\n  ctx.end();\n  Font.reset(); // TODO: move outside\n\n  return ctx;\n};\n\nexport default render;\n","/**\n * Capitalize first letter of each word\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\nconst capitalize = value => {\n  if (!value) return value;\n  return value.replace(/(^|\\s)\\S/g, l => l.toUpperCase());\n};\n\nexport default capitalize;\n","import * as R from 'ramda';\n\n/**\n * Capitalize first letter of string\n *\n * @param {String} string\n * @returns {String} capitalized string\n */\nconst upperFirst = R.ifElse(\n  R.isNil,\n  R.identity,\n  R.compose(\n    R.join(''),\n    R.juxt([\n      R.compose(\n        R.toUpper,\n        R.head,\n      ),\n      R.tail,\n    ]),\n  ),\n);\n\nexport default R.memoizeWith(R.identity, upperFirst);\n","import capitalize from '../utils/capitalize';\nimport upperFirst from '../utils/upperFirst';\n\n/**\n * Apply transformation to text string\n *\n * @param {String} text\n * @param {String} transformation type\n * @returns {String} transformed text\n */\nconst transformText = (text, transformation) => {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n    case 'lowercase':\n      return text.toLowerCase();\n    case 'capitalize':\n      return capitalize(text);\n    case 'upperfirst':\n      return upperFirst(text);\n    default:\n      return text;\n  }\n};\n\nexport default transformText;\n","import { PDFFont } from '@react-pdf/pdfkit';\n\nclass StandardFont {\n  constructor(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n\n  layout(str) {\n    const [encoded, positions] = this.src.encode(str);\n\n    return {\n      positions,\n      stringIndices: positions.map((_, i) => i),\n      glyphs: encoded.map((g, i) => {\n        const glyph = this.getGlyph(parseInt(g, 16));\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      }),\n    };\n  }\n\n  glyphForCodePoint(codePoint) {\n    const glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  }\n\n  getGlyph(id) {\n    return {\n      id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id),\n    };\n  }\n\n  hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  }\n\n  // Based on empirical observation\n  get ascent() {\n    return 900;\n  }\n\n  // Based on empirical observation\n  get descent() {\n    switch (this.name) {\n      case 'Times-Roman':\n      case 'Times-Bold':\n      case 'Times-Italic':\n        return -220;\n      case 'Courier':\n      case 'Courier-Bold':\n      case 'Courier-Oblique':\n        return -230;\n      default:\n        return -200;\n    }\n  }\n\n  get lineGap() {\n    return 0;\n  }\n\n  get unitsPerEm() {\n    return 1000;\n  }\n}\n\nexport default StandardFont;\n","import * as R from 'ramda';\n\nimport StandardFont from './standardFont';\n\nconst fontCache = {};\n\nconst IGNORED_CODE_POINTS = [173];\n\nconst getFontSize = R.pathOr(12, ['attributes', 'fontSize']);\n\nconst getOrCreateFont = name => {\n  if (fontCache[name]) return fontCache[name];\n\n  const font = new StandardFont(name);\n  fontCache[name] = font;\n\n  return font;\n};\n\nconst getFallbackFont = () => getOrCreateFont('Helvetica');\n\nconst shouldFallbackToFont = (codePoint, font) =>\n  !IGNORED_CODE_POINTS.includes(codePoint) &&\n  !font.hasGlyphForCodePoint(codePoint) &&\n  getFallbackFont().hasGlyphForCodePoint(codePoint);\n\nconst fontSubstitution = () => ({ string, runs }) => {\n  let lastFont = null;\n  let lastIndex = 0;\n  let index = 0;\n\n  const res = [];\n\n  for (const run of runs) {\n    const fontSize = getFontSize(run);\n    const defaultFont =\n      typeof run.attributes.font === 'string'\n        ? getOrCreateFont(run.attributes.font)\n        : run.attributes.font;\n\n    if (string.length === 0) {\n      res.push({ start: 0, end: 0, attributes: { font: defaultFont } });\n      break;\n    }\n\n    for (const char of string.slice(run.start, run.end)) {\n      const codePoint = char.codePointAt();\n      const shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n      const font = shouldFallback ? getFallbackFont() : defaultFont;\n\n      // If the default font does not have a glyph and the fallback font does, we use it\n      if (font !== lastFont) {\n        if (lastFont) {\n          res.push({\n            start: lastIndex,\n            end: index,\n            attributes: {\n              font: lastFont,\n              scale: lastFont ? fontSize / lastFont.unitsPerEm : 0,\n            },\n          });\n        }\n\n        lastFont = font;\n        lastIndex = index;\n      }\n\n      index += char.length;\n    }\n  }\n\n  if (lastIndex < string.length) {\n    const fontSize = getFontSize(R.last(runs));\n\n    res.push({\n      start: lastIndex,\n      end: string.length,\n      attributes: {\n        font: lastFont,\n        scale: lastFont ? fontSize / lastFont.unitsPerEm : 0,\n      },\n    });\n  }\n\n  return { string, runs: res };\n};\n\nexport default fontSubstitution;\n","import * as R from 'ramda';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\nimport AttributedString from '@react-pdf/textkit/attributedString';\n\nimport Font from '../font';\nimport transformText from '../text/transformText';\nimport isTextInstance from '../node/isTextInstance';\nimport fontSubstitution from '../text/fontSubstitution';\n\nconst engines = {\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution,\n};\n\nconst engine = layoutEngine(engines);\n\nconst layoutOptions = {\n  hyphenationCallback: Font.getHyphenationCallback(),\n  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n};\n\nconst getFragments = instance => {\n  if (!instance) return [{ string: '' }];\n\n  const fragments = [];\n\n  const {\n    fill = 'black',\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    opacity,\n  } = instance.props;\n\n  const obj = Font.getFont({ fontFamily, fontWeight, fontStyle });\n  const font = obj ? obj.data : fontFamily;\n\n  const attributes = {\n    font,\n    opacity,\n    fontSize,\n    color: fill,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || fill,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || fill,\n  };\n\n  instance.children.forEach(child => {\n    if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes,\n      });\n    } else {\n      if (child) {\n        fragments.push(...getFragments(child));\n      }\n    }\n  });\n\n  return fragments;\n};\n\nconst getAttributedString = instance =>\n  AttributedString.fromFragments(getFragments(instance));\n\nconst AlmostInfinity = 999999999999;\n\nconst layoutTspan = node => {\n  const attributedString = getAttributedString(node);\n\n  const x = R.pathOr(0, ['props', 'x'], node);\n  const y = R.pathOr(0, ['props', 'y'], node);\n\n  const container = { x, y, width: AlmostInfinity, height: AlmostInfinity };\n\n  const lines = R.compose(\n    R.reduce(R.concat, []),\n    engine,\n  )(attributedString, container, layoutOptions);\n\n  return R.assoc('lines', lines, node);\n};\n\nconst layoutText = R.evolve({\n  children: R.map(layoutTspan),\n});\n\nexport default layoutText;\n","import * as R from 'ramda';\n\nimport { DEFS } from '../constants';\n\n/**\n * Checks if node is svg defs\n *\n * @param {Object} node\n * @returns {Boolean} is node svg defs?\n */\nconst isDefs = R.propEq('type', DEFS);\n\nexport default isDefs;\n","import * as R from 'ramda';\n\nimport isDefs from '../node/isDefs';\n\nconst getChildren = R.propOr([], 'children');\n\nconst getId = R.path(['props', 'id']);\n\nconst getDefs = R.compose(\n  R.map(R.prop(0)),\n  R.groupBy(getId),\n  getChildren,\n  R.defaultTo({}),\n  R.find(isDefs),\n  getChildren,\n);\n\nexport default getDefs;\n","import * as R from 'ramda';\n\nimport getDefs from './getDefs';\nimport isDefs from '../node/isDefs';\n\nconst isNotDefs = R.complement(isDefs);\n\nconst detachDefs = R.evolve({\n  children: R.filter(isNotDefs),\n});\n\nconst URL_REGEX = /url\\(['\"]?#([^'\"]+)['\"]?\\)/;\n\nconst replaceDef = defs =>\n  R.compose(\n    R.when(\n      R.test(URL_REGEX),\n      R.compose(\n        R.prop(R.__, defs),\n        R.prop(1),\n        R.match(URL_REGEX),\n      ),\n    ),\n    R.defaultTo(''),\n  );\n\nconst parseNodeDefs = defs => node =>\n  R.compose(\n    R.evolve({\n      props: R.evolve({\n        fill: replaceDef(defs),\n        clipPath: replaceDef(defs),\n      }),\n    }),\n    R.evolve({ children: R.map(parseNodeDefs(defs)) }),\n  )(node);\n\nconst parseDefs = root => {\n  const defs = getDefs(root);\n  return R.evolve({ children: R.map(parseNodeDefs(defs)) }, root);\n};\n\nconst replaceDefs = R.compose(\n  detachDefs,\n  parseDefs,\n);\n\nexport default replaceDefs;\n","const parseViewbox = value => {\n  if (!value) return null;\n  const values = value.split(/[,\\s]+/).map(parseFloat);\n  if (values.length !== 4) return null;\n  return { minX: values[0], minY: values[1], maxX: values[2], maxY: values[3] };\n};\n\nexport default parseViewbox;\n","import parseViewBox from './parseViewbox';\n\nconst getContainer = node => {\n  const viewbox = parseViewBox(node.props.viewBox);\n\n  if (viewbox) {\n    return { width: viewbox.maxX, height: viewbox.maxY };\n  }\n\n  if (node.props.width && node.props.height) {\n    return {\n      width: parseFloat(node.props.width),\n      height: parseFloat(node.props.height),\n    };\n  }\n\n  return { width: 0, height: 0 };\n};\n\nexport default getContainer;\n","import * as R from 'ramda';\n\nimport { SVG_INHERITED_PROPS } from '../constants';\n\nconst getInheritProps = R.compose(\n  R.pick(SVG_INHERITED_PROPS),\n  R.propOr({}, 'props'),\n);\n\nconst inheritProps = node => {\n  const props = getInheritProps(node);\n\n  return R.evolve({\n    children: R.map(\n      R.compose(\n        inheritProps,\n        R.evolve({\n          props: R.merge(props),\n        }),\n      ),\n    ),\n  })(node);\n};\n\nexport default inheritProps;\n","const parseAspectRatio = value => {\n  const match = value\n    .replace(/[\\s\\r\\t\\n]+/gm, ' ')\n    .replace(/^defer\\s/, '')\n    .split(' ');\n\n  const align = match[0] || 'xMidYMid';\n  const meetOrSlice = match[1] || 'meet';\n\n  return { align, meetOrSlice };\n};\n\nexport default parseAspectRatio;\n","import * as R from 'ramda';\nimport colorString from 'color-string';\nimport hlsToHex from 'hsl-to-hex';\n\nconst isRgb = R.test(/rgb/g);\nconst isRgba = R.test(/rgba/g);\nconst isHsl = R.test(/hsl/g);\nconst isHsla = R.test(/hsla/g);\n\n/**\n * Transform rgb color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst parseRgb = R.compose(\n  colorString.to.hex,\n  colorString.get.rgb,\n);\n\n/**\n * Transform Hsl color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst parseHsl = R.compose(\n  R.toUpper,\n  R.apply(hlsToHex),\n  R.map(Math.round),\n  colorString.get.hsl,\n);\n\n/**\n * Transform given color to hexa\n *\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nexport const transformColor = value =>\n  R.cond([\n    [isRgba, parseRgb],\n    [isRgb, parseRgb],\n    [isHsla, parseHsl],\n    [isHsl, parseHsl],\n    [R.T, R.always(value)],\n  ])(value);\n\n/**\n * Transform rbg and cmyk colors to hexa\n *\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\nconst transformColors = styles => R.map(transformColor, styles);\n\nexport default transformColors;\n","import * as R from 'ramda';\n\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\n\nimport layoutText from '../svg/layoutText';\nimport replaceDefs from '../svg/replaceDefs';\nimport getContainer from '../svg/getContainer';\nimport parseViewbox from '../svg/parseViewbox';\nimport inheritProps from '../svg/inheritProps';\nimport matchPercent from '../utils/matchPercent';\nimport isTextInstance from '../node/isTextInstance';\nimport parseAspectRatio from '../svg/parseAspectRatio';\nimport { transformColor } from '../stylesheet/transformColors';\n\nconst STYLE_PROPS = [\n  'width',\n  'height',\n  'color',\n  'stroke',\n  'strokeWidth',\n  'opacity',\n  'fillOpacity',\n  'strokeOpacity',\n  'fill',\n  'fillRule',\n  'clipPath',\n  'offset',\n  'transform',\n  'strokeLinejoin',\n  'strokeLinecap',\n  'strokeDasharray',\n];\n\nconst VERTICAL_PROPS = ['y', 'y1', 'y2', 'height', 'cy', 'ry'];\nconst HORIZONTAL_PROPS = ['x', 'x1', 'x2', 'width', 'cx', 'rx'];\n\nconst transformPercent = container =>\n  R.mapObjIndexed((value, key) => {\n    const match = matchPercent(value);\n\n    if (match && VERTICAL_PROPS.includes(key)) {\n      return match.percent * container.height;\n    }\n\n    if (match && HORIZONTAL_PROPS.includes(key)) {\n      return match.percent * container.width;\n    }\n\n    return value;\n  });\n\nconst parsePercent = value => {\n  const match = matchPercent(value);\n  return match ? match.percent : parseFloat(value);\n};\n\nconst parseProps = container =>\n  R.compose(\n    R.evolve({\n      props: R.o(\n        R.evolve({\n          x: parseFloat,\n          x1: parseFloat,\n          x2: parseFloat,\n          y: parseFloat,\n          y1: parseFloat,\n          y2: parseFloat,\n          r: parseFloat,\n          rx: parseFloat,\n          ry: parseFloat,\n          cx: parseFloat,\n          cy: parseFloat,\n          width: parseFloat,\n          height: parseFloat,\n          offset: parsePercent,\n          fill: transformColor,\n          opacity: parsePercent,\n          stroke: transformColor,\n          stopOpacity: parsePercent,\n          stopColor: transformColor,\n        }),\n        transformPercent(container),\n      ),\n    }),\n  );\n\nconst mergeStyles = node => {\n  const style = R.propOr({}, 'style', node);\n  return R.evolve({ props: R.merge(style) }, node);\n};\n\nconst removeNoneValues = R.evolve({\n  props: R.map(R.when(R.equals('none'), R.always(null))),\n});\n\nconst pickStyleProps = node => {\n  const styleProps = R.o(R.pick(STYLE_PROPS), R.propOr({}, 'props'))(node);\n  return R.evolve({ style: R.merge(styleProps) }, node);\n};\n\nconst parseSvgProps = R.evolve({\n  props: R.evolve({\n    width: parseFloat,\n    height: parseFloat,\n    viewBox: parseViewbox,\n    preserveAspectRatio: parseAspectRatio,\n  }),\n});\n\nconst wrapBetweenTspan = node => ({\n  type: 'TSPAN',\n  props: {},\n  children: [node],\n});\n\nconst addMissingTspan = R.when(\n  isText,\n  R.evolve({\n    children: R.map(R.when(isTextInstance, wrapBetweenTspan)),\n  }),\n);\n\nconst resolveSvgNode = container =>\n  R.compose(\n    parseProps(container),\n    addMissingTspan,\n    removeNoneValues,\n    mergeStyles,\n  );\n\nconst resolveChildren = container => node =>\n  R.evolve({\n    children: R.map(\n      R.compose(\n        resolveChildren(container),\n        resolveSvgNode(container),\n      ),\n    ),\n  })(node);\n\nconst parseText = node =>\n  R.ifElse(\n    isText,\n    layoutText,\n    R.evolve({\n      children: R.map(parseText),\n    }),\n  )(node);\n\nconst resolveSvgRoot = node => {\n  const container = getContainer(node);\n\n  return R.compose(\n    replaceDefs,\n    parseText,\n    parseSvgProps,\n    pickStyleProps,\n    inheritProps,\n    resolveChildren(container),\n  )(node);\n};\n\nconst resolveSvg = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveSvg) }),\n    R.when(isSvg, resolveSvgRoot),\n  )(node);\n\nexport default resolveSvg;\n","import * as R from 'ramda';\nimport { SVG, DOCUMENT } from '../constants';\n\nconst getZIndex = R.path(['style', 'zIndex']);\n\nconst isType = R.propEq('type');\n\nconst shouldNotSort = R.anyPass([isType(DOCUMENT), isType(SVG)]);\n\nconst sortZIndex = (a, b) => {\n  const za = getZIndex(a);\n  const zb = getZIndex(b);\n\n  if (!za && !zb) return 0;\n  if (!za) return 1;\n  if (!zb) return -1;\n\n  return zb - za;\n};\n\n/**\n * Sort children by zIndex value\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolveZIndex = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveZIndex) }),\n    R.unless(shouldNotSort, R.evolve({ children: R.sort(sortZIndex) })),\n  )(node);\n\nexport default resolveZIndex;\n","import * as R from 'ramda';\n\nimport { RULER_WIDTH } from '../constants';\nimport hasVerticalRuler from '../node/hasVerticalRuler';\nimport hasHorizontalRuler from '../node/hasHorizontalRuler';\n\n/**\n * Adjust page size given ruler props\n *\n * @param {Object} page\n * @returns {boolean} page with size altered by ruler props\n */\nconst adjustPageSize = R.compose(\n  R.when(\n    hasVerticalRuler,\n    R.evolve({\n      box: { height: R.add(RULER_WIDTH) },\n      children: R.map(\n        R.evolve({\n          box: { top: R.add(RULER_WIDTH) },\n        }),\n      ),\n    }),\n  ),\n  R.when(\n    hasHorizontalRuler,\n    R.evolve({\n      box: { width: R.add(RULER_WIDTH) },\n      children: R.map(\n        R.evolve({\n          box: { left: R.add(RULER_WIDTH) },\n        }),\n      ),\n    }),\n  ),\n);\n\n/**\n * Adjust pages size given ruler props\n *\n * @param {Object} root\n * @returns {boolean} root with pages size altered by ruler props\n */\nconst resolveRulers = R.evolve({\n  children: R.map(adjustPageSize),\n});\n\nexport default resolveRulers;\n","import PNG from '@react-pdf/png-js';\n\nPNG.isValid = function(data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n};\n\nexport default PNG;\n","// Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\nconst MARKERS = [\n  0xffc0,\n  0xffc1,\n  0xffc2,\n  0xffc3,\n  0xffc5,\n  0xffc6,\n  0xffc7,\n  0xffc8,\n  0xffc9,\n  0xffca,\n  0xffcb,\n  0xffcc,\n  0xffcd,\n  0xffce,\n  0xffcf,\n];\n\nclass JPEG {\n  data = null;\n  width = null;\n  height = null;\n\n  constructor(data) {\n    this.data = data;\n\n    if (data.readUInt16BE(0) !== 0xffd8) {\n      throw new Error('SOI not found in JPEG');\n    }\n\n    let marker;\n    let pos = 2;\n\n    while (pos < data.length) {\n      marker = data.readUInt16BE(pos);\n      pos += 2;\n      if (MARKERS.includes(marker)) {\n        break;\n      }\n      pos += data.readUInt16BE(pos);\n    }\n\n    if (!MARKERS.includes(marker)) {\n      throw new Error('Invalid JPEG.');\n    }\n\n    pos += 3;\n    this.height = data.readUInt16BE(pos);\n\n    pos += 2;\n    this.width = data.readUInt16BE(pos);\n  }\n}\n\nJPEG.isValid = function(data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  let marker;\n  let pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nexport default JPEG;\n","const createCache = ({ limit = 100 } = {}) => {\n  let cache = {};\n  let keys = [];\n\n  return {\n    get: key => cache[key],\n    set: (key, value) => {\n      keys.push(key);\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n      cache[key] = value;\n    },\n    reset: () => {\n      cache = {};\n      keys = [];\n    },\n    length: () => keys.length,\n  };\n};\n\nexport default createCache;\n","import fs from 'fs';\nimport url from 'url';\nimport path from 'path';\nimport fetch from 'cross-fetch';\n\nimport PNG from '../utils/png';\nimport JPEG from '../utils/jpeg';\nimport createCache from '../utils/cache';\n\nexport const IMAGE_CACHE = createCache({ limit: 30 });\n\nexport const getAbsoluteLocalPath = src => {\n  if (BROWSER) {\n    throw new Error('Cannot check local paths in client-side environment');\n  }\n\n  const { protocol, auth, host, port, hostname, path: pathname } = url.parse(\n    src,\n  );\n  const absolutePath = path.resolve(pathname);\n  if ((protocol && protocol !== 'file:') || auth || host || port || hostname) {\n    return undefined;\n  }\n  return absolutePath;\n};\n\nconst fetchLocalFile = src =>\n  new Promise((resolve, reject) => {\n    try {\n      if (BROWSER) {\n        return reject(new Error('Cannot fetch local file in this environemnt'));\n      }\n      const absolutePath = getAbsoluteLocalPath(src);\n      if (!absolutePath) {\n        return reject(new Error(`Cannot fetch non-local path: ${src}`));\n      }\n      fs.readFile(absolutePath, (err, data) =>\n        err ? reject(err) : resolve(data),\n      );\n    } catch (err) {\n      reject(err);\n    }\n  });\n\nconst fetchRemoteFile = async (uri, options) => {\n  const response = await fetch(uri, options);\n\n  const buffer = await (response.buffer\n    ? response.buffer()\n    : response.arrayBuffer());\n\n  return buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer);\n};\n\nconst isValidFormat = format => {\n  const lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nconst guessFormat = buffer => {\n  let format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nconst isCompatibleBase64 = ({ uri }) =>\n  /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n    case 'png':\n      return new PNG(body);\n    default:\n      return null;\n  }\n}\n\nconst resolveBase64Image = ({ uri }) => {\n  const match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  const format = match[1];\n  const data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(`Base64 image invalid format: ${format}`);\n  }\n\n  return new Promise(resolve => {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nconst resolveImageFromData = src => {\n  if (src.data && src.format) {\n    return new Promise(resolve => resolve(getImage(src.data, src.format)));\n  }\n\n  throw new Error(`Invalid data given for local file: ${JSON.stringify(src)}`);\n};\n\nconst resolveBufferImage = buffer => {\n  const format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(resolve => resolve(getImage(buffer, format)));\n  }\n};\n\nconst getImageFormat = body => {\n  const isPng =\n    body[0] === 137 &&\n    body[1] === 80 &&\n    body[2] === 78 &&\n    body[3] === 71 &&\n    body[4] === 13 &&\n    body[5] === 10 &&\n    body[6] === 26 &&\n    body[7] === 10;\n\n  const isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n\n  let extension = '';\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nconst resolveImageFromUrl = async src => {\n  const { uri, body, headers, method = 'GET' } = src;\n\n  const data =\n    !BROWSER && getAbsoluteLocalPath(uri)\n      ? await fetchLocalFile(uri)\n      : await fetchRemoteFile(uri, { body, headers, method });\n\n  const extension = getImageFormat(data);\n\n  return getImage(data, extension);\n};\n\nconst resolveImage = (src, { cache = true } = {}) => {\n  const cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  let image;\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nexport default resolveImage;\n","import * as R from 'ramda';\n\nconst isNotNil = R.complement(R.isNil);\n\n/**\n * Takes a list of predicates and returns the first predicate result that returns true for a given list of arguments\n *\n * @param  {...any} predicates\n * @param  {any} value\n */\nconst firstPass = (...fns) => value => {\n  let res;\n\n  for (const fn of fns) {\n    res = fn(value);\n    if (isNotNil(res)) return res;\n  }\n\n  return res;\n};\n\nexport default firstPass;\n","import * as R from 'ramda';\n\nimport firstPass from '../utils/firstPass';\n\n/**\n * Get image source\n *\n * @param {Object} image node\n * @returns {String} image src\n */\nconst getSource = R.compose(\n  R.when(R.is(String), src => ({ uri: src })),\n  firstPass(\n    R.path(['props', 'src']),\n    R.path(['props', 'source']),\n    R.path(['props', 'href']),\n  ),\n);\n\nexport default getSource;\n","import resolveImage from './resolveImage';\nimport getSource from './getSource';\nimport warning from '../utils/warning';\n\n/**\n * Resolves async src if passed\n *\n * @param {string | Function} src\n * @returns {object} resolved src\n */\nconst resolveSrc = async src =>\n  typeof src === 'function' ? { uri: await src() } : src;\n\n/**\n * Fetches image and append data to node\n * Ideally this fn should be immutable.\n *\n * @param {Object} node\n */\nconst fetchImage = async node => {\n  const src = getSource(node);\n  const { cache } = node.props;\n\n  if (!src) {\n    warning(false, 'Image should receive either a \"src\" or \"source\" prop');\n    return;\n  }\n\n  try {\n    const source = await resolveSrc(src);\n    node.image = await resolveImage(source, { cache });\n  } catch (e) {\n    node.image = { width: 0, height: 0 };\n    console.warn(e.message);\n  }\n};\n\nexport default fetchImage;\n","/* eslint-disable no-cond-assign */\nimport emojiRegex from 'emoji-regex';\n\nimport Font from '../font';\nimport resolveImage from '../image/resolveImage';\n\n// Caches emoji images data\nconst emojis = {};\nconst regex = emojiRegex();\n\nconst reflect = promise => (...args) => promise(...args).then(v => v, e => e);\n\n// Returns a function to be able to mock resolveImage.\nconst makeFetchEmojiImage = () => reflect(resolveImage);\n\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\nconst _removeNoColor = x => x !== '️';\n\nconst getCodePoints = string =>\n  Array.from(string)\n    .filter(_removeNoColor)\n    .map(char => char.codePointAt(0).toString(16))\n    .join('-');\n\nconst buildEmojiUrl = emoji => {\n  const { url, format } = Font.getEmojiSource();\n  return `${url}${getCodePoints(emoji)}.${format}`;\n};\n\nexport const fetchEmojis = string => {\n  const emojiSource = Font.getEmojiSource();\n\n  if (!emojiSource || !emojiSource.url) return [];\n\n  const promises = [];\n\n  let match;\n  while ((match = regex.exec(string))) {\n    const emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      const emojiUrl = buildEmojiUrl(emoji);\n\n      emojis[emoji] = { loading: true };\n      const fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(\n        fetchEmojiImage({ uri: emojiUrl }).then(image => {\n          emojis[emoji].loading = false;\n          emojis[emoji].data = image.data;\n        }),\n      );\n    }\n  }\n\n  return promises;\n};\n\nexport const embedEmojis = fragments => {\n  const result = [];\n\n  for (let i = 0; i < fragments.length; i++) {\n    const fragment = fragments[i];\n\n    let match;\n    let lastIndex = 0;\n\n    while ((match = regex.exec(fragment.string))) {\n      const index = match.index;\n      const emoji = match[0];\n      const emojiSize = fragment.attributes.fontSize;\n      const chunk = fragment.string.slice(lastIndex, index + match[0].length);\n\n      // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: {\n            ...fragment.attributes,\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data,\n            },\n          },\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes,\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes,\n      });\n    }\n  }\n\n  return result;\n};\n","import * as R from 'ramda';\n\nimport Font from '../font';\nimport isImage from '../node/isImage';\nimport fetchImage from '../image/fetchImage';\nimport { fetchEmojis } from '../text/emoji';\n\n/**\n * Get all asset promises that need to be resolved\n *\n * @param {Object} root node\n * @returns {Array} asset promises\n */\nconst fetchAssets = node => {\n  const promises = [];\n  const listToExplore = node.children.slice(0);\n\n  while (listToExplore.length > 0) {\n    const node = listToExplore.shift();\n\n    if (isImage(node)) {\n      promises.push(fetchImage(node));\n    }\n\n    if (node.style && node.style.fontFamily) {\n      promises.push(Font.load(node.style));\n    }\n\n    if (typeof node === 'string') {\n      promises.push(...fetchEmojis(node));\n    }\n\n    if (typeof node.value === 'string') {\n      promises.push(...fetchEmojis(node.value));\n    }\n\n    if (node.children) {\n      node.children.forEach(childNode => {\n        listToExplore.push(childNode);\n      });\n    }\n  }\n\n  return promises;\n};\n\n/**\n * Fetch image, font and emoji assets in parallel.\n * Layout process will not be resumed until promise resolves.\n *\n * @param {Object} root node\n * @returns {Object} root node\n */\nconst resolveAssets = node =>\n  R.compose(\n    R.then(R.always(node)),\n    p => Promise.all(p),\n    fetchAssets,\n  )(node);\n\nexport default resolveAssets;\n","import * as R from 'ramda';\n\n/**\n * Checks if value is not an array\n *\n * @param {any} value\n * @returns {Boolean} isn't value an array\n */\nconst isNotArray = R.complement(R.is(Array));\n\n/**\n * Casts value to array\n *\n * @param {any} value\n * @returns {Array} casted value\n */\nconst castArray = R.when(isNotArray, v => [v]);\n\nexport default castArray;\n","import * as R from 'ramda';\n\nimport castArray from '../utils/castArray';\n\n/**\n * Remove nil values from array\n *\n * @param {Array} array\n * @returns {Array} array without nils\n */\nconst compact = R.filter(Boolean);\n\n/**\n * Checks if value is array\n *\n * @param {any} value\n * @returns {Boolean} is value an array\n */\nconst isArray = R.is(Array);\n\n/**\n * Merges style objects array\n *\n * @param {Array} style objects array\n * @returns {Object} merged style object\n */\nconst mergeStyles = styles =>\n  styles.reduce((acc, style) => {\n    const s = isArray(style) ? flatten(style) : style;\n\n    Object.keys(s).forEach(key => {\n      if (s[key] !== null && s[key] !== undefined) {\n        acc[key] = s[key];\n      }\n    });\n\n    return acc;\n  }, {});\n\n/**\n * Flattens an array of style objects, into one aggregated style object.\n *\n * @param {Array} style objects array\n * @returns {Object} flatted style object\n */\nconst flatten = R.compose(\n  mergeStyles,\n  compact,\n  castArray,\n);\n\nexport default flatten;\n","const hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Expand rules\n */\nconst styleShorthands = {\n  margin: {\n    marginTop: true,\n    marginRight: true,\n    marginBottom: true,\n    marginLeft: true,\n  },\n  marginHorizontal: {\n    marginLeft: true,\n    marginRight: true,\n  },\n  marginVertical: {\n    marginTop: true,\n    marginBottom: true,\n  },\n  padding: {\n    paddingTop: true,\n    paddingRight: true,\n    paddingBottom: true,\n    paddingLeft: true,\n  },\n  paddingHorizontal: {\n    paddingLeft: true,\n    paddingRight: true,\n  },\n  paddingVertical: {\n    paddingTop: true,\n    paddingBottom: true,\n  },\n  border: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true,\n  },\n  borderTop: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n  },\n  borderRight: {\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n  },\n  borderBottom: {\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n  },\n  borderLeft: {\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true,\n  },\n  borderColor: {\n    borderTopColor: true,\n    borderRightColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true,\n  },\n  borderRadius: {\n    borderTopLeftRadius: true,\n    borderTopRightRadius: true,\n    borderBottomRightRadius: true,\n    borderBottomLeftRadius: true,\n  },\n  borderStyle: {\n    borderTopStyle: true,\n    borderRightStyle: true,\n    borderBottomStyle: true,\n    borderLeftStyle: true,\n  },\n  borderWidth: {\n    borderTopWidth: true,\n    borderRightWidth: true,\n    borderBottomWidth: true,\n    borderLeftWidth: true,\n  },\n  objectPosition: {\n    objectPositionX: true,\n    objectPositionY: true,\n  },\n  transformOrigin: {\n    transformOriginX: true,\n    transformOriginY: true,\n  },\n  flex: {\n    flexGrow: true,\n    flexShrink: true,\n    flexBasis: true,\n  },\n};\n\n/**\n * Expand the shorthand properties to isolate every declaration from the others.\n *\n * @param { Object } style object\n * @returns { Object } expanded style object\n */\nconst expandStyles = style => {\n  if (!style) return style;\n\n  const propsArray = Object.keys(style);\n  const resolvedStyle = {};\n\n  for (let i = 0; i < propsArray.length; i++) {\n    const key = propsArray[i];\n    const value = style[key];\n\n    if (styleShorthands[key]) {\n      const expandedProps = styleShorthands[key];\n\n      for (const propName in expandedProps) {\n        if (hasOwnProperty.call(expandedProps, propName)) {\n          resolvedStyle[propName] = value;\n        }\n      }\n    } else {\n      resolvedStyle[key] = value;\n    }\n  }\n\n  return resolvedStyle;\n};\n\nexport default expandStyles;\n","import * as R from 'ramda';\n\nimport { DPI } from '../constants';\n\nconst MM_FACTOR = (1 / 25.4) * DPI;\n\nconst CM_FACTOR = (1 / 2.54) * DPI;\n\n/**\n * Parses scalar value in value and unit pairs\n *\n * @param {String} scalar value\n * @returns {Object} parsed value\n */\nconst parseValue = value => {\n  const match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw|px)?$/g.exec(value);\n\n  return match\n    ? { value: parseFloat(match[1], 10), unit: match[2] || 'pt' }\n    : { value, unit: undefined };\n};\n\n/**\n * Transform given scalar value\n *\n * @param {Object} container\n * @param {String} styles value\n * @returns {Object} transformed value\n */\nconst transformUnit = R.curryN(2, (container, value) => {\n  const scalar = parseValue(value);\n\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * DPI;\n    case 'mm':\n      return scalar.value * MM_FACTOR;\n    case 'cm':\n      return scalar.value * CM_FACTOR;\n    case 'vh':\n      return scalar.value * (container.height / 100);\n    case 'vw':\n      return scalar.value * (container.width / 100);\n    default:\n      return scalar.value;\n  }\n});\n\n/**\n * Transform units on given styles object.\n * Container is given to calculate vh and vw\n *\n * @param {Object} container\n * @param {Object} styles object\n * @returns {Object} transformed styles\n */\nconst transformUnits = (container, styles) =>\n  R.map(transformUnit(container), styles);\n\nexport default R.curryN(2, transformUnits);\n","import * as R from 'ramda';\nimport matchMedia from 'media-engine';\n\n/**\n * Resolves media queries in styles object\n *\n * @param {Object} container\n * @param {Object} styles object\n */\nconst resolveMediaQueries = (container, styles) => {\n  return Object.keys(styles).reduce((acc, key) => {\n    if (/@media/.test(key)) {\n      return {\n        ...acc,\n        ...matchMedia({ [key]: styles[key] }, container),\n      };\n    }\n\n    return { ...acc, [key]: styles[key] };\n  }, {});\n};\n\nexport default R.curryN(2, resolveMediaQueries);\n","import * as R from 'ramda';\n\nimport isLink from '../node/isLink';\nimport flattenStyles from '../stylesheet/flatten';\nimport expandStyles from '../stylesheet/expandStyles';\nimport transformUnits from '../stylesheet/transformUnits';\nimport transformStyles from '../stylesheet/transformStyles';\nimport transformColors from '../stylesheet/transformColors';\nimport resolveMediaQueries from '../stylesheet/resolveMediaQueries';\n\nconst LINK_STYLES = {\n  color: 'blue',\n  textDecoration: 'underline',\n};\n\n/**\n * Filter styles with `none` value\n *\n * @param {Object} style object\n * @returns {Object} style without none values\n */\nconst filterNoneValues = R.reject(R.equals('none'));\n\n/**\n * Resolves styles\n *\n * @param {Object} container\n * @param {Object} node\n * @param {Object} style object\n * @returns {Object} resolved style object\n */\nconst resolveStyles = container =>\n  R.compose(\n    transformUnits(container),\n    transformColors,\n    transformStyles,\n    expandStyles,\n    resolveMediaQueries(container),\n    filterNoneValues,\n    flattenStyles,\n  );\n\n/**\n * Resolves node styles\n *\n * @param {Object} container\n * @param {Object} document node\n * @returns {Object} node (and subnodes) with resolved styles\n */\nconst resolveNodeStyles = container => node =>\n  R.o(\n    R.when(isLink, R.evolve({ style: R.merge(LINK_STYLES) })),\n    R.evolve({\n      style: resolveStyles(container),\n      children: R.map(resolveNodeStyles(container)),\n    }),\n  )(node);\n\n/**\n * Resolves page styles\n *\n * @param {Object} document page\n * @returns {Object} document page with resolved styles\n */\nconst resolvePageStyles = page => {\n  const box = R.prop('box', page);\n  const style = R.prop('style', page);\n  const container = R.isEmpty(box) ? style : box;\n\n  return R.evolve({\n    style: resolveStyles(container),\n    children: R.map(resolveNodeStyles(container)),\n  })(page);\n};\n\n/**\n * Resolves root styles\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved styles\n */\nexport default R.evolve({\n  children: R.map(resolvePageStyles),\n});\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\nconst getTransformStyle = s => R.pathOr('50%', ['style', s]);\n\n/**\n * Get node origin\n *\n * @param {Object} node\n * @returns {Object} node origin\n */\nconst getOrigin = node => {\n  if (!node.box) return {};\n\n  const { left, top, width, height } = node.box;\n  const transformOriginX = getTransformStyle('transformOriginX')(node);\n  const transformOriginY = getTransformStyle('transformOriginY')(node);\n\n  const percentX = matchPercent(transformOriginX);\n  const percentY = matchPercent(transformOriginY);\n\n  const offsetX = percentX ? width * percentX.percent : transformOriginX;\n  const offsetY = percentY ? height * percentY.percent : transformOriginY;\n\n  return { left: left + offsetX, top: top + offsetY };\n};\n\nexport default getOrigin;\n","import * as R from 'ramda';\n\nimport getOrigin from '../node/getOrigin';\n\n/**\n * Resolve node origin\n *\n * @param {Object} node\n * @returns {Object} node with origin attribute\n */\nconst resolveNodeOrigin = node =>\n  R.compose(\n    R.evolve({ children: R.map(resolveNodeOrigin) }),\n    R.converge(R.assoc('origin'), [getOrigin, R.identity]),\n  )(node);\n\n/**\n * Resolve document origins\n *\n * @param {Object} document root\n * @returns {Object} documrnt root\n */\nconst resolveOrigin = R.evolve({\n  children: R.map(resolveNodeOrigin),\n});\n\nexport default resolveOrigin;\n","import * as R from 'ramda';\n\nimport { PORTRAIT, LANDSCAPE } from '../constants';\n\nconst VALID_ORIENTATIONS = [PORTRAIT, LANDSCAPE];\n\n/**\n * Get page orientation. Defaults to landscape\n *\n * @param { Object } page object\n * @returns { String } page orientation\n */\nconst getOrientation = R.compose(\n  R.ifElse(\n    R.includes(R.__, VALID_ORIENTATIONS),\n    R.identity,\n    R.always(PORTRAIT),\n  ),\n  R.pathOr(PORTRAIT, ['props', 'orientation']),\n);\n\nexport default getOrientation;\n","import * as R from 'ramda';\n\nimport getOrientation from './getOrientation';\n\nimport { LANDSCAPE } from '../constants';\n\nconst isLandscape = R.compose(\n  R.equals(LANDSCAPE),\n  getOrientation,\n);\n\nexport default isLandscape;\n","import * as R from 'ramda';\n\nimport isLandscape from './isLandscape';\nimport { PAGE_SIZES } from '../constants';\n\n/**\n * Transforms array into size object\n *\n * @param {Array} array\n * @returns {Object} size object with width and height\n */\nconst toSizeObject = R.applySpec({\n  width: R.prop(0),\n  height: R.prop(1),\n});\n\n/**\n * Flip size object\n *\n * @param {Object} size object\n * @returns {Object} flipped size object\n */\nconst flipSizeObject = R.applySpec({\n  width: R.prop('height'),\n  height: R.prop('width'),\n});\n\n/**\n * Returns size object from a given string\n *\n * @param {String} page size string\n * @returns {Object} size object with width and height\n */\nconst getStringSize = R.compose(\n  toSizeObject,\n  R.prop(R.__, PAGE_SIZES),\n  R.toUpper,\n);\n\n/**\n * Returns size object from a single number\n *\n * @param {Number} page size number\n * @returns {Object} size object with width and height\n */\nconst getNumberSize = R.compose(\n  toSizeObject,\n  v => [v],\n);\n\n/**\n * Throws invalid size error\n *\n * @param {String} invalid page size input\n */\nconst throwInvalidError = size => {\n  throw new Error(`Invalid Page size: ${JSON.stringify(size)}`);\n};\n\n/**\n * Return page size in an object { width, height }\n *\n * @param {Object} page instance\n * @returns {Object} size object with width and height\n */\nconst getSize = page => {\n  const size = R.compose(\n    R.cond([\n      [R.is(String), getStringSize],\n      [R.is(Array), toSizeObject],\n      [R.is(Number), getNumberSize],\n      [R.is(Object), R.identity],\n      [R.T, throwInvalidError],\n    ]),\n    R.pathOr('A4', ['props', 'size']),\n  )(page);\n\n  return isLandscape(page) ? flipSizeObject(size) : size;\n};\n\nexport default getSize;\n","import * as R from 'ramda';\n\n/**\n * Add empt box prop if not present in node\n *\n * @param {Object} node\n * @returns {Object} node with box prop\n */\nconst assocIfNil = (key, value, target) =>\n  R.when(\n    R.compose(\n      R.isNil,\n      R.prop(key),\n    ),\n    R.assoc(key, value),\n  )(target);\n\nexport default R.curryN(3, assocIfNil);\n","import * as R from 'ramda';\n\nimport getPageSize from '../page/getSize';\nimport assocIfNil from '../utils/assocIfNil';\n\n/**\n * Resolves page size\n *\n * @param {Object} page\n * @returns {Object} page with resolved size in style attribute\n */\nexport const resolvePageSize = page => {\n  const size = getPageSize(page);\n  return R.evolve({ style: R.merge(R.__, size) })(page);\n};\n\n/**\n * Resolves page sizes\n *\n * @param {Object} document root\n * @returns {Object} document root with resolved page sizes\n */\nconst resolvePageSizes = R.evolve({\n  children: R.map(\n    R.compose(\n      resolvePageSize,\n      assocIfNil('style', {}),\n    ),\n  ),\n});\n\nexport default resolvePageSizes;\n","/**\n * Get line index at given height\n *\n * @param {Object} node\n * @param {Number} height\n */\nconst lineIndexAtHeight = (node, height) => {\n  let y = 0;\n\n  if (!node.lines) return 0;\n\n  for (let i = 0; i < node.lines.length; i++) {\n    const line = node.lines[i];\n    if (y + line.box.height > height) return i;\n    y += line.box.height;\n  }\n\n  return node.lines.length;\n};\n\nexport default lineIndexAtHeight;\n","/**\n * Get height for given text line index\n *\n * @param {Object} node\n * @param {Number} index\n */\nconst heightAtLineIndex = (node, index) => {\n  let counter = 0;\n\n  if (!node.lines) return counter;\n\n  for (let i = 0; i < index; i++) {\n    const line = node.lines[i];\n\n    if (!line) break;\n\n    counter += line.box.height;\n  }\n\n  return counter;\n};\n\nexport default heightAtLineIndex;\n","import * as R from 'ramda';\n\nimport lineIndexAtHeight from './lineIndexAtHeight';\nimport heightAtLineIndex from './heightAtLineIndex';\n\nconst zero = R.always(0);\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst getWidows = R.pathOr(2, ['props', 'widows']);\n\nconst getOrphans = R.pathOr(2, ['props', 'orphans']);\n\nconst getLineBreak = (node, height) => {\n  const top = getTop(node);\n  const widows = getWidows(node);\n  const orphans = getOrphans(node);\n  const linesQuantity = node.lines.length;\n  const slicedLine = lineIndexAtHeight(node, height - top);\n\n  if (slicedLine === 0) {\n    return 0;\n  } else if (linesQuantity < orphans) {\n    return linesQuantity;\n  } else if (slicedLine < orphans || linesQuantity < orphans + widows) {\n    return 0;\n  } else if (linesQuantity === orphans + widows) {\n    return orphans;\n  } else if (linesQuantity - slicedLine < widows) {\n    return linesQuantity - widows;\n  }\n\n  return slicedLine;\n};\n\nconst splitText = (node, height) => {\n  const slicedLineIndex = getLineBreak(node, height);\n  const currentHeight = heightAtLineIndex(node, slicedLineIndex);\n  const nextHeight = node.box.height - currentHeight;\n\n  const current = R.evolve(\n    {\n      lines: R.slice(0, slicedLineIndex),\n      style: R.evolve({\n        marginBottom: zero,\n        paddingBottom: zero,\n        borderBottomWidth: zero,\n        borderBottomLeftRadius: zero,\n        borderBottomRightRadius: zero,\n      }),\n      box: {\n        height: R.always(currentHeight),\n        borderBottomWidth: zero,\n      },\n    },\n    node,\n  );\n\n  const next = R.evolve(\n    {\n      lines: R.slice(slicedLineIndex, Infinity),\n      style: R.evolve({\n        marginTop: zero,\n        paddingTop: zero,\n        borderTopWidth: zero,\n        borderTopLeftRadius: zero,\n        borderTopRightRadius: zero,\n      }),\n      box: {\n        top: zero,\n        height: R.always(nextHeight),\n        borderTopWidth: zero,\n      },\n    },\n    node,\n  );\n\n  return [current, next];\n};\n\nexport default splitText;\n","import * as R from 'ramda';\n\nconst zero = R.always(0);\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst hasFixedHeight = R.hasPath(['style', 'height']);\n\nconst subtractHeight = value =>\n  R.o(R.subtract(R.__, value), R.path(['box', 'height']));\n\nconst splitNode = (node, height) => {\n  if (!node) return [null, null];\n\n  const nodeTop = getTop(node);\n\n  // TODO: We should keep style untouched\n  const current = R.evolve({\n    style: R.evolve({\n      marginBottom: zero,\n      paddingBottom: zero,\n      borderBottomWidth: zero,\n      borderBottomLeftRadius: zero,\n      borderBottomRightRadius: zero,\n    }),\n    box: {\n      height: R.always(height - nodeTop),\n      borderBottomWidth: zero,\n    },\n  })(node);\n\n  const nextHeight = R.ifElse(\n    hasFixedHeight,\n    subtractHeight(height - nodeTop),\n    R.always(null),\n  )(node);\n\n  // TODO: We should keep style untouched\n  const next = R.evolve({\n    style: R.evolve({\n      marginTop: zero,\n      paddingTop: zero,\n      borderTopWidth: zero,\n      borderTopLeftRadius: zero,\n      borderTopRightRadius: zero,\n    }),\n    box: {\n      top: zero,\n      height: R.always(nextHeight),\n      borderTopWidth: zero,\n    },\n  })(node);\n\n  return [current, next];\n};\n\nexport default splitNode;\n","import * as R from 'ramda';\n\nimport castArray from '../utils/castArray';\nimport { TEXT_INSTANCE } from '../constants';\n\nconst isString = R.is(String);\n\nconst isNumber = R.is(Number);\n\nconst isNotString = R.complement(isString);\n\n/**\n * Transforms a react element instance to internal element format\n *\n * @param {Object} React element\n * @returns {Object} parsed react element\n */\nconst createInstance = element => {\n  if (isString(element) || isNumber(element))\n    return { type: TEXT_INSTANCE, value: `${element}` };\n\n  if (isNotString(element.type))\n    return createInstance(element.type(element.props));\n\n  const {\n    type,\n    props: { style = {}, children = [], ...props },\n  } = element;\n\n  const nextChildren = R.compose(\n    R.map(createInstance),\n    castArray,\n  )(children);\n\n  return {\n    type,\n    style,\n    props,\n    box: {},\n    children: nextChildren,\n  };\n};\n\nexport default createInstance;\n","import * as R from 'ramda';\n\n/**\n * Get many nodes height\n *\n * @param {Array} nodes\n * @return {number} nodes height\n */\nconst getNodesHeight = nodes => {\n  let max = 0;\n  let min = Infinity;\n\n  if (R.isEmpty(nodes)) return 0;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    min = Math.min(min, node.box.top);\n    max = Math.max(max, node.box.top + node.box.height);\n  }\n\n  return max - min;\n};\n\nexport default getNodesHeight;\n","import * as R from 'ramda';\n\nimport isSvg from './isSvg';\nimport isNote from './isNote';\nimport isImage from './isImage';\nimport isCanvas from './isCanvas';\nimport getNodesHeight from './getNodesHeight';\n\nconst getWrap = R.ifElse(\n  R.anyPass([isSvg, isNote, isImage, isCanvas]),\n  R.always(false),\n  R.pathOr(true, ['props', 'wrap']),\n);\n\nconst getBreak = R.pathOr(false, ['props', 'break']);\n\nconst getMinPresenceAhead = R.path(['props', 'minPresenceAhead']);\n\nconst defaultPresenceAhead = element => height =>\n  Math.min(element.box.height, height);\n\nconst getPresenceAhead = (elements, height) => {\n  let result = 0;\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!element.box) continue;\n\n    const isElementInside = height > element.box.top;\n    const presenceAhead =\n      element.props.presenceAhead || defaultPresenceAhead(element);\n\n    if (element && isElementInside) {\n      result += presenceAhead(height - element.box.top);\n    }\n  }\n\n  return result;\n};\n\nconst shouldBreak = (child, futureElements, height) => {\n  const minPresenceAhead = getMinPresenceAhead(child);\n  const presenceAhead = getPresenceAhead(futureElements, height);\n  const futureHeight = getNodesHeight(futureElements);\n  const shouldSplit = height < child.box.top + child.box.height;\n  const shouldWrap = getWrap(child);\n\n  return (\n    getBreak(child) ||\n    (!shouldWrap && shouldSplit) ||\n    (minPresenceAhead < futureHeight && presenceAhead < minPresenceAhead)\n  );\n};\n\nexport default shouldBreak;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport firstPass from '../utils/firstPass';\n\nconst getComputedPadding = edge => node => {\n  const yogaNode = node._yogaNode;\n  return yogaNode ? yogaNode.getComputedPadding(edge) : null;\n};\n\n/**\n * Get Yoga computed paddings. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} paddings\n */\nconst getPadding = R.applySpec({\n  paddingTop: firstPass(\n    getComputedPadding(Yoga.EDGE_TOP),\n    R.path(['box', 'paddingTop']),\n    R.path(['style', 'paddingTop']),\n    R.path(['style', 'paddingVertical']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingRight: firstPass(\n    getComputedPadding(Yoga.EDGE_RIGHT),\n    R.path(['box', 'paddingRight']),\n    R.path(['style', 'paddingRight']),\n    R.path(['style', 'paddingHorizontal']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingBottom: firstPass(\n    getComputedPadding(Yoga.EDGE_BOTTOM),\n    R.path(['box', 'paddingBottom']),\n    R.path(['style', 'paddingBottom']),\n    R.path(['style', 'paddingVertical']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n  paddingLeft: firstPass(\n    getComputedPadding(Yoga.EDGE_LEFT),\n    R.path(['box', 'paddingLeft']),\n    R.path(['style', 'paddingLeft']),\n    R.path(['style', 'paddingHorizontal']),\n    R.path(['style', 'padding']),\n    R.always(0),\n  ),\n});\n\nexport default getPadding;\n","import * as R from 'ramda';\n\nimport getPadding from '../node/getPadding';\n\nconst getContentArea = page => {\n  const { paddingTop } = getPadding(page);\n  const height = R.path(['style', 'height'], page);\n  return height - paddingTop;\n};\n\nexport default getContentArea;\n","const IGNORABLE_CODEPOINTS = [\n  8232, // LINE_SEPARATOR\n  8233, // PARAGRAPH_SEPARATOR\n];\n\nconst buildSubsetForFont = font =>\n  IGNORABLE_CODEPOINTS.reduce((acc, codePoint) => {\n    if (font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n    return [...acc, String.fromCharCode(codePoint)];\n  }, []);\n\nexport const ignoreChars = fragments =>\n  fragments.map(fragment => {\n    const charSubset = buildSubsetForFont(fragment.attributes.font);\n    const subsetRegex = new RegExp(charSubset.join('|'));\n\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes,\n    };\n  });\n","import AttributedString from '@react-pdf/textkit/attributedString';\n\nimport Font from '../font';\nimport isImage from '../node/isImage';\nimport { embedEmojis } from './emoji';\nimport transformText from './transformText';\nimport { ignoreChars } from './ignorableChars';\nimport isTextInstance from '../node/isTextInstance';\n\nconst PREPROCESSORS = [ignoreChars, embedEmojis];\n\n/**\n * Get textkit framgents of given node object\n *\n * @param {Object} instance node\n * @returns {Array} text fragments\n */\nconst getFragments = instance => {\n  if (!instance) return [{ string: '' }];\n\n  let fragments = [];\n  const {\n    color = 'black',\n    backgroundColor,\n    fontFamily = 'Helvetica',\n    fontWeight,\n    fontStyle,\n    fontSize = 18,\n    textAlign = 'left',\n    lineHeight,\n    textDecoration,\n    textDecorationColor,\n    textDecorationStyle,\n    textTransform,\n    letterSpacing,\n    textIndent,\n    opacity,\n  } = instance.style;\n\n  const obj = Font.getFont({ fontFamily, fontWeight, fontStyle });\n  const font = obj ? obj.data : fontFamily;\n\n  const attributes = {\n    font,\n    color,\n    opacity,\n    fontSize,\n    backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null,\n  };\n\n  instance.children.forEach(child => {\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: {\n          ...attributes,\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data,\n          },\n        },\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes,\n      });\n    } else {\n      if (child) {\n        fragments.push(...getFragments(child));\n      }\n    }\n  });\n\n  for (const preprocessor of PREPROCESSORS) {\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n\n/**\n * Get textkit attributed string from text node\n *\n * @param {Object} instance node\n * @returns {Object} attributed string\n */\nconst getAttributedString = instance =>\n  AttributedString.fromFragments(getFragments(instance));\n\nexport default getAttributedString;\n","import * as R from 'ramda';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\n\nimport Font from '../font';\nimport fontSubstitution from './fontSubstitution';\nimport getAttributedString from './getAttributedString';\n\nconst engines = {\n  linebreaker,\n  justification,\n  textDecoration,\n  scriptItemizer,\n  wordHyphenation,\n  fontSubstitution,\n};\n\nconst engine = layoutEngine(engines);\n\n/**\n * Get layout container for specific text node\n *\n * @param {Object} node\n * @param {Number} width\n * @param {Number} height\n * @returns {Object} layout container\n */\nconst getContainer = (node, width, height) => {\n  const maxLines = R.path(['style', 'maxLines'], node);\n  const textOverflow = R.path(['style', 'textOverflow'], node);\n\n  return {\n    x: 0,\n    y: 0,\n    width,\n    maxLines,\n    height: height || Infinity,\n    truncateMode: textOverflow,\n  };\n};\n\n/**\n * Get text layout options for specific text node\n *\n * @param {Object} node instance\n * @returns {Object} layout options\n */\nconst getLayoutOptions = node => ({\n  hyphenationPenalty: node.props.hyphenationPenalty,\n  hyphenationCallback: Font.getHyphenationCallback(),\n  shrinkWhitespaceFactor: { before: -0.5, after: -0.5 },\n});\n\n/**\n * Get text lines for given node\n *\n * @param {Object} node\n * @param {Number} container width\n * @param {Number} container height\n * @returns {Array} layout lines\n */\nconst layoutText = R.compose(\n  R.reduce(R.concat, []),\n  R.converge(engine, [getAttributedString, getContainer, getLayoutOptions]),\n);\n\nexport default layoutText;\n","import * as R from 'ramda';\n\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\nimport layoutText from '../text/layoutText';\n\nconst isNotSvg = R.complement(isSvg);\n\nconst hasLines = node =>\n  node.props.fixed ? !R.isEmpty(node.lines) : !!node.lines;\n\nconst shouldLayoutText = node => isText(node) && !hasLines(node);\n\n/**\n * Performs text layout on text node if wasn't calculated before.\n * Text layout is usually performed on Yoga's layout process (via setMeasureFunc),\n * but we need to layout those nodes with fixed width and height.\n *\n * @param {Object} node\n * @returns {Object} layouted node\n */\nconst resolveTextLayout = node =>\n  R.compose(\n    R.evolve({\n      children: R.map(R.when(isNotSvg, resolveTextLayout)),\n    }),\n    R.when(\n      shouldLayoutText,\n      R.compose(\n        R.converge(R.assoc('lines'), [\n          R.converge(layoutText, [\n            R.identity,\n            R.path(['box', 'width']),\n            R.path(['box', 'height']),\n          ]),\n          R.identity,\n        ]),\n      ),\n    ),\n  )(node);\n\nexport default resolveTextLayout;\n","import * as R from 'ramda';\n\nimport isSvg from '../node/isSvg';\nimport { INHERITED_PROPERTIES } from '../constants';\n\n/**\n * Get styles sub group of inherited properties\n *\n * @param {Object} style object\n * @returns {Object} style object only with inherited properties\n */\nconst getInheritStyles = R.compose(\n  R.pick(INHERITED_PROPERTIES),\n  R.propOr({}, 'style'),\n);\n\n/**\n * Merges styles with node\n *\n * @param {Object} style object\n * @param {Object} node\n * @returns {Object} node with styles merged\n */\nconst mergeStyles = styles =>\n  R.evolve({\n    style: R.merge(styles),\n  });\n\n/**\n * Inherit style values from the root to the leafs\n *\n * @param {Object} document root\n * @returns {Object} document root with inheritance\n *\n */\nconst resolveInheritance = node => {\n  if (isSvg(node)) return node;\n\n  const inheritStyles = getInheritStyles(node);\n\n  return R.evolve({\n    children: R.map(\n      R.compose(\n        resolveInheritance,\n        mergeStyles(inheritStyles),\n      ),\n    ),\n  })(node);\n};\n\nexport default resolveInheritance;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport firstPass from '../utils/firstPass';\n\nconst getComputedMargin = edge => node => {\n  const yogaNode = node._yogaNode;\n  return yogaNode ? yogaNode.getComputedMargin(edge) : null;\n};\n\n/**\n * Get Yoga computed magins. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} margins\n */\nconst getMargin = R.applySpec({\n  marginTop: firstPass(\n    getComputedMargin(Yoga.EDGE_TOP),\n    R.path(['box', 'marginTop']),\n    R.path(['style', 'marginTop']),\n    R.path(['style', 'marginVertical']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginRight: firstPass(\n    getComputedMargin(Yoga.EDGE_RIGHT),\n    R.path(['box', 'marginRight']),\n    R.path(['style', 'marginRight']),\n    R.path(['style', 'marginHorizontal']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginBottom: firstPass(\n    getComputedMargin(Yoga.EDGE_BOTTOM),\n    R.path(['box', 'marginBottom']),\n    R.path(['style', 'marginBottom']),\n    R.path(['style', 'marginVertical']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n  marginLeft: firstPass(\n    getComputedMargin(Yoga.EDGE_LEFT),\n    R.path(['box', 'marginLeft']),\n    R.path(['style', 'marginLeft']),\n    R.path(['style', 'marginHorizontal']),\n    R.path(['style', 'margin']),\n    R.always(0),\n  ),\n});\n\nexport default getMargin;\n","import * as R from 'ramda';\n\nconst getTop = yogaNode => (yogaNode ? yogaNode.getComputedTop() : 0);\nconst getRight = yogaNode => (yogaNode ? yogaNode.getComputedRight() : 0);\nconst getBottom = yogaNode => (yogaNode ? yogaNode.getComputedBottom() : 0);\nconst getLeft = yogaNode => (yogaNode ? yogaNode.getComputedLeft() : 0);\n\n/**\n * Get Yoga computed position. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} position\n */\nconst getPosition = node => {\n  const yogaNode = node._yogaNode;\n\n  return R.applySpec({\n    top: getTop,\n    right: getRight,\n    bottom: getBottom,\n    left: getLeft,\n  })(yogaNode);\n};\n\nexport default getPosition;\n","const DEFAULT_DIMENSION = {\n  width: 0,\n  height: 0,\n};\n\n/**\n * Get Yoga computed dimensions. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} dimensions\n */\nconst getDimension = node => {\n  const yogaNode = node._yogaNode;\n\n  if (!yogaNode) return DEFAULT_DIMENSION;\n\n  return {\n    width: yogaNode.getComputedWidth(),\n    height: yogaNode.getComputedHeight(),\n  };\n};\n\nexport default getDimension;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst getComputedBorder = edge => yogaNode =>\n  yogaNode ? yogaNode.getComputedBorder(edge) : 0;\n\n/**\n * Get Yoga computed border width. Zero otherwise\n *\n * @param {Object} node\n * @return {Object} border widths\n */\nconst getBorderWidth = node => {\n  const yogaNode = node._yogaNode;\n\n  return R.applySpec({\n    borderTopWidth: getComputedBorder(Yoga.EDGE_TOP),\n    borderRightWidth: getComputedBorder(Yoga.EDGE_RIGHT),\n    borderBottomWidth: getComputedBorder(Yoga.EDGE_BOTTOM),\n    borderLeftWidth: getComputedBorder(Yoga.EDGE_LEFT),\n  })(yogaNode);\n};\n\nexport default getBorderWidth;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set display attribute to node's Yoga instance\n *\n * @param {String} display\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setDisplay = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      yogaNode.setDisplay(\n        value === 'none' ? Yoga.DISPLAY_NONE : Yoga.DISPLAY_FLEX,\n      );\n    }\n  });\n\nexport default setDisplay;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set overflow attribute to node's Yoga instance\n *\n * @param {String} overflow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setOverflow = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('hidden'), R.always(Yoga.OVERFLOW_HIDDEN)],\n        [R.equals('scroll'), R.always(Yoga.OVERFLOW_SCROLL)],\n        [R.T, R.always(Yoga.OVERFLOW_VISIBLE)],\n      ])(value);\n\n      yogaNode.setOverflow(yogaValue);\n    }\n  });\n\nexport default setOverflow;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set flex wrap attribute to node's Yoga instance\n *\n * @param {String} flex wrap value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexWrap = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('wrap'), R.always(Yoga.WRAP_WRAP)],\n        [R.equals('wrap-reverse'), R.always(Yoga.WRAP_WRAP_REVERSE)],\n        [R.T, R.always(Yoga.WRAP_NO_WRAP)],\n      ])(value);\n\n      yogaNode.setFlexWrap(yogaValue);\n    }\n  });\n\nexport default setFlexWrap;\n","import * as R from 'ramda';\n\nimport upperFirst from '../utils/upperFirst';\nimport matchPercent from '../utils/matchPercent';\n\nconst isNotNil = R.complement(R.isNil);\n\n/**\n * Set generic yoga attribute to node's Yoga instance, handing `auto`, edges and percentage cases\n *\n * @param {String} property\n * @param {Number} edge\n * @param {any} value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setYogaValue = (attr, edge) => value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const hasEdge = isNotNil(edge);\n      const fixedMethod = `set${upperFirst(attr)}`;\n      const autoMethod = `${fixedMethod}Auto`;\n      const percentMethod = `${fixedMethod}Percent`;\n      const percent = matchPercent(value);\n\n      if (percent && !yogaNode[percentMethod]) {\n        throw new Error(`You can't pass percentage values to ${attr} property`);\n      }\n\n      if (percent) {\n        hasEdge\n          ? yogaNode[percentMethod](edge, percent.value)\n          : yogaNode[percentMethod](percent.value);\n      } else if (value === 'auto') {\n        hasEdge ? yogaNode[autoMethod](edge) : yogaNode[autoMethod]();\n      } else {\n        hasEdge\n          ? yogaNode[fixedMethod](edge, value)\n          : yogaNode[fixedMethod](value);\n      }\n    }\n  });\n\nexport default setYogaValue;\n","import * as R from 'ramda';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set flex grow attribute to node's Yoga instance\n *\n * @param {Number} flex grow value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexGrow = R.compose(\n  setYogaValue('flexGrow'),\n  R.defaultTo(0),\n);\n\nexport default setFlexGrow;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set flex basis attribute to node's Yoga instance\n *\n * @param {Number} flex basis value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexBasis = setYogaValue('flexBasis');\n\nexport default setFlexBasis;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport upperFirst from '../utils/upperFirst';\n\n/**\n * Set generic align attribute to node's Yoga instance\n *\n * @param {String} specific align property\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlign = attr => value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('flex-start'), R.always(Yoga.ALIGN_FLEX_START)],\n        [R.equals('center'), R.always(Yoga.ALIGN_CENTER)],\n        [R.equals('flex-end'), R.always(Yoga.ALIGN_FLEX_END)],\n        [R.equals('stretch'), R.always(Yoga.ALIGN_STRETCH)],\n        [R.equals('baseline'), R.always(Yoga.ALIGN_BASELINE)],\n        [R.equals('space-between'), R.always(Yoga.ALIGN_SPACE_BETWEEN)],\n        [R.equals('space-around'), R.always(Yoga.ALIGN_SPACE_AROUND)],\n        [\n          R.T,\n          R.always(attr === 'items' ? Yoga.ALIGN_STRETCH : Yoga.ALIGN_AUTO),\n        ],\n      ])(value);\n\n      yogaNode[`setAlign${upperFirst(attr)}`](yogaValue);\n    }\n  });\n\nexport default setAlign;\n","import setAlign from './setAlign';\n\n/**\n * Set align self attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignSelf = setAlign('self');\n\nexport default setAlignSelf;\n","import setAlign from './setAlign';\n\n/**\n * Set align items attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignItems = setAlign('items');\n\nexport default setAlignItems;\n","import * as R from 'ramda';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set flex shrink attribute to node's Yoga instance\n *\n * @param {Number} flex shrink value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexShrink = R.compose(\n  setYogaValue('flexShrink'),\n  R.defaultTo(1),\n);\n\nexport default setFlexShrink;\n","import * as R from 'ramda';\n\n/**\n * Set aspect ratio attribute to node's Yoga instance\n *\n * @param {Number} ratio\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAspectRatio = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      yogaNode.setAspectRatio(value);\n    }\n  });\n\nexport default setAspectRatio;\n","import setAlign from './setAlign';\n\n/**\n * Set align content attribute to node's Yoga instance\n *\n * @param {String} align value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setAlignContent = setAlign('content');\n\nexport default setAlignContent;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set position type attribute to node's Yoga instance\n *\n * @param {String} position type\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setPositionType = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      yogaNode.setPositionType(\n        value === 'absolute'\n          ? Yoga.POSITION_TYPE_ABSOLUTE\n          : Yoga.POSITION_TYPE_RELATIVE,\n      );\n    }\n  });\n\nexport default setPositionType;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst isRow = R.equals('row');\nconst isRowReverse = R.equals('row-reverse');\nconst isColumnReverse = R.equals('column-reverse');\n\n/**\n * Set flex direction attribute to node's Yoga instance\n *\n * @param {String} flex direction value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setFlexDirection = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (yogaNode) {\n      const yogaValue = R.cond([\n        [isRow, R.always(Yoga.FLEX_DIRECTION_ROW)],\n        [isRowReverse, R.always(Yoga.FLEX_DIRECTION_ROW_REVERSE)],\n        [isColumnReverse, R.always(Yoga.FLEX_DIRECTION_COLUMN_REVERSE)],\n        [R.T, R.always(Yoga.FLEX_DIRECTION_COLUMN)],\n      ])(value);\n\n      yogaNode.setFlexDirection(yogaValue);\n    }\n  });\n\nexport default setFlexDirection;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\n/**\n * Set justify content attribute to node's Yoga instance\n *\n * @param {String} justify content value\n * @param {Object} node instance\n * @return {Object} node instance\n */\nconst setJustifyContent = value =>\n  R.tap(node => {\n    const yogaNode = node._yogaNode;\n\n    if (!R.isNil(value) && yogaNode) {\n      const yogaValue = R.cond([\n        [R.equals('center'), R.always(Yoga.JUSTIFY_CENTER)],\n        [R.equals('flex-end'), R.always(Yoga.JUSTIFY_FLEX_END)],\n        [R.equals('space-between'), R.always(Yoga.JUSTIFY_SPACE_BETWEEN)],\n        [R.equals('space-around'), R.always(Yoga.JUSTIFY_SPACE_AROUND)],\n        [R.equals('space-evenly'), R.always(Yoga.JUSTIFY_SPACE_EVENLY)],\n        [R.T, R.always(Yoga.JUSTIFY_FLEX_START)],\n      ])(value);\n\n      yogaNode.setJustifyContent(yogaValue);\n    }\n  });\n\nexport default setJustifyContent;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set margin top attribute to node's Yoga instance\n *\n * @param {Number} margin top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginTop = setYogaValue('margin', Yoga.EDGE_TOP);\n\n/**\n * Set margin right attribute to node's Yoga instance\n *\n * @param {Number} margin right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginRight = setYogaValue('margin', Yoga.EDGE_RIGHT);\n\n/**\n * Set margin bottom attribute to node's Yoga instance\n *\n * @param {Number} margin bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginBottom = setYogaValue('margin', Yoga.EDGE_BOTTOM);\n\n/**\n * Set margin left attribute to node's Yoga instance\n *\n * @param {Number} margin left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMarginLeft = setYogaValue('margin', Yoga.EDGE_LEFT);\n\n/**\n * Set all margins at once\n *\n * @param {Number} margin\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMargin = margin =>\n  R.tap(node => {\n    setMarginTop(margin)(node);\n    setMarginRight(margin)(node);\n    setMarginBottom(margin)(node);\n    setMarginLeft(margin)(node);\n  });\n\nexport default setMargin;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set padding top attribute to node's Yoga instance\n *\n * @param {Number} padding top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingTop = setYogaValue('padding', Yoga.EDGE_TOP);\n\n/**\n * Set padding right attribute to node's Yoga instance\n *\n * @param {Number} padding right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingRight = setYogaValue('padding', Yoga.EDGE_RIGHT);\n\n/**\n * Set padding bottom attribute to node's Yoga instance\n *\n * @param {Number} padding bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingBottom = setYogaValue('padding', Yoga.EDGE_BOTTOM);\n\n/**\n * Set padding left attribute to node's Yoga instance\n *\n * @param {Number} padding left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPaddingLeft = setYogaValue('padding', Yoga.EDGE_LEFT);\n\n/**\n * Set all paddings at once\n *\n * @param {Number} margin\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPadding = padding =>\n  R.tap(node => {\n    setPaddingTop(padding)(node);\n    setPaddingRight(padding)(node);\n    setPaddingBottom(padding)(node);\n    setPaddingLeft(padding)(node);\n  });\n\nexport default setPadding;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set border top attribute to node's Yoga instance\n *\n * @param {Number} border top width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderTop = setYogaValue('border', Yoga.EDGE_TOP);\n\n/**\n * Set border right attribute to node's Yoga instance\n *\n * @param {Number} border right width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderRight = setYogaValue('border', Yoga.EDGE_RIGHT);\n\n/**\n * Set border bottom attribute to node's Yoga instance\n *\n * @param {Number} border bottom width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderBottom = setYogaValue('border', Yoga.EDGE_BOTTOM);\n\n/**\n * Set border left attribute to node's Yoga instance\n *\n * @param {Number} border left width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorderLeft = setYogaValue('border', Yoga.EDGE_LEFT);\n\n/**\n * Set all border widths at once\n *\n * @param {Number} border width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setBorder = width =>\n  R.tap(node => {\n    setBorderTop(width)(node);\n    setBorderRight(width)(node);\n    setBorderBottom(width)(node);\n    setBorderLeft(width)(node);\n  });\n\nexport default setBorder;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport setYogaValue from './setYogaValue';\n\n/**\n * Set position top attribute to node's Yoga instance\n *\n * @param {Number} position top\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionTop = setYogaValue('position', Yoga.EDGE_TOP);\n\n/**\n * Set position right attribute to node's Yoga instance\n *\n * @param {Number} position right\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionRight = setYogaValue('position', Yoga.EDGE_RIGHT);\n\n/**\n * Set position bottom attribute to node's Yoga instance\n *\n * @param {Number} position bottom\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionBottom = setYogaValue('position', Yoga.EDGE_BOTTOM);\n\n/**\n * Set position left attribute to node's Yoga instance\n *\n * @param {Number} position left\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPositionLeft = setYogaValue('position', Yoga.EDGE_LEFT);\n\n/**\n * Set all positions at once\n *\n * @param {Number} position\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setPosition = position =>\n  R.tap(node => {\n    setPositionTop(position)(node);\n    setPositionRight(position)(node);\n    setPositionBottom(position)(node);\n    setPositionLeft(position)(node);\n  });\n\nexport default setPosition;\n","import setYogaValue from './setYogaValue';\n\n/**\n * Set width to node's Yoga instance\n *\n * @param {Number} width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setWidth = setYogaValue('width');\n\n/**\n * Set min width to node's Yoga instance\n *\n * @param {Number} min width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMinWidth = setYogaValue('minWidth');\n\n/**\n * Set max width to node's Yoga instance\n *\n * @param {Number} max width\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMaxWidth = setYogaValue('maxWidth');\n\n/**\n * Set height to node's Yoga instance\n *\n * @param {Number} height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setHeight = setYogaValue('height');\n\n/**\n * Set min height to node's Yoga instance\n *\n * @param {Number} min height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMinHeight = setYogaValue('minHeight');\n\n/**\n * Set max height to node's Yoga instance\n *\n * @param {Number} max height\n * @param {Object} node instance\n * @return {Object} node instance\n */\nexport const setMaxHeight = setYogaValue('maxHeight');\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nconst getAspectRatio = viewbox => {\n  if (!viewbox) return null;\n  return (viewbox.maxX - viewbox.minX) / (viewbox.maxY - viewbox.minY);\n};\n\n/**\n * Yoga svg measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nconst measureCanvas = (page, node, width, widthMode, height, heightMode) => {\n  const aspectRatio = getAspectRatio(node.props.viewBox) || 1;\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY ||\n    widthMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    return { width, height: width / aspectRatio };\n  }\n\n  if (heightMode === Yoga.MEASURE_MODE_EXACTLY) {\n    return { width: height * aspectRatio };\n  }\n\n  return {};\n};\n\nexport default R.curryN(6, measureCanvas);\n","import AttributedString from '@react-pdf/textkit/attributedString';\n\n/**\n * Get lines width (if any)\n *\n * @param {Object} node\n * @returns {Number} lines width\n */\nconst linesWidth = node => {\n  if (!node.lines) return -1;\n  return Math.max(\n    ...node.lines.map(line => AttributedString.advanceWidth(line)),\n  );\n};\n\nexport default linesWidth;\n","/**\n * Get lines height (if any)\n *\n * @param {Object} node\n * @returns {Number} lines height\n */\nconst linesHeight = node => {\n  if (!node.lines) return -1;\n  return node.lines.reduce((acc, line) => acc + line.box.height, 0);\n};\n\nexport default linesHeight;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport layoutText from './layoutText';\nimport linesWidth from './linesWidth';\nimport linesHeight from './linesHeight';\n\n/**\n * Yoga text measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} text width and height\n */\nconst measureText = (page, node, width, widthMode, height, heightMode) => {\n  if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n    if (!node.lines) node.lines = layoutText(node, width, height);\n\n    return { height: linesHeight(node) };\n  }\n\n  if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n    if (!node.lines) node.lines = layoutText(node, width, height);\n\n    return {\n      height: linesHeight(node),\n      width: Math.min(width, linesWidth(node)),\n    };\n  }\n\n  return {};\n};\n\nexport default R.curryN(6, measureText);\n","import * as R from 'ramda';\n\n/**\n * Get image ratio\n *\n * @param {Object} image node\n * @returns {Number} image ratio\n */\nconst getRatio = R.ifElse(\n  R.hasPath(['image', 'data']),\n  node => node.image.width / node.image.height,\n  R.always(1),\n);\n\nexport default getRatio;\n","import * as R from 'ramda';\n\n/**\n * Checks if page has auto height\n *\n * @param {Object} page\n * @returns {Boolean} is page height auto\n */\nconst isHeightAuto = R.pathSatisfies(R.isNil, ['box', 'height']);\n\nexport default isHeightAuto;\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport getRatio from '../image/getRatio';\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport isHeightAuto from '../page/isHeightAuto';\n\nconst SAFETY_HEIGHT = 10;\n\n/**\n * Yoga image measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} image width and height\n */\nconst measureImage = (page, node, width, widthMode, height, heightMode) => {\n  const imageRatio = getRatio(node);\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page)\n    ? Infinity\n    : page.box.height -\n      pagePadding.paddingTop -\n      pagePadding.paddingBottom -\n      imageMargin.marginTop -\n      imageMargin.marginBottom -\n      SAFETY_HEIGHT;\n\n  // Skip measure if image data not present yet\n  if (!node.image) return { width: 0, height: 0 };\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY &&\n    heightMode === Yoga.MEASURE_MODE_UNDEFINED\n  ) {\n    const scaledHeight = width / imageRatio;\n    return { height: Math.min(pageArea, scaledHeight) };\n  }\n\n  if (\n    heightMode === Yoga.MEASURE_MODE_EXACTLY &&\n    (widthMode === Yoga.MEASURE_MODE_AT_MOST ||\n      widthMode === Yoga.MEASURE_MODE_UNDEFINED)\n  ) {\n    return { width: Math.min(height * imageRatio, width) };\n  }\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_EXACTLY &&\n    heightMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    const scaledHeight = width / imageRatio;\n    return { height: Math.min(height, pageArea, scaledHeight) };\n  }\n\n  if (\n    widthMode === Yoga.MEASURE_MODE_AT_MOST &&\n    heightMode === Yoga.MEASURE_MODE_AT_MOST\n  ) {\n    if (imageRatio > 1) {\n      return {\n        width: width,\n        height: Math.min(width / imageRatio, height),\n      };\n    } else {\n      return {\n        width: Math.min(height * imageRatio, width),\n        height: height,\n      };\n    }\n  }\n\n  return { height, width };\n};\n\nexport default R.curryN(6, measureImage);\n","import * as R from 'ramda';\n\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport isHeightAuto from '../page/isHeightAuto';\n\nconst SAFETY_HEIGHT = 10;\n\nconst getMax = R.reduce(R.max, -Infinity);\n\n/**\n * Helper object to predict canvas size\n * TODO: Implement remaining functions (as close as possible);\n */\nconst measureCtx = () => {\n  const ctx = {};\n  const points = [];\n\n  const nil = () => ctx;\n  const addPoint = (x, y) => points.push([x, y]);\n\n  const moveTo = R.compose(\n    nil,\n    addPoint,\n  );\n\n  const rect = (x, y, w, h) => {\n    addPoint(x, y);\n    addPoint(x + w, y);\n    addPoint(x, y + h);\n    addPoint(x + w, y + h);\n    return ctx;\n  };\n\n  const ellipse = (x, y, rx, ry) => {\n    ry = ry || rx;\n\n    addPoint(x - rx, y - ry);\n    addPoint(x + rx, y - ry);\n    addPoint(x + rx, y + ry);\n    addPoint(x - rx, y + ry);\n\n    return ctx;\n  };\n\n  const polygon = (...pts) => {\n    points.push(...pts);\n    return nil();\n  };\n\n  // Change dimensions\n  ctx.rect = rect;\n  ctx.moveTo = moveTo;\n  ctx.lineTo = moveTo;\n  ctx.circle = ellipse;\n  ctx.polygon = polygon;\n  ctx.ellipse = ellipse;\n  ctx.roundedRect = rect;\n\n  // To be implemented\n  ctx.text = nil;\n  ctx.path = nil;\n  ctx.lineWidth = nil;\n  ctx.bezierCurveTo = nil;\n  ctx.quadraticCurveTo = nil;\n\n  ctx.scale = nil;\n  ctx.rotate = nil;\n  ctx.translate = nil;\n\n  // These don't change dimensions\n  ctx.dash = nil;\n  ctx.clip = nil;\n  ctx.save = nil;\n  ctx.fill = nil;\n  ctx.font = nil;\n  ctx.stroke = nil;\n  ctx.lineCap = nil;\n  ctx.opacity = nil;\n  ctx.restore = nil;\n  ctx.lineJoin = nil;\n  ctx.fontSize = nil;\n  ctx.fillColor = nil;\n  ctx.miterLimit = nil;\n  ctx.strokeColor = nil;\n  ctx.fillOpacity = nil;\n  ctx.strokeOpacity = nil;\n  ctx.linearGradient = nil;\n  ctx.radialGradient = nil;\n\n  ctx.getWidth = () =>\n    R.compose(\n      getMax,\n      R.pluck(0),\n    )(points);\n\n  ctx.getHeight = () =>\n    R.compose(\n      getMax,\n      R.pluck(1),\n    )(points);\n\n  return ctx;\n};\n\n/**\n * Yoga canvas measure function\n *\n * @param {Object} page\n * @param {Object} node\n * @param {Number} width\n * @param {Number} widthMode\n * @param {Number} height\n * @param {Number} heightMode\n * @returns {Object} canvas width and height\n */\nconst measureCanvas = (page, node) => {\n  const imageMargin = getMargin(node);\n  const pagePadding = getPadding(page);\n  const pageArea = isHeightAuto(page)\n    ? Infinity\n    : page.box.height -\n      pagePadding.paddingTop -\n      pagePadding.paddingBottom -\n      imageMargin.marginTop -\n      imageMargin.marginBottom -\n      SAFETY_HEIGHT;\n\n  const ctx = measureCtx();\n\n  node.props.paint(ctx);\n\n  const width = ctx.getWidth();\n  const height = Math.min(pageArea, ctx.getHeight());\n\n  return { height, width };\n};\n\nexport default R.curryN(6, measureCanvas);\n","import * as R from 'ramda';\nimport Yoga from 'yoga-layout';\n\nimport getMargin from '../node/getMargin';\nimport getPadding from '../node/getPadding';\nimport getPosition from '../node/getPosition';\nimport getDimension from '../node/getDimension';\nimport getBorderWidth from '../node/getBorderWidth';\nimport setDisplay from '../node/setDisplay';\nimport setOverflow from '../node/setOverflow';\nimport setFlexWrap from '../node/setFlexWrap';\nimport setFlexGrow from '../node/setFlexGrow';\nimport setFlexBasis from '../node/setFlexBasis';\nimport setAlignSelf from '../node/setAlignSelf';\nimport setAlignItems from '../node/setAlignItems';\nimport setFlexShrink from '../node/setFlexShrink';\nimport setAspectRatio from '../node/setAspectRatio';\nimport setAlignContent from '../node/setAlignContent';\nimport setPositionType from '../node/setPositionType';\nimport setFlexDirection from '../node/setFlexDirection';\nimport setJustifyContent from '../node/setJustifyContent';\nimport {\n  setMarginTop,\n  setMarginRight,\n  setMarginBottom,\n  setMarginLeft,\n} from '../node/setMargin';\nimport {\n  setPaddingTop,\n  setPaddingRight,\n  setPaddingBottom,\n  setPaddingLeft,\n} from '../node/setPadding';\nimport {\n  setBorderTop,\n  setBorderRight,\n  setBorderBottom,\n  setBorderLeft,\n} from '../node/setBorderWidth';\nimport {\n  setPositionTop,\n  setPositionRight,\n  setPositionBottom,\n  setPositionLeft,\n} from '../node/setPosition';\nimport {\n  setWidth,\n  setHeight,\n  setMinWidth,\n  setMaxWidth,\n  setMinHeight,\n  setMaxHeight,\n} from '../node/setDimension';\nimport isSvg from '../node/isSvg';\nimport isText from '../node/isText';\nimport isNote from '../node/isNote';\nimport isPage from '../node/isPage';\nimport isImage from '../node/isImage';\nimport isCanvas from '../node/isCanvas';\nimport measureSvg from '../svg/measureSvg';\nimport measureText from '../text/measureText';\nimport measureImage from '../image/measureImage';\nimport measureCanvas from '../canvas/measureCanvas';\nimport isTextInstance from '../node/isTextInstance';\n\nconst YOGA_NODE = '_yogaNode';\nconst YOGA_CONFIG = Yoga.Config.create();\n\nYOGA_CONFIG.setPointScaleFactor(0);\n\nconst setNodeHeight = node =>\n  R.ifElse(\n    isPage,\n    setHeight(node.box.height),\n    setHeight(node.box.height || node.style.height),\n  );\n\n/**\n * Set styles valeus into yoga node before layout calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst setYogaValues = R.tap(node => {\n  R.compose(\n    setNodeHeight(node),\n    setWidth(node.style.width),\n    setMinWidth(node.style.minWidth),\n    setMaxWidth(node.style.maxWidth),\n    setMinHeight(node.style.minHeight),\n    setMaxHeight(node.style.maxHeight),\n    setMarginTop(node.style.marginTop),\n    setMarginRight(node.style.marginRight),\n    setMarginBottom(node.style.marginBottom),\n    setMarginLeft(node.style.marginLeft),\n    setPaddingTop(node.style.paddingTop),\n    setPaddingRight(node.style.paddingRight),\n    setPaddingBottom(node.style.paddingBottom),\n    setPaddingLeft(node.style.paddingLeft),\n    setPositionType(node.style.position),\n    setPositionTop(node.style.top),\n    setPositionRight(node.style.right),\n    setPositionBottom(node.style.bottom),\n    setPositionLeft(node.style.left),\n    setBorderTop(node.style.borderTopWidth),\n    setBorderRight(node.style.borderRightWidth),\n    setBorderBottom(node.style.borderBottomWidth),\n    setBorderLeft(node.style.borderLeftWidth),\n    setDisplay(node.style.display),\n    setFlexDirection(node.style.flexDirection),\n    setAlignSelf(node.style.alignSelf),\n    setAlignContent(node.style.alignContent),\n    setAlignItems(node.style.alignItems),\n    setJustifyContent(node.style.justifyContent),\n    setFlexWrap(node.style.flexWrap),\n    setOverflow(node.style.overflow),\n    setAspectRatio(node.style.aspectRatio),\n    setFlexBasis(node.style.flexBasis),\n    setFlexGrow(node.style.flexGrow),\n    setFlexShrink(node.style.flexShrink),\n  )(node);\n});\n\n/**\n * Inserts child into parent' yoga node\n *\n * @param {Object} parent\n * @param {Object} node\n * @param {Object} node\n */\nconst insertYogaNodes = parent =>\n  R.tap(child => parent.insertChild(child[YOGA_NODE], parent.getChildCount()));\n\nconst setMeasureFunc = page => node => {\n  const yogaNode = node[YOGA_NODE];\n\n  if (isText(node)) {\n    yogaNode.setMeasureFunc(measureText(page, node));\n  }\n\n  if (isImage(node)) {\n    yogaNode.setMeasureFunc(measureImage(page, node));\n  }\n\n  if (isCanvas(node)) {\n    yogaNode.setMeasureFunc(measureCanvas(page, node));\n  }\n\n  if (isSvg(node)) {\n    yogaNode.setMeasureFunc(measureSvg(page, node));\n  }\n\n  return node;\n};\n\nconst isNotText = R.complement(isText);\nconst isNotNote = R.complement(isNote);\nconst isNotSvg = R.complement(isSvg);\nconst isNotTextInstance = R.complement(isTextInstance);\nconst isLayoutElement = R.allPass([isNotText, isNotNote, isNotSvg]);\n\n/**\n * Creates and add yoga node to document tree\n * Handles measure function for text and image nodes\n *\n * @param {Object} node\n * @returns {Object} node with appended yoga node\n */\nconst createYogaNodes = page => node => {\n  const yogaNode = Yoga.Node.createWithConfig(YOGA_CONFIG);\n\n  return R.compose(\n    setMeasureFunc(page),\n    R.when(\n      isLayoutElement,\n      R.evolve({\n        children: R.map(\n          R.compose(\n            insertYogaNodes(yogaNode),\n            createYogaNodes(page),\n          ),\n        ),\n      }),\n    ),\n    setYogaValues,\n    R.assoc(YOGA_NODE, yogaNode),\n  )(node);\n};\n\n/**\n * Performs yoga calculation\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst calculateLayout = R.tap(page => page[YOGA_NODE].calculateLayout());\n\n/**\n * Saves Yoga layout result into 'box' attribute of node\n *\n * @param {Object} node\n * @returns {Object} node with box data\n */\nconst persistDimensions = node => {\n  return R.evolve({\n    children: R.map(R.when(isNotTextInstance, persistDimensions)),\n    box: R.always(\n      R.mergeAll([\n        getPadding(node),\n        getMargin(node),\n        getBorderWidth(node),\n        getPosition(node),\n        getDimension(node),\n      ]),\n    ),\n  })(node);\n};\n\n/**\n * Removes and destroys yoga node frm document tree\n *\n * @param {Object} node\n * @returns {Object} node without yoga node\n */\nconst destroyYogaNodes = node => {\n  return R.compose(\n    R.dissoc(YOGA_NODE),\n    R.tap(n => Yoga.Node.destroy(n[YOGA_NODE])),\n    R.evolve({ children: R.map(R.when(isLayoutElement, destroyYogaNodes)) }),\n  )(node);\n};\n\n/**\n * Calculates page object layout using Yoga.\n * Takes node values from 'box' and 'style' attributes, and persist them back into 'box'\n * Destroy yoga values at the end.\n *\n * @param {Object} page object\n * @returns {Object} page object with correct 'box' layout attributes\n */\nexport const resolvePageDimensions = page =>\n  R.ifElse(\n    R.isNil,\n    R.always(null),\n    R.compose(\n      destroyYogaNodes,\n      persistDimensions,\n      calculateLayout,\n      createYogaNodes(page),\n    ),\n  )(page);\n\n/**\n * Calculates root object layout using Yoga.\n *\n * @param {Object} root object\n * @returns {Object} root object with correct 'box' layout attributes\n */\nconst resolveDimensions = node =>\n  R.evolve({\n    children: R.map(resolvePageDimensions),\n  })(node);\n\nexport default resolveDimensions;\n","import * as R from 'ramda';\n\nimport isText from '../node/isText';\nimport splitText from '../text/splitText';\nimport splitNode from '../node/splitNode';\nimport createInstance from '../node/createInstance';\nimport shouldNodeBreak from '../node/shouldBreak';\nimport getContentArea from '../page/getContentArea';\nimport resolveTextLayout from './resolveTextLayout';\nimport resolveInheritance from './resolveInheritance';\nimport { resolvePageDimensions } from './resolveDimensions';\n\n// Prevent splitting elements by low decimal numbers\nconst SAFTY_THRESHOLD = 0.001;\n\nconst assingChildren = R.assoc('children');\n\nconst getTop = R.pathOr(0, ['box', 'top']);\n\nconst getHeight = R.path(['box', 'height']);\n\nconst getChildren = R.propOr([], 'children');\n\nconst isElementOutside = R.useWith(R.lte, [R.identity, getTop]);\n\nconst isFixed = R.pathEq(['props', 'fixed'], true);\n\nconst allFixed = R.all(isFixed);\n\nconst isDynamic = R.hasPath(['props', 'render']);\n\nconst relayoutPage = R.compose(\n  resolveTextLayout,\n  resolveInheritance,\n  resolvePageDimensions,\n);\n\nconst splitView = (node, height) => {\n  const [currentNode, nextNode] = splitNode(node, height);\n  const [currentChilds, nextChildren] = splitChildren(height, node);\n\n  return [\n    assingChildren(currentChilds)(currentNode),\n    assingChildren(nextChildren)(nextNode),\n  ];\n};\n\nconst split = R.ifElse(isText, splitText, splitView);\n\nconst splitNodes = (height, nodes) => {\n  const currentChildren = [];\n  const nextChildren = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const child = nodes[i];\n    const futureNodes = nodes.slice(i + 1);\n    const futureFixedNodes = R.filter(isFixed, futureNodes);\n\n    const nodeTop = getTop(child);\n    const nodeHeight = getHeight(child);\n    const isOutside = isElementOutside(height, child);\n    const shouldBreak = shouldNodeBreak(child, futureNodes, height);\n    const shouldSplit = height + SAFTY_THRESHOLD < nodeTop + nodeHeight;\n\n    if (isFixed(child)) {\n      nextChildren.push(child);\n      currentChildren.push(child);\n      continue;\n    }\n\n    if (isOutside) {\n      const next = R.evolve({ box: { top: R.subtract(R.__, height) } })(child);\n      nextChildren.push(next);\n      continue;\n    }\n\n    if (shouldBreak) {\n      const next = R.evolve({\n        box: { top: R.subtract(R.__, height) },\n        props: R.evolve({ break: R.always(false) }),\n      })(child);\n\n      currentChildren.push(...futureFixedNodes);\n      nextChildren.push(next, ...futureNodes);\n      break;\n    }\n\n    if (shouldSplit) {\n      const [currentChild, nextChild] = split(child, height);\n\n      if (currentChild) currentChildren.push(currentChild);\n      if (nextChild) nextChildren.push(nextChild);\n\n      continue;\n    }\n\n    currentChildren.push(child);\n  }\n\n  return [currentChildren, nextChildren];\n};\n\nconst splitChildren = (height, node) => {\n  const children = getChildren(node);\n  const availableHeight = height - getTop(node);\n  return splitNodes(availableHeight, children);\n};\n\nconst splitPage = (page, pageNumber) => {\n  const contentArea = getContentArea(page);\n  const height = R.path(['style', 'height'], page);\n  const dynamicPage = resolveDynamicPage({ pageNumber }, page);\n\n  const [currentChilds, nextChilds] = splitNodes(\n    contentArea,\n    dynamicPage.children,\n  );\n\n  const currentPage = R.compose(\n    relayoutPage,\n    assingChildren(currentChilds),\n    R.assocPath(['box', 'height'], height),\n  )(page);\n\n  if (R.isEmpty(nextChilds) || allFixed(nextChilds)) return [currentPage, null];\n\n  const nextPage = R.compose(\n    relayoutPage,\n    assingChildren(nextChilds),\n    R.dissocPath(['box', 'height']),\n  )(page);\n\n  return [currentPage, nextPage];\n};\n\nconst shouldResolveDynamicNodes = node =>\n  R.either(\n    isDynamic,\n    R.compose(\n      R.any(shouldResolveDynamicNodes),\n      R.propOr([], 'children'),\n    ),\n  )(node);\n\nconst resolveDynamicPage = (props, page) =>\n  R.when(\n    shouldResolveDynamicNodes,\n    R.compose(\n      relayoutPage,\n      resolveDynamicNodes(props),\n    ),\n  )(page);\n\nconst resolveDynamicNodes = props => node => {\n  const isNodeDynamic = R.always(isDynamic(node));\n\n  const resolveRender = () => {\n    const res = node.props.render(props);\n    return [createInstance(res)];\n  };\n\n  return R.evolve(\n    {\n      children: R.ifElse(\n        isNodeDynamic,\n        resolveRender,\n        R.map(resolveDynamicNodes(props)),\n      ),\n      lines: R.when(isNodeDynamic, R.always([])),\n    },\n    node,\n  );\n};\n\nconst paginate = (page, pageNumber) => {\n  if (!page) return [];\n\n  let splittedPage = splitPage(page, pageNumber);\n\n  const pages = [splittedPage[0]];\n  let nextPage = splittedPage[1];\n\n  while (nextPage !== null) {\n    splittedPage = splitPage(nextPage, pageNumber + pages.length);\n\n    pages.push(splittedPage[0]);\n    nextPage = splittedPage[1];\n  }\n\n  return pages;\n};\n\nconst resolvePageIndices = (page, pageNumber, pages) => {\n  const totalPages = pages.length;\n  return resolveDynamicPage({ pageNumber: pageNumber + 1, totalPages }, page);\n};\n\nconst resolvePagination = doc => {\n  let pages = [];\n  let pageNumber = 1;\n\n  for (let i = 0; i < doc.children.length; i++) {\n    const page = doc.children[i];\n    const subpages = paginate(page, pageNumber);\n\n    pageNumber += subpages.length;\n    pages = pages.concat(subpages);\n  }\n\n  pages = pages.map(resolvePageIndices);\n\n  return assingChildren(pages, doc);\n};\n\nexport default resolvePagination;\n","import * as R from 'ramda';\n\n/**\n * Removes margins on node\n *\n * @param {Object} node\n * @returns {Object} node without margins\n */\nconst removeMargins = R.compose(\n  R.dissocPath(['style', 'margin']),\n  R.dissocPath(['style', 'marginTop']),\n  R.dissocPath(['style', 'marginRight']),\n  R.dissocPath(['style', 'marginBottom']),\n  R.dissocPath(['style', 'marginLeft']),\n  R.dissocPath(['style', 'marginHorizontal']),\n  R.dissocPath(['style', 'marginVertical']),\n);\n\nexport default removeMargins;\n","import * as R from 'ramda';\n\nimport removeMargins from '../node/removeMargins';\n\n/**\n * Remove page margins\n *\n * @param {Object} document root\n * @returns {Object} document root without margins on pages\n */\nconst resolvePageMargins = R.evolve({\n  children: R.map(removeMargins),\n});\n\nexport default resolvePageMargins;\n","import * as R from 'ramda';\n\nimport isNote from '../node/isNote';\nimport isTextInstance from '../node/isTextInstance';\n\n/**\n * Get node underlying text value\n *\n * @param {Object} node\n * @returns {String} node text content\n */\nconst getNodeText = node =>\n  R.cond([\n    [R.is(String), R.identity],\n    [isTextInstance, R.prop('value')],\n    [\n      R.T,\n      R.compose(\n        getNodesText,\n        R.propOr([], 'children'),\n      ),\n    ],\n  ])(node);\n\n/**\n * Get underlying text value of several nodes\n *\n * @param {Array} nodes\n * @returns {String} nodes text content\n */\nconst getNodesText = R.compose(\n  R.join(''),\n  R.map(getNodeText),\n);\n\n/**\n * Transforms string to text instance\n *\n * @param {String} value\n * @returns {Array} text intance\n */\nconst wrapTextInstance = value => [{ type: 'TEXT_INSTANCE', value }];\n\n/**\n * Cast Note children as a text instance\n *\n * @param {Object} node\n * @returns {Object} node with resolved note children\n */\nconst resolveNoteChildren = node =>\n  R.ifElse(\n    isNote,\n    R.evolve({\n      children: R.compose(\n        wrapTextInstance,\n        getNodesText,\n      ),\n    }),\n    R.evolve({ children: R.map(resolveNoteChildren) }),\n  )(node);\n\nexport default resolveNoteChildren;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/*\n * Translates page percentage horizontal paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nconst resolvePageHorizontalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.width : value;\n};\n\n/**\n * Translates page percentage vertical paddings in fixed ones\n *\n * @param {Object} page container\n * @param {String} padding value\n * @returns {Object} translated padding value\n */\nconst resolvePageVerticalPadding = container => value => {\n  const match = matchPercent(value);\n  return match ? match.percent * container.height : value;\n};\n\n/**\n * Translates page percentage paddings in fixed ones\n *\n * @param {Object} page\n * @returns {Object} page with fixed paddings\n */\nconst resolvePagePaddings = page => {\n  const container = R.pathOr({}, ['props', 'size'], page);\n\n  return R.evolve({\n    style: R.evolve({\n      paddingLeft: resolvePageHorizontalPadding(container),\n      paddingRight: resolvePageHorizontalPadding(container),\n      paddingTop: resolvePageVerticalPadding(container),\n      paddingBottom: resolvePageVerticalPadding(container),\n    }),\n  })(page);\n};\n\n/**\n * Translates all pages percentage paddings in fixed ones\n * This has to be computed from pages calculated size and not by Yoga\n * because at this point we didn't performed pagination yet.\n *\n * @param {Object} document root\n * @returns {Object} document root with translated page paddings\n */\nexport default R.evolve({\n  children: R.map(resolvePagePaddings),\n});\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/**\n *\n * @param {Object} container width and height\n * @param {String | Number} value border radius value\n * @returns {Number} fixed border radius value\n */\nconst resolveRadius = container => value => {\n  const match = matchPercent(value);\n  return match\n    ? match.percent * Math.min(container.width, container.height)\n    : value;\n};\n\n/**\n * Transforms percent border radius into fixed values\n *\n * @param {Object} node\n * @returns {Object} node\n */\nconst resolvePercentRadius = node =>\n  R.evolve({\n    children: R.map(resolvePercentRadius),\n    style: R.evolve({\n      borderTopLeftRadius: resolveRadius(node.box),\n      borderTopRightRadius: resolveRadius(node.box),\n      borderBottomRightRadius: resolveRadius(node.box),\n      borderBottomLeftRadius: resolveRadius(node.box),\n    }),\n  })(node);\n\nexport default resolvePercentRadius;\n","import * as R from 'ramda';\n\nimport matchPercent from '../utils/matchPercent';\n\n/**\n * Transform percent height into fixed\n *\n * @param {String | number} height\n * @return {number} height\n */\nconst transformHeight = pageArea => height => {\n  const match = matchPercent(height);\n  return match ? match.percent * pageArea : height;\n};\n\n/**\n * Get page area (height minus paddings)\n *\n * @param {Object} page\n * @return {number} page area\n */\nconst getPageArea = page => {\n  const pageHeight = R.path(['style', 'height'], page);\n  const pagePaddingTop = R.pathOr(0, ['style', 'paddingTop'], page);\n  const pagePaddingBottom = R.pathOr(0, ['style', 'paddingBottom'], page);\n  return pageHeight - pagePaddingTop - pagePaddingBottom;\n};\n\n/**\n * Checks if page has height\n *\n * @param {Object} page\n * @return {boolean} page has height\n */\nconst hasHeight = R.hasPath(['style', 'height']);\n\n/**\n * Transform node percent height to fixed\n *\n * @param {Object} page\n * @param {Object} node\n * @return {Object} transformed node\n */\nconst resolveNodePercentHeight = page => node => {\n  if (hasHeight(page)) {\n    const pageArea = getPageArea(page);\n    return R.evolve({ style: { height: transformHeight(pageArea) } })(node);\n  }\n\n  return node;\n};\n\n/**\n * Transform page immediate children with percent height to fixed\n *\n * @param {Object} page\n * @return {Object} transformed page\n */\nconst resolvePagePercentHeight = page =>\n  R.evolve({\n    children: R.map(resolveNodePercentHeight(page)),\n  })(page);\n\n/**\n * Transform all page immediate children with percent height to fixed\n *\n * @param {Object} document root\n * @return {Object} transformed document root\n */\nconst resolvePercentHeight = R.evolve({\n  children: R.map(resolvePagePercentHeight),\n});\n\nexport default resolvePercentHeight;\n","import * as R from 'ramda';\n\nimport { TEXT } from '../constants';\nimport isLink from '../node/isLink';\nimport isTextInstance from '../node/isTextInstance';\n\n/**\n * Checks if node has render prop\n *\n * @param {Object} node\n * @returns {Boolean} has render prop?\n */\nconst hasRenderProp = R.hasPath(['props', 'render']);\n\n/**\n * Checks if all children of node are text instances\n *\n * @param {Object} node\n * @returns {Boolean} are all children text instances?\n */\nconst hasTextInstanceChilds = R.compose(\n  R.all(isTextInstance),\n  R.propOr([], 'children'),\n);\n\n/**\n * If the Link has a string child or render prop, substitute the instance by a Text,\n * that will ultimately render the inline Link via the textkit PDF renderer.\n *\n * @param {Object} node\n * @returns {Object} node with link substitution\n */\nconst resolveLinkSubstitution = node =>\n  R.evolve({\n    children: R.map(\n      R.ifElse(\n        R.both(isLink, R.either(hasRenderProp, hasTextInstanceChilds)),\n        R.assoc('type', TEXT),\n        resolveLinkSubstitution,\n      ),\n    ),\n  })(node);\n\nexport default resolveLinkSubstitution;\n","import * as R from 'ramda';\n\n/**\n * Performs right-to-left function composition with async functions support\n *\n * @param  {...any} functions\n */\nconst asyncCompose = (...fns) => async value => {\n  for (const fn of R.reverse(fns)) value = await fn(value);\n  return value;\n};\n\nexport default asyncCompose;\n","// import * as R from 'ramda';\n\nimport resolveSvg from './resolveSvg';\nimport resolveZIndex from './resolveZIndex';\nimport resolveRulers from './resolveRulers';\nimport resolveAssets from './resolveAssets';\nimport resolveStyles from './resolveStyles';\nimport resolveOrigins from './resolveOrigins';\nimport resolvePageSizes from './resolvePageSizes';\nimport resolvePagination from './resolvePagination';\nimport resolveDimensions from './resolveDimensions';\nimport resolveTextLayout from './resolveTextLayout';\nimport resolveInheritance from './resolveInheritance';\nimport resolvePageMargins from './resolvePageMargins';\nimport resolveNoteChildren from './resolveNoteChildren';\nimport resolvePagePaddings from './resolvePagePaddings';\nimport resolvePercentRadius from './resolvePercentRadius';\nimport resolvePercentHeight from './resolvePercentHeight';\nimport resolveLinkSubstitution from './resolveLinkSubstitution';\nimport asyncCompose from '../utils/asyncCompose';\n\n// const startTimer = name => R.tap(() => console.time(name));\n// const endTimer = name => R.tap(() => console.timeEnd(name));\n\nconst layout = asyncCompose(\n  resolveZIndex,\n  resolveRulers,\n  resolveOrigins,\n  resolvePagination,\n  resolveTextLayout,\n  resolvePercentRadius,\n  resolveDimensions,\n  resolveSvg,\n  resolveAssets,\n  resolveInheritance,\n  resolvePercentHeight,\n  resolvePagePaddings,\n  resolveStyles,\n  resolveNoteChildren,\n  resolveLinkSubstitution,\n  resolvePageMargins,\n  resolvePageSizes,\n);\n\nexport default layout;\n","/**\n * Checks if two sets of props are equal (recursively)\n *\n * @param {Object} props A\n * @param {Object} props B\n * @returns {Boolean} props equals?\n *\n */\nconst propsEqual = (a, b) => {\n  const oldPropsKeys = Object.keys(a);\n  const newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < oldPropsKeys.length; i++) {\n    const propName = oldPropsKeys[i];\n\n    if (propName === 'render') {\n      if (!a[propName] !== !b[propName]) {\n        return false;\n      }\n      continue;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (\n        typeof a[propName] === 'object' &&\n        typeof b[propName] === 'object' &&\n        propsEqual(a[propName], b[propName])\n      ) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (\n      propName === 'children' &&\n      (typeof a[propName] === 'string' || typeof b[propName] === 'string')\n    ) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nexport default propsEqual;\n","'use strict';\n\nimport ReactFiberReconciler from 'react-reconciler';\nimport {\n  unstable_scheduleCallback as schedulePassiveEffects,\n  unstable_cancelCallback as cancelPassiveEffects,\n} from 'scheduler';\n\nimport propsEqual from './utils/propsEqual';\n\nconst emptyObject = {};\n\nconst createRenderer = ({ onChange = () => {} }) => {\n  return ReactFiberReconciler({\n    schedulePassiveEffects,\n\n    cancelPassiveEffects,\n\n    supportsMutation: true,\n\n    isPrimaryRenderer: false,\n\n    warnsIfNotActing: false,\n\n    appendInitialChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n\n    createInstance(type, { style, children, ...props }) {\n      return {\n        type,\n        box: {},\n        style: style || {},\n        props: props || {},\n        children: [],\n      };\n    },\n\n    createTextInstance(text, rootContainerInstance) {\n      return { type: 'TEXT_INSTANCE', value: text };\n    },\n\n    finalizeInitialChildren(element, type, props) {\n      return false;\n    },\n\n    getPublicInstance(instance) {\n      return instance;\n    },\n\n    prepareForCommit() {\n      // Noop\n    },\n\n    prepareUpdate(element, type, oldProps, newProps) {\n      return !propsEqual(oldProps, newProps);\n    },\n\n    resetAfterCommit: onChange,\n\n    resetTextContent(element) {\n      // Noop\n    },\n\n    getRootHostContext() {\n      return emptyObject;\n    },\n\n    getChildHostContext() {\n      return emptyObject;\n    },\n\n    shouldSetTextContent(type, props) {\n      return false;\n    },\n\n    now: Date.now,\n\n    useSyncScheduling: true,\n\n    appendChild(parentInstance, child) {\n      parentInstance.children.push(child);\n    },\n\n    appendChildToContainer(parentInstance, child) {\n      if (parentInstance.type === 'ROOT') {\n        parentInstance.document = child;\n      } else {\n        parentInstance.children.push(child);\n      }\n    },\n\n    insertBefore(parentInstance, child, beforeChild) {\n      const index = parentInstance.children.indexOf(beforeChild);\n      if (index !== -1 && child)\n        parentInstance.children.splice(index, 0, child);\n    },\n\n    removeChild(parentInstance, child) {\n      const index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n\n    removeChildFromContainer(parentInstance, child) {\n      const index = parentInstance.children.indexOf(child);\n      if (index !== -1) parentInstance.children.splice(index, 1);\n    },\n\n    commitTextUpdate(textInstance, oldText, newText) {\n      textInstance.value = newText;\n    },\n\n    commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n      const { style, ...props } = newProps;\n      instance.props = props;\n      instance.style = style;\n    },\n  });\n};\n\nexport default createRenderer;\n","import flatten from './flatten';\n\nconst create = styles => styles;\n\nconst absoluteFillObject = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0,\n};\n\nexport default {\n  hairlineWidth: 1,\n  create,\n  flatten,\n  absoluteFillObject,\n};\n","import BlobStream from 'blob-stream';\nimport PDFDocument from '@react-pdf/pdfkit';\n\nimport Font from './font';\nimport renderPDF from './render';\nimport layoutDocument from './layout';\nimport createRenderer from './renderer';\nimport StyleSheet from './stylesheet';\nimport { version } from '../package.json';\nimport {\n  VIEW,\n  TEXT,\n  LINK,\n  PAGE,\n  NOTE,\n  IMAGE,\n  DOCUMENT,\n  CANVAS,\n  SVG,\n  GROUP,\n  PATH,\n  RECT,\n  LINE,\n  CIRCLE,\n  ELLIPSE,\n  POLYGON,\n  POLYLINE,\n  DEFS,\n  TSPAN,\n  CLIP_PATH,\n  STOP,\n  LINEAR_GRADIENT,\n  RADIAL_GRADIENT,\n} from './constants';\n\nconst View = VIEW;\nconst Text = TEXT;\nconst Link = LINK;\nconst Page = PAGE;\nconst Note = NOTE;\nconst Image = IMAGE;\nconst Document = DOCUMENT;\nconst Canvas = CANVAS;\nconst Svg = SVG;\nconst G = GROUP;\nconst Path = PATH;\nconst Rect = RECT;\nconst Line = LINE;\nconst Circle = CIRCLE;\nconst Ellipse = ELLIPSE;\nconst Polygon = POLYGON;\nconst Polyline = POLYLINE;\nconst Defs = DEFS;\nconst Tspan = TSPAN;\nconst ClipPath = CLIP_PATH;\nconst Stop = STOP;\nconst LinearGradient = LINEAR_GRADIENT;\nconst RadialGradient = RADIAL_GRADIENT;\n\nconst pdf = ({ initialValue, onChange }) => {\n  const container = { type: 'ROOT', document: null };\n  const PDFRenderer = createRenderer({ onChange });\n  const mountNode = PDFRenderer.createContainer(container);\n\n  if (initialValue) updateContainer(initialValue);\n\n  const render = async () => {\n    const ctx = new PDFDocument({ autoFirstPage: false });\n\n    console.time('layout');\n    const layout = await layoutDocument(container.document);\n    console.timeEnd('layout');\n\n    return renderPDF(ctx, layout);\n  };\n\n  const layout = async () => {\n    return layoutDocument(container);\n  };\n\n  function updateContainer(doc) {\n    PDFRenderer.updateContainer(doc, mountNode, null);\n  }\n\n  function callOnRender(params = {}) {\n    if (container.document.props.onRender) {\n      container.document.props.onRender(params);\n    }\n  }\n\n  async function toBlob() {\n    const instance = await render();\n    const stream = instance.pipe(BlobStream());\n\n    return new Promise((resolve, reject) => {\n      stream.on('finish', () => {\n        try {\n          const blob = stream.toBlob('application/pdf');\n          callOnRender({ blob });\n          resolve(blob);\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      stream.on('error', reject);\n    });\n  }\n\n  async function toBuffer() {\n    callOnRender();\n    return render();\n  }\n\n  function toString() {\n    let result = '';\n    const instance = render();\n\n    return new Promise((resolve, reject) => {\n      try {\n        instance.on('data', function(buffer) {\n          result += buffer;\n        });\n\n        instance.on('end', function() {\n          resolve(result);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    layout,\n    container,\n    updateContainer,\n    toBuffer,\n    toBlob,\n    toString,\n  };\n};\n\nexport {\n  version,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Document,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Defs,\n  Tspan,\n  ClipPath,\n  Polyline,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  StyleSheet,\n  pdf,\n};\n","import React from 'react';\n\nconst svgpath = require('svgpath');\n\nimport { pdf } from './index';\n\nconst queue = require('queue');\n\nconst canvasInstance = canvas => {\n  const instance = {};\n  const images = {};\n  const ctx = canvas.getContext('2d');\n\n  let fillColor = 'white';\n\n  const nil = () => {\n    return instance;\n  };\n\n  instance.info = {};\n  instance.end = nil;\n  instance.font = nil;\n\n  instance.translate = (x, y) => {\n    ctx.translate(x, y);\n    return instance;\n  };\n\n  instance.addPage = ({ size }) => {\n    canvas.width = size[0];\n    canvas.height = size[1];\n\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  instance.save = () => {\n    ctx.save();\n    return instance;\n  };\n\n  instance.restore = () => {\n    ctx.restore();\n    return instance;\n  };\n\n  instance.moveTo = (x, y) => {\n    ctx.moveTo(x, y);\n    return instance;\n  };\n\n  instance.lineTo = (x, y) => {\n    ctx.lineTo(x, y);\n    return instance;\n  };\n\n  instance.bezierCurveTo = (a, b, c, d, e, f) => {\n    ctx.bezierCurveTo(a, b, c, d, e, f);\n    return instance;\n  };\n\n  instance.closePath = () => {\n    ctx.closePath();\n    return instance;\n  };\n\n  instance.clip = () => {\n    ctx.clip();\n    return instance;\n  };\n\n  instance.fillColor = color => {\n    fillColor = color;\n    return instance;\n  };\n\n  instance.rect = (a, b, c, d) => {\n    ctx.rect(a, b, c, d);\n    return instance;\n  };\n\n  instance.fill = () => {\n    ctx.fillStyle = fillColor;\n    ctx.fill();\n    return instance;\n  };\n\n  instance.fillOpacity = opacity => {\n    ctx.globalAlpha = opacity;\n    return instance;\n  };\n\n  instance._addGlyphs = (glyphs, positions) => {\n    let xAdvance = 0;\n    const fontSize = 20;\n    const unitsPerEm = 2048;\n\n    for (let i = 0; i < glyphs.length; i++) {\n      const glyph = glyphs[i];\n      const position = positions[i];\n\n      const path = svgpath(glyph.path.toSVG())\n        .scale(1, -1)\n        .scale(fontSize / unitsPerEm)\n        .translate(xAdvance, 0)\n        .toString();\n\n      xAdvance += position.xAdvance;\n\n      ctx.fillStyle = '#000';\n\n      const p = new Path2D(path);\n\n      ctx.stroke(p);\n      ctx.fill(p);\n    }\n\n    return instance;\n  };\n\n  instance.image = (data, x, y, { width, height }) => {\n    const base64Data = btoa(String.fromCharCode.apply(null, data));\n\n    if (images[base64Data]) {\n      ctx.drawImage(images[base64Data], x, y, width, height);\n    } else {\n      const img = document.createElement('img');\n      img.src = 'data:image/png;base64,' + base64Data;\n\n      images[base64Data] = img;\n\n      img.onload = () => {\n        ctx.drawImage(img, x, y, width, height);\n      };\n    }\n\n    return instance;\n  };\n\n  instance.clear = () => {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n  };\n\n  return instance;\n};\n\nexport class CanvasViewer extends React.Component {\n  ctx = null;\n  instance = pdf();\n  renderQueue = queue({ autostart: true, concurrency: 1 });\n  state = { layout: null, error: null };\n\n  componentDidMount() {\n    this.ctx = canvasInstance(this.canvas);\n    this.queueDocumentRender(this.props.children);\n\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  }\n\n  componentDidUpdate(prevProps) {\n    if (prevProps.children !== this.props.children) {\n      this.queueDocumentRender(this.props.children);\n    }\n  }\n\n  componentWillUnmount() {\n    this.renderQueue.end();\n  }\n\n  queueDocumentRender(doc) {\n    this.renderQueue.splice(0, this.renderQueue.length, () => {\n      this.instance.updateContainer(doc);\n\n      if (this.instance.isDirty() && !this.state.error) {\n        return this.instance.renderWithContext(this.ctx);\n      }\n\n      return Promise.resolve();\n    });\n  }\n\n  onRenderFailed = error => {\n    this.setState({ error });\n    console.error(error);\n  };\n\n  onRenderSuccessful = layout => {\n    this.setState({ layout });\n  };\n\n  render() {\n    return (\n      <canvas\n        height={900}\n        id=\"myCanvas\"\n        ref={ref => (this.canvas = ref)}\n        style={{ border: '1px solid black' }}\n        width={900}\n      />\n    );\n  }\n}\n","/* eslint-disable no-unused-vars */\nimport React from 'react';\nimport { CanvasViewer } from './canvas';\n\nimport warning from '../src/utils/warning';\n\nconst queue = require('queue');\n\nimport {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Polyline,\n  Defs,\n  Tspan,\n  ClipPath,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  version,\n  StyleSheet,\n  // createInstance,\n  Document as PDFDocument,\n} from './index';\n\nconst flatStyles = stylesArray =>\n  stylesArray.reduce((acc, style) => ({ ...acc, ...style }), {});\n\nexport const Document = ({ children, ...props }) => {\n  return <PDFDocument {...props}>{children}</PDFDocument>;\n};\n\nclass InternalBlobProvider extends React.PureComponent {\n  renderQueue = queue({ autostart: true, concurrency: 1 });\n  state = { blob: null, url: null, loading: true, error: null };\n\n  componentDidMount() {\n    this.instance = pdf({ onChange: this.queueDocumentRender });\n    this.instance.updateContainer(this.props.document);\n\n    this.renderQueue.on('error', this.onRenderFailed);\n    this.renderQueue.on('success', this.onRenderSuccessful);\n  }\n\n  componentDidUpdate() {\n    this.instance.updateContainer(this.props.document);\n  }\n\n  componentWillUnmount() {\n    this.renderQueue.end();\n  }\n\n  queueDocumentRender = () => {\n    this.renderQueue.splice(0, this.renderQueue.length, () =>\n      this.state.error ? Promise.resolve() : this.instance.toBlob(),\n    );\n  };\n\n  onRenderFailed = error => {\n    this.setState({ error });\n    console.error(error);\n  };\n\n  onRenderSuccessful = blob => {\n    const oldBlobUrl = this.state.url;\n\n    this.setState(\n      { blob, url: URL.createObjectURL(blob), loading: false },\n      () => URL.revokeObjectURL(oldBlobUrl),\n    );\n  };\n\n  render() {\n    return this.props.children(this.state);\n  }\n}\n\nexport const BlobProvider = ({ document: doc, children }) => {\n  if (!doc) {\n    warning(false, 'You should pass a valid document to BlobProvider');\n    return null;\n  }\n\n  return <InternalBlobProvider document={doc}>{children}</InternalBlobProvider>;\n};\n\nexport const PDFViewer = ({\n  className,\n  style,\n  children,\n  innerRef,\n  ...props\n}) => {\n  return (\n    <InternalBlobProvider document={children}>\n      {({ url }) => (\n        <iframe\n          className={className}\n          ref={innerRef}\n          src={url}\n          style={Array.isArray(style) ? flatStyles(style) : style}\n          {...props}\n        />\n      )}\n    </InternalBlobProvider>\n  );\n};\n\nexport const PDFDownloadLink = ({\n  document: doc,\n  className,\n  style,\n  children,\n  fileName = 'document.pdf',\n}) => {\n  if (!doc) {\n    warning(false, 'You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n\n  const downloadOnIE = blob => () => {\n    if (window.navigator.msSaveBlob) {\n      window.navigator.msSaveBlob(blob, fileName);\n    }\n  };\n\n  return (\n    <InternalBlobProvider document={doc}>\n      {params => (\n        <a\n          className={className}\n          download={fileName}\n          href={params.url}\n          onClick={downloadOnIE(params.blob)}\n          style={Array.isArray(style) ? flatStyles(style) : style}\n        >\n          {typeof children === 'function' ? children(params) : children}\n        </a>\n      )}\n    </InternalBlobProvider>\n  );\n};\n\nexport {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Polyline,\n  Defs,\n  Tspan,\n  ClipPath,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  version,\n  StyleSheet,\n} from './index';\n\nexport { CanvasViewer } from './canvas';\n\nexport default {\n  pdf,\n  View,\n  Text,\n  Link,\n  Page,\n  Font,\n  Note,\n  Image,\n  Canvas,\n  Svg,\n  G,\n  Path,\n  Rect,\n  Line,\n  Circle,\n  Ellipse,\n  Polygon,\n  Polyline,\n  Defs,\n  Tspan,\n  ClipPath,\n  Stop,\n  LinearGradient,\n  RadialGradient,\n  version,\n  Document,\n  PDFViewer,\n  StyleSheet,\n  CanvasViewer,\n  BlobProvider,\n  PDFDownloadLink,\n};\n"]},"metadata":{},"sourceType":"module"}