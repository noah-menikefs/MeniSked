{"ast":null,"code":"'use strict';\n\nvar paramCounts = {\n  a: 7,\n  c: 6,\n  h: 1,\n  l: 2,\n  m: 2,\n  r: 4,\n  q: 4,\n  s: 4,\n  t: 2,\n  v: 1,\n  z: 0\n};\nvar SPECIAL_SPACES = [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];\n\nfunction isSpace(ch) {\n  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029 || // Line terminators\n  // White spaces\n  ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0;\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D\n    /* m */\n    :\n    case 0x7A\n    /* z */\n    :\n    case 0x6C\n    /* l */\n    :\n    case 0x68\n    /* h */\n    :\n    case 0x76\n    /* v */\n    :\n    case 0x63\n    /* c */\n    :\n    case 0x73\n    /* s */\n    :\n    case 0x71\n    /* q */\n    :\n    case 0x74\n    /* t */\n    :\n    case 0x61\n    /* a */\n    :\n    case 0x72\n    /* r */\n    :\n      return true;\n  }\n\n  return false;\n}\n\nfunction isArc(code) {\n  return (code | 0x20) === 0x61;\n}\n\nfunction isDigit(code) {\n  return code >= 48 && code <= 57; // 0..9\n}\n\nfunction isDigitStart(code) {\n  return code >= 48 && code <= 57 ||\n  /* 0..9 */\n  code === 0x2B ||\n  /* + */\n  code === 0x2D ||\n  /* - */\n  code === 0x2E;\n  /* . */\n}\n\nfunction State(path) {\n  this.index = 0;\n  this.path = path;\n  this.max = path.length;\n  this.result = [];\n  this.param = 0.0;\n  this.err = '';\n  this.segmentStart = 0;\n  this.data = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\nfunction scanFlag(state) {\n  var ch = state.path.charCodeAt(state.index);\n\n  if (ch === 0x30\n  /* 0 */\n  ) {\n      state.param = 0;\n      state.index++;\n      return;\n    }\n\n  if (ch === 0x31\n  /* 1 */\n  ) {\n      state.param = 1;\n      state.index++;\n      return;\n    }\n\n  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';\n}\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B\n  /* + */\n  || ch === 0x2D\n  /* - */\n  ) {\n      index++;\n      ch = index < max ? state.path.charCodeAt(index) : 0;\n    } // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n\n\n  if (!isDigit(ch) && ch !== 0x2E\n  /* . */\n  ) {\n      state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n      return;\n    }\n\n  if (ch !== 0x2E\n  /* . */\n  ) {\n      zeroFirst = ch === 0x30\n      /* 0 */\n      ;\n      index++;\n      ch = index < max ? state.path.charCodeAt(index) : 0;\n\n      if (zeroFirst && index < max) {\n        // decimal number starts with '0' such as '09' is illegal.\n        if (ch && isDigit(ch)) {\n          state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';\n          return;\n        }\n      }\n\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n        hasCeiling = true;\n      }\n\n      ch = index < max ? state.path.charCodeAt(index) : 0;\n    }\n\n  if (ch === 0x2E\n  /* . */\n  ) {\n      hasDot = true;\n      index++;\n\n      while (isDigit(state.path.charCodeAt(index))) {\n        index++;\n        hasDecimal = true;\n      }\n\n      ch = index < max ? state.path.charCodeAt(index) : 0;\n    }\n\n  if (ch === 0x65\n  /* e */\n  || ch === 0x45\n  /* E */\n  ) {\n      if (hasDot && !hasCeiling && !hasDecimal) {\n        state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n        return;\n      }\n\n      index++;\n      ch = index < max ? state.path.charCodeAt(index) : 0;\n\n      if (ch === 0x2B\n      /* + */\n      || ch === 0x2D\n      /* - */\n      ) {\n          index++;\n        }\n\n      if (index < max && isDigit(state.path.charCodeAt(index))) {\n        while (index < max && isDigit(state.path.charCodeAt(index))) {\n          index++;\n        }\n      } else {\n        state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n        return;\n      }\n    }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC; // Process duplicated commands (without comand name)\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n\n  cmd = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([cmd, params[0], params[1]]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = cmd === 'm' ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([cmd].concat(params));\n  } else {\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([cmd].concat(params.splice(0, paramCounts[cmdLC])));\n\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\nfunction scanSegment(state) {\n  var max = state.max,\n      cmdCode,\n      is_arc,\n      comma_found,\n      need_params,\n      i;\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n  is_arc = isArc(cmdCode);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n  state.index++;\n  skipSpaces(state);\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      if (is_arc && (i === 3 || i === 4)) scanFlag(state);else scanParam(state);\n\n      if (state.err.length) {\n        return;\n      }\n\n      state.data.push(state.param);\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C\n      /* , */\n      ) {\n          state.index++;\n          skipSpaces(state);\n          comma_found = true;\n        }\n    } // after ',' param is mandatory\n\n\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    } // Stop on next segment\n\n\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\n\n\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.err.length) {\n    state.result = [];\n  } else if (state.result.length) {\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};","map":{"version":3,"sources":["/Users/nikhil.ismail/Desktop/MeniSked/node_modules/svgpath/lib/path_parse.js"],"names":["paramCounts","a","c","h","l","m","r","q","s","t","v","z","SPECIAL_SPACES","isSpace","ch","indexOf","isCommand","code","isArc","isDigit","isDigitStart","State","path","index","max","length","result","param","err","segmentStart","data","skipSpaces","state","charCodeAt","scanFlag","scanParam","start","zeroFirst","hasCeiling","hasDecimal","hasDot","parseFloat","slice","finalizeSegment","cmd","cmdLC","toLowerCase","params","push","concat","splice","scanSegment","cmdCode","is_arc","comma_found","need_params","i","module","exports","pathParse","svgPath","segments"],"mappings":"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","sourcesContent":["'use strict';\n\n\nvar paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, r: 4, q: 4, s: 4, t: 2, v: 1, z: 0 };\n\nvar SPECIAL_SPACES = [\n  0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006,\n  0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF\n];\n\nfunction isSpace(ch) {\n  return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029) || // Line terminators\n    // White spaces\n    (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n    (ch >= 0x1680 && SPECIAL_SPACES.indexOf(ch) >= 0);\n}\n\nfunction isCommand(code) {\n  /*eslint-disable no-bitwise*/\n  switch (code | 0x20) {\n    case 0x6D/* m */:\n    case 0x7A/* z */:\n    case 0x6C/* l */:\n    case 0x68/* h */:\n    case 0x76/* v */:\n    case 0x63/* c */:\n    case 0x73/* s */:\n    case 0x71/* q */:\n    case 0x74/* t */:\n    case 0x61/* a */:\n    case 0x72/* r */:\n      return true;\n  }\n  return false;\n}\n\nfunction isArc(code) {\n  return (code | 0x20) === 0x61;\n}\n\nfunction isDigit(code) {\n  return (code >= 48 && code <= 57);   // 0..9\n}\n\nfunction isDigitStart(code) {\n  return (code >= 48 && code <= 57) || /* 0..9 */\n          code === 0x2B || /* + */\n          code === 0x2D || /* - */\n          code === 0x2E;   /* . */\n}\n\n\nfunction State(path) {\n  this.index  = 0;\n  this.path   = path;\n  this.max    = path.length;\n  this.result = [];\n  this.param  = 0.0;\n  this.err    = '';\n  this.segmentStart = 0;\n  this.data   = [];\n}\n\nfunction skipSpaces(state) {\n  while (state.index < state.max && isSpace(state.path.charCodeAt(state.index))) {\n    state.index++;\n  }\n}\n\n\nfunction scanFlag(state) {\n  var ch = state.path.charCodeAt(state.index);\n\n  if (ch === 0x30/* 0 */) {\n    state.param = 0;\n    state.index++;\n    return;\n  }\n\n  if (ch === 0x31/* 1 */) {\n    state.param = 1;\n    state.index++;\n    return;\n  }\n\n  state.err = 'SvgPath: arc flag can be 0 or 1 only (at pos ' + state.index + ')';\n}\n\n\nfunction scanParam(state) {\n  var start = state.index,\n      index = start,\n      max = state.max,\n      zeroFirst = false,\n      hasCeiling = false,\n      hasDecimal = false,\n      hasDot = false,\n      ch;\n\n  if (index >= max) {\n    state.err = 'SvgPath: missed param (at pos ' + index + ')';\n    return;\n  }\n  ch = state.path.charCodeAt(index);\n\n  if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n    index++;\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  // This logic is shamelessly borrowed from Esprima\n  // https://github.com/ariya/esprimas\n  //\n  if (!isDigit(ch) && ch !== 0x2E/* . */) {\n    state.err = 'SvgPath: param should start with 0..9 or `.` (at pos ' + index + ')';\n    return;\n  }\n\n  if (ch !== 0x2E/* . */) {\n    zeroFirst = (ch === 0x30/* 0 */);\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n\n    if (zeroFirst && index < max) {\n      // decimal number starts with '0' such as '09' is illegal.\n      if (ch && isDigit(ch)) {\n        state.err = 'SvgPath: numbers started with `0` such as `09` are illegal (at pos ' + start + ')';\n        return;\n      }\n    }\n\n    while (index < max && isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasCeiling = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x2E/* . */) {\n    hasDot = true;\n    index++;\n    while (isDigit(state.path.charCodeAt(index))) {\n      index++;\n      hasDecimal = true;\n    }\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n  }\n\n  if (ch === 0x65/* e */ || ch === 0x45/* E */) {\n    if (hasDot && !hasCeiling && !hasDecimal) {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n\n    index++;\n\n    ch = (index < max) ? state.path.charCodeAt(index) : 0;\n    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n      index++;\n    }\n    if (index < max && isDigit(state.path.charCodeAt(index))) {\n      while (index < max && isDigit(state.path.charCodeAt(index))) {\n        index++;\n      }\n    } else {\n      state.err = 'SvgPath: invalid float exponent (at pos ' + index + ')';\n      return;\n    }\n  }\n\n  state.index = index;\n  state.param = parseFloat(state.path.slice(start, index)) + 0.0;\n}\n\n\nfunction finalizeSegment(state) {\n  var cmd, cmdLC;\n\n  // Process duplicated commands (without comand name)\n\n  // This logic is shamelessly borrowed from Raphael\n  // https://github.com/DmitryBaranovskiy/raphael/\n  //\n  cmd   = state.path[state.segmentStart];\n  cmdLC = cmd.toLowerCase();\n\n  var params = state.data;\n\n  if (cmdLC === 'm' && params.length > 2) {\n    state.result.push([ cmd, params[0], params[1] ]);\n    params = params.slice(2);\n    cmdLC = 'l';\n    cmd = (cmd === 'm') ? 'l' : 'L';\n  }\n\n  if (cmdLC === 'r') {\n    state.result.push([ cmd ].concat(params));\n  } else {\n\n    while (params.length >= paramCounts[cmdLC]) {\n      state.result.push([ cmd ].concat(params.splice(0, paramCounts[cmdLC])));\n      if (!paramCounts[cmdLC]) {\n        break;\n      }\n    }\n  }\n}\n\n\nfunction scanSegment(state) {\n  var max = state.max,\n      cmdCode, is_arc, comma_found, need_params, i;\n\n  state.segmentStart = state.index;\n  cmdCode = state.path.charCodeAt(state.index);\n  is_arc = isArc(cmdCode);\n\n  if (!isCommand(cmdCode)) {\n    state.err = 'SvgPath: bad command ' + state.path[state.index] + ' (at pos ' + state.index + ')';\n    return;\n  }\n\n  need_params = paramCounts[state.path[state.index].toLowerCase()];\n\n  state.index++;\n  skipSpaces(state);\n\n  state.data = [];\n\n  if (!need_params) {\n    // Z\n    finalizeSegment(state);\n    return;\n  }\n\n  comma_found = false;\n\n  for (;;) {\n    for (i = need_params; i > 0; i--) {\n      if (is_arc && (i === 3 || i === 4)) scanFlag(state);\n      else scanParam(state);\n\n      if (state.err.length) {\n        return;\n      }\n      state.data.push(state.param);\n\n      skipSpaces(state);\n      comma_found = false;\n\n      if (state.index < max && state.path.charCodeAt(state.index) === 0x2C/* , */) {\n        state.index++;\n        skipSpaces(state);\n        comma_found = true;\n      }\n    }\n\n    // after ',' param is mandatory\n    if (comma_found) {\n      continue;\n    }\n\n    if (state.index >= state.max) {\n      break;\n    }\n\n    // Stop on next segment\n    if (!isDigitStart(state.path.charCodeAt(state.index))) {\n      break;\n    }\n  }\n\n  finalizeSegment(state);\n}\n\n\n/* Returns array of segments:\n *\n * [\n *   [ command, coord1, coord2, ... ]\n * ]\n */\nmodule.exports = function pathParse(svgPath) {\n  var state = new State(svgPath);\n  var max = state.max;\n\n  skipSpaces(state);\n\n  while (state.index < max && !state.err.length) {\n    scanSegment(state);\n  }\n\n  if (state.err.length) {\n    state.result = [];\n\n  } else if (state.result.length) {\n\n    if ('mM'.indexOf(state.result[0][0]) < 0) {\n      state.err = 'SvgPath: string should start with `M` or `m`';\n      state.result = [];\n    } else {\n      state.result[0][0] = 'M';\n    }\n  }\n\n  return {\n    err: state.err,\n    segments: state.result\n  };\n};\n"]},"metadata":{},"sourceType":"script"}