{"ast":null,"code":"// Convert an arc to a sequence of cubic bézier curves\n//\n'use strict';\n\nvar TAU = Math.PI * 2;\n/* eslint-disable space-infix-ops */\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\n\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = ux * vy - uy * vx < 0 ? -1 : 1;\n  var dot = ux * vx + uy * vy; // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n\n  if (dot > 1.0) {\n    dot = 1.0;\n  }\n\n  if (dot < -1.0) {\n    dot = -1.0;\n  }\n\n  return sign * Math.acos(dot);\n} // Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\n\n\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;\n  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;\n  var rx_sq = rx * rx;\n  var ry_sq = ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p; // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n\n  var radicant = rx_sq * ry_sq - rx_sq * y1p_sq - ry_sq * x1p_sq;\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /= rx_sq * y1p_sq + ry_sq * x1p_sq;\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n  var cxp = radicant * rx / ry * y1p;\n  var cyp = radicant * -ry / rx * x1p; // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n\n  var cx = cos_phi * cxp - sin_phi * cyp + (x1 + x2) / 2;\n  var cy = sin_phi * cxp + cos_phi * cyp + (y1 + y2) / 2; // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n\n  var v1x = (x1p - cxp) / rx;\n  var v1y = (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [cx, cy, theta1, delta_theta];\n} //\n// Approximate one unit arc segment with bézier curves,\n// see http://math.stackexchange.com/questions/873224\n//\n\n\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4 / 3 * Math.tan(delta_theta / 4);\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n  return [x1, y1, x1 - y1 * alpha, y1 + x1 * alpha, x2 + y2 * alpha, y2 - x2 * alpha, x2, y2];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360); // Make sure radii are valid\n  //\n\n  var x1p = cos_phi * (x1 - x2) / 2 + sin_phi * (y1 - y2) / 2;\n  var y1p = -sin_phi * (x1 - x2) / 2 + cos_phi * (y1 - y2) / 2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  } // Compensate out-of-range radii\n  //\n\n\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n  var lambda = x1p * x1p / (rx * rx) + y1p * y1p / (ry * ry);\n\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  } // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n\n\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3]; // Split an arc to multiple segments, so each segment\n  // will be less than τ/4 (= 90°)\n  //\n\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  } // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n\n\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1]; // scale\n\n      x *= rx;\n      y *= ry; // rotate\n\n      var xp = cos_phi * x - sin_phi * y;\n      var yp = sin_phi * x + cos_phi * y; // translate\n\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};","map":{"version":3,"sources":["/Users/noah.menikefs/Desktop/menisked/MeniSked/node_modules/svgpath/lib/a2c.js"],"names":["TAU","Math","PI","unit_vector_angle","ux","uy","vx","vy","sign","dot","acos","get_arc_center","x1","y1","x2","y2","fa","fs","rx","ry","sin_phi","cos_phi","x1p","y1p","rx_sq","ry_sq","x1p_sq","y1p_sq","radicant","sqrt","cxp","cyp","cx","cy","v1x","v1y","v2x","v2y","theta1","delta_theta","approximate_unit_arc","alpha","tan","cos","sin","module","exports","a2c","phi","abs","lambda","cc","result","segments","max","ceil","i","push","map","curve","length","x","y","xp","yp"],"mappings":"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","sourcesContent":["// Convert an arc to a sequence of cubic bézier curves\n//\n'use strict';\n\n\nvar TAU = Math.PI * 2;\n\n\n/* eslint-disable space-infix-ops */\n\n// Calculate an angle between two unit vectors\n//\n// Since we measure angle between radii of circular arcs,\n// we can use simplified math (without length normalization)\n//\nfunction unit_vector_angle(ux, uy, vx, vy) {\n  var sign = (ux * vy - uy * vx < 0) ? -1 : 1;\n  var dot  = ux * vx + uy * vy;\n\n  // Add this to work with arbitrary vectors:\n  // dot /= Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);\n\n  // rounding errors, e.g. -1.0000000000000002 can screw up this\n  if (dot >  1.0) { dot =  1.0; }\n  if (dot < -1.0) { dot = -1.0; }\n\n  return sign * Math.acos(dot);\n}\n\n\n// Convert from endpoint to center parameterization,\n// see http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n//\n// Return [cx, cy, theta1, delta_theta]\n//\nfunction get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi) {\n  // Step 1.\n  //\n  // Moving an ellipse so origin will be the middlepoint between our two\n  // points. After that, rotate it to line up ellipse axes with coordinate\n  // axes.\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  var rx_sq  =  rx * rx;\n  var ry_sq  =  ry * ry;\n  var x1p_sq = x1p * x1p;\n  var y1p_sq = y1p * y1p;\n\n  // Step 2.\n  //\n  // Compute coordinates of the centre of this ellipse (cx', cy')\n  // in the new coordinate system.\n  //\n  var radicant = (rx_sq * ry_sq) - (rx_sq * y1p_sq) - (ry_sq * x1p_sq);\n\n  if (radicant < 0) {\n    // due to rounding errors it might be e.g. -1.3877787807814457e-17\n    radicant = 0;\n  }\n\n  radicant /=   (rx_sq * y1p_sq) + (ry_sq * x1p_sq);\n  radicant = Math.sqrt(radicant) * (fa === fs ? -1 : 1);\n\n  var cxp = radicant *  rx/ry * y1p;\n  var cyp = radicant * -ry/rx * x1p;\n\n  // Step 3.\n  //\n  // Transform back to get centre coordinates (cx, cy) in the original\n  // coordinate system.\n  //\n  var cx = cos_phi*cxp - sin_phi*cyp + (x1+x2)/2;\n  var cy = sin_phi*cxp + cos_phi*cyp + (y1+y2)/2;\n\n  // Step 4.\n  //\n  // Compute angles (theta1, delta_theta).\n  //\n  var v1x =  (x1p - cxp) / rx;\n  var v1y =  (y1p - cyp) / ry;\n  var v2x = (-x1p - cxp) / rx;\n  var v2y = (-y1p - cyp) / ry;\n\n  var theta1 = unit_vector_angle(1, 0, v1x, v1y);\n  var delta_theta = unit_vector_angle(v1x, v1y, v2x, v2y);\n\n  if (fs === 0 && delta_theta > 0) {\n    delta_theta -= TAU;\n  }\n  if (fs === 1 && delta_theta < 0) {\n    delta_theta += TAU;\n  }\n\n  return [ cx, cy, theta1, delta_theta ];\n}\n\n//\n// Approximate one unit arc segment with bézier curves,\n// see http://math.stackexchange.com/questions/873224\n//\nfunction approximate_unit_arc(theta1, delta_theta) {\n  var alpha = 4/3 * Math.tan(delta_theta/4);\n\n  var x1 = Math.cos(theta1);\n  var y1 = Math.sin(theta1);\n  var x2 = Math.cos(theta1 + delta_theta);\n  var y2 = Math.sin(theta1 + delta_theta);\n\n  return [ x1, y1, x1 - y1*alpha, y1 + x1*alpha, x2 + y2*alpha, y2 - x2*alpha, x2, y2 ];\n}\n\nmodule.exports = function a2c(x1, y1, x2, y2, fa, fs, rx, ry, phi) {\n  var sin_phi = Math.sin(phi * TAU / 360);\n  var cos_phi = Math.cos(phi * TAU / 360);\n\n  // Make sure radii are valid\n  //\n  var x1p =  cos_phi*(x1-x2)/2 + sin_phi*(y1-y2)/2;\n  var y1p = -sin_phi*(x1-x2)/2 + cos_phi*(y1-y2)/2;\n\n  if (x1p === 0 && y1p === 0) {\n    // we're asked to draw line to itself\n    return [];\n  }\n\n  if (rx === 0 || ry === 0) {\n    // one of the radii is zero\n    return [];\n  }\n\n\n  // Compensate out-of-range radii\n  //\n  rx = Math.abs(rx);\n  ry = Math.abs(ry);\n\n  var lambda = (x1p * x1p) / (rx * rx) + (y1p * y1p) / (ry * ry);\n  if (lambda > 1) {\n    rx *= Math.sqrt(lambda);\n    ry *= Math.sqrt(lambda);\n  }\n\n\n  // Get center parameters (cx, cy, theta1, delta_theta)\n  //\n  var cc = get_arc_center(x1, y1, x2, y2, fa, fs, rx, ry, sin_phi, cos_phi);\n\n  var result = [];\n  var theta1 = cc[2];\n  var delta_theta = cc[3];\n\n  // Split an arc to multiple segments, so each segment\n  // will be less than τ/4 (= 90°)\n  //\n  var segments = Math.max(Math.ceil(Math.abs(delta_theta) / (TAU / 4)), 1);\n  delta_theta /= segments;\n\n  for (var i = 0; i < segments; i++) {\n    result.push(approximate_unit_arc(theta1, delta_theta));\n    theta1 += delta_theta;\n  }\n\n  // We have a bezier approximation of a unit circle,\n  // now need to transform back to the original ellipse\n  //\n  return result.map(function (curve) {\n    for (var i = 0; i < curve.length; i += 2) {\n      var x = curve[i + 0];\n      var y = curve[i + 1];\n\n      // scale\n      x *= rx;\n      y *= ry;\n\n      // rotate\n      var xp = cos_phi*x - sin_phi*y;\n      var yp = sin_phi*x + cos_phi*y;\n\n      // translate\n      curve[i + 0] = xp + cc[0];\n      curve[i + 1] = yp + cc[1];\n    }\n\n    return curve;\n  });\n};\n"]},"metadata":{},"sourceType":"script"}