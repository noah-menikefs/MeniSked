{"ast":null,"code":"// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n'use strict';\n\nvar pathParse = require('./path_parse');\n\nvar transformParse = require('./transform_parse');\n\nvar matrix = require('./matrix');\n\nvar a2c = require('./a2c');\n\nvar ellipse = require('./ellipse'); // Class constructor\n//\n\n\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) {\n    return new SvgPath(path);\n  }\n\n  var pstate = pathParse(path); // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n\n  this.segments = pstate.segments; // Error message on parse error.\n\n  this.err = pstate.err; // Transforms stack for lazy evaluation\n\n  this.__stack = [];\n}\n\nSvgPath.from = function (src) {\n  if (typeof src === 'string') return new SvgPath(src);\n\n  if (src instanceof SvgPath) {\n    // Create empty object\n    var s = new SvgPath(''); // Clone properies\n\n    s.err = src.err;\n    s.segments = src.segments.map(function (sgm) {\n      return sgm.slice();\n    });\n    s.__stack = src.__stack.map(function (m) {\n      return matrix().matrix(m.toArray());\n    });\n    return s;\n  }\n\n  throw new Error('SvgPath.from: invalid param type ' + src);\n};\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this,\n      i; // Quick leave for empty matrix\n\n  if (!m.queue.length) {\n    return;\n  }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n      // Process 'assymetric' commands separately\n      case 'v':\n        p = m.calc(0, s[1], true);\n        result = p[0] === 0 ? ['v', p[1]] : ['l', p[0], p[1]];\n        break;\n\n      case 'V':\n        p = m.calc(x, s[1], false);\n        result = p[0] === m.calc(x, y, false)[0] ? ['V', p[1]] : ['L', p[0], p[1]];\n        break;\n\n      case 'h':\n        p = m.calc(s[1], 0, true);\n        result = p[1] === 0 ? ['h', p[0]] : ['l', p[0], p[1]];\n        break;\n\n      case 'H':\n        p = m.calc(s[1], y, false);\n        result = p[1] === m.calc(x, y, false)[1] ? ['H', p[0]] : ['L', p[0], p[1]];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // Drop segment if arc is empty (end point === start point)\n\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma); // flip sweep-flag if matrix is not orientation-preserving\n\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        } // Transform end point as usual (without translation for relative notation)\n\n\n        p = m.calc(s[6], s[7], s[0] === 'a'); // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n\n        if (s[0] === 'A' && s[6] === x && s[7] === y || s[0] === 'a' && s[6] === 0 && s[7] === 0) {\n          result = [s[0] === 'a' ? 'l' : 'L', p[0], p[1]];\n          break;\n        } // if the resulting ellipse is (almost) a segment ...\n\n\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [s[0] === 'a' ? 'l' : 'L', p[0], p[1]];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1]];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n        p = m.calc(s[1], s[2], isRelative);\n        result = ['m', p[0], p[1]];\n        break;\n\n      default:\n        name = s[0];\n        result = [name];\n        isRelative = name.toLowerCase() === name; // Apply transformations to the segment\n\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n\n    }\n\n    self.segments[index] = result;\n  }, true);\n}; // Apply stacked commands\n//\n\n\nSvgPath.prototype.__evaluateStack = function () {\n  var m, i;\n\n  if (!this.__stack.length) {\n    return;\n  }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n\n  this.__stack = [];\n}; // Convert processed SVG Path back to string\n//\n\n\nSvgPath.prototype.toString = function () {\n  var elements = [],\n      skipCmd,\n      cmd;\n\n  this.__evaluateStack();\n\n  for (var i = 0; i < this.segments.length; i++) {\n    // remove repeating commands names\n    cmd = this.segments[i][0];\n    skipCmd = i > 0 && cmd !== 'm' && cmd !== 'M' && cmd === this.segments[i - 1][0];\n    elements = elements.concat(skipCmd ? this.segments[i].slice(1) : this.segments[i]);\n  }\n\n  return elements.join(' ') // Optimizations: remove spaces around commands & before `-`\n  //\n  // We could also remove leading zeros for `0.5`-like values,\n  // but their count is too small to spend time for.\n  .replace(/ ?([achlmqrstvz]) ?/gi, '$1').replace(/ \\-/g, '-') // workaround for FontForge SVG importing bug\n  .replace(/zm/g, 'z m');\n}; // Translate path to (x [, y])\n//\n\n\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n\n  return this;\n}; // Scale path to (sx [, sy])\n// sy = sx if not defined\n//\n\n\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, !sy && sy !== 0 ? sx : sy));\n\n  return this;\n}; // Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\n\n\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n\n  return this;\n}; // Skew path along the X axis by `degrees` angle\n//\n\n\nSvgPath.prototype.skewX = function (degrees) {\n  this.__stack.push(matrix().skewX(degrees));\n\n  return this;\n}; // Skew path along the Y axis by `degrees` angle\n//\n\n\nSvgPath.prototype.skewY = function (degrees) {\n  this.__stack.push(matrix().skewY(degrees));\n\n  return this;\n}; // Apply matrix transform (array of 6 elements)\n//\n\n\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n\n  return this;\n}; // Transform path according to \"transform\" attr of SVG spec\n//\n\n\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n\n  this.__stack.push(transformParse(transformString));\n\n  return this;\n}; // Round coords with given decimal precition.\n// 0 by default (to integers)\n//\n\n\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0,\n      contourStartDeltaY = 0,\n      deltaX = 0,\n      deltaY = 0,\n      l;\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = s[0].toLowerCase() === s[0];\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) {\n          s[1] += deltaX;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) {\n          s[1] += deltaY;\n        }\n\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n        s.forEach(function (val, i) {\n          if (!i) {\n            return;\n          }\n\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n  return this;\n}; // Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\n\n\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = s[0] === s[0].toLowerCase(); // calculate absolute X and Y\n\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  }); // Replace segments if iterator return results\n\n  if (!needReplace) {\n    return this;\n  }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n  return this;\n}; // Converts segments from relative to absolute\n//\n\n\nSvgPath.prototype.abs = function () {\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i; // Skip absolute commands\n\n    if (name === nameUC) {\n      return;\n    }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n\n    }\n  }, true);\n  return this;\n}; // Converts segments from absolute to relative\n//\n\n\nSvgPath.prototype.rel = function () {\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i; // Skip relative commands\n\n    if (name === nameLC) {\n      return;\n    } // Don't touch the first M to avoid potential confusions.\n\n\n    if (index === 0 && name === 'M') {\n      return;\n    }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n\n    }\n  }, true);\n  return this;\n}; // Converts arcs to cubic bézier curves\n//\n\n\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var new_segments,\n        nextX,\n        nextY,\n        result = [],\n        name = s[0]; // Skip anything except arcs\n\n    if (name !== 'A' && name !== 'a') {\n      return null;\n    }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]); // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n\n    if (new_segments.length === 0) {\n      return [[s[0] === 'a' ? 'l' : 'L', s[6], s[7]]];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push(['C', s[2], s[3], s[4], s[5], s[6], s[7]]);\n    });\n    return result;\n  });\n  return this;\n}; // Converts smooth curves (with missed control point) to generic curves\n//\n\n\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY; // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        isRelative; // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n\n    if (!idx) {\n      return;\n    }\n\n    if (nameUC === 'T') {\n      // quadratic curve\n      isRelative = name === 't';\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [isRelative ? 'q' : 'Q', curControlX, curControlY, s[1], s[2]];\n    } else if (nameUC === 'S') {\n      // cubic curve\n      isRelative = name === 's';\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [isRelative ? 'c' : 'C', curControlX, curControlY, s[1], s[2], s[3], s[4]];\n    }\n  });\n  return this;\n};\n\nmodule.exports = SvgPath;","map":{"version":3,"sources":["/Users/nikhil.ismail/Desktop/MeniSked/node_modules/svgpath/lib/svgpath.js"],"names":["pathParse","require","transformParse","matrix","a2c","ellipse","SvgPath","path","pstate","segments","err","__stack","from","src","s","map","sgm","slice","m","toArray","Error","prototype","__matrix","self","i","queue","length","iterate","index","x","y","p","result","name","isRelative","calc","ma","e","transform","isDegenerate","rx","ry","ax","toLowerCase","push","__evaluateStack","toString","elements","skipCmd","cmd","concat","join","replace","translate","scale","sx","sy","rotate","angle","skewX","degrees","skewY","transformString","trim","round","d","contourStartDeltaX","contourStartDeltaY","deltaX","deltaY","l","forEach","toFixed","val","iterator","keepLazyStack","replacements","needReplace","lastX","lastY","countourStartX","countourStartY","j","newSegments","res","Array","isArray","abs","nameUC","toUpperCase","rel","nameLC","unarc","new_segments","nextX","nextY","unshort","prevControlX","prevControlY","prevSegment","curControlX","curControlY","idx","module","exports"],"mappings":"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","sourcesContent":["// SVG Path transformations library\n//\n// Usage:\n//\n//    SvgPath('...')\n//      .translate(-150, -100)\n//      .scale(0.5)\n//      .translate(-150, -100)\n//      .toFixed(1)\n//      .toString()\n//\n\n'use strict';\n\n\nvar pathParse      = require('./path_parse');\nvar transformParse = require('./transform_parse');\nvar matrix         = require('./matrix');\nvar a2c            = require('./a2c');\nvar ellipse        = require('./ellipse');\n\n\n// Class constructor\n//\nfunction SvgPath(path) {\n  if (!(this instanceof SvgPath)) { return new SvgPath(path); }\n\n  var pstate = pathParse(path);\n\n  // Array of path segments.\n  // Each segment is array [command, param1, param2, ...]\n  this.segments = pstate.segments;\n\n  // Error message on parse error.\n  this.err      = pstate.err;\n\n  // Transforms stack for lazy evaluation\n  this.__stack    = [];\n}\n\nSvgPath.from = function (src) {\n  if (typeof src === 'string') return new SvgPath(src);\n\n  if (src instanceof SvgPath) {\n    // Create empty object\n    var s = new SvgPath('');\n\n    // Clone properies\n    s.err = src.err;\n    s.segments = src.segments.map(function (sgm) { return sgm.slice(); });\n    s.__stack = src.__stack.map(function (m) {\n      return matrix().matrix(m.toArray());\n    });\n\n    return s;\n  }\n\n  throw new Error('SvgPath.from: invalid param type ' + src);\n};\n\n\nSvgPath.prototype.__matrix = function (m) {\n  var self = this, i;\n\n  // Quick leave for empty matrix\n  if (!m.queue.length) { return; }\n\n  this.iterate(function (s, index, x, y) {\n    var p, result, name, isRelative;\n\n    switch (s[0]) {\n\n      // Process 'assymetric' commands separately\n      case 'v':\n        p      = m.calc(0, s[1], true);\n        result = (p[0] === 0) ? [ 'v', p[1] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'V':\n        p      = m.calc(x, s[1], false);\n        result = (p[0] === m.calc(x, y, false)[0]) ? [ 'V', p[1] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'h':\n        p      = m.calc(s[1], 0, true);\n        result = (p[1] === 0) ? [ 'h', p[0] ] : [ 'l', p[0], p[1] ];\n        break;\n\n      case 'H':\n        p      = m.calc(s[1], y, false);\n        result = (p[1] === m.calc(x, y, false)[1]) ? [ 'H', p[0] ] : [ 'L', p[0], p[1] ];\n        break;\n\n      case 'a':\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n\n        // Drop segment if arc is empty (end point === start point)\n        /*if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          return [];\n        }*/\n\n        // Transform rx, ry and the x-axis-rotation\n        var ma = m.toArray();\n        var e = ellipse(s[1], s[2], s[3]).transform(ma);\n\n        // flip sweep-flag if matrix is not orientation-preserving\n        if (ma[0] * ma[3] - ma[1] * ma[2] < 0) {\n          s[5] = s[5] ? '0' : '1';\n        }\n\n        // Transform end point as usual (without translation for relative notation)\n        p = m.calc(s[6], s[7], s[0] === 'a');\n\n        // Empty arcs can be ignored by renderer, but should not be dropped\n        // to avoid collisions with `S A S` and so on. Replace with empty line.\n        if ((s[0] === 'A' && s[6] === x && s[7] === y) ||\n            (s[0] === 'a' && s[6] === 0 && s[7] === 0)) {\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n          break;\n        }\n\n        // if the resulting ellipse is (almost) a segment ...\n        if (e.isDegenerate()) {\n          // replace the arc by a line\n          result = [ s[0] === 'a' ? 'l' : 'L', p[0], p[1] ];\n        } else {\n          // if it is a real ellipse\n          // s[0], s[4] and s[5] are not modified\n          result = [ s[0], e.rx, e.ry, e.ax, s[4], s[5], p[0], p[1] ];\n        }\n\n        break;\n\n      case 'm':\n        // Edge case. The very first `m` should be processed as absolute, if happens.\n        // Make sense for coord shift transforms.\n        isRelative = index > 0;\n\n        p = m.calc(s[1], s[2], isRelative);\n        result = [ 'm', p[0], p[1] ];\n        break;\n\n      default:\n        name       = s[0];\n        result     = [ name ];\n        isRelative = (name.toLowerCase() === name);\n\n        // Apply transformations to the segment\n        for (i = 1; i < s.length; i += 2) {\n          p = m.calc(s[i], s[i + 1], isRelative);\n          result.push(p[0], p[1]);\n        }\n    }\n\n    self.segments[index] = result;\n  }, true);\n};\n\n\n// Apply stacked commands\n//\nSvgPath.prototype.__evaluateStack = function () {\n  var m, i;\n\n  if (!this.__stack.length) { return; }\n\n  if (this.__stack.length === 1) {\n    this.__matrix(this.__stack[0]);\n    this.__stack = [];\n    return;\n  }\n\n  m = matrix();\n  i = this.__stack.length;\n\n  while (--i >= 0) {\n    m.matrix(this.__stack[i].toArray());\n  }\n\n  this.__matrix(m);\n  this.__stack = [];\n};\n\n\n// Convert processed SVG Path back to string\n//\nSvgPath.prototype.toString = function () {\n  var elements = [], skipCmd, cmd;\n\n  this.__evaluateStack();\n\n  for (var i = 0; i < this.segments.length; i++) {\n    // remove repeating commands names\n    cmd = this.segments[i][0];\n    skipCmd = i > 0 && cmd !== 'm' && cmd !== 'M' && cmd === this.segments[i - 1][0];\n    elements = elements.concat(skipCmd ? this.segments[i].slice(1) : this.segments[i]);\n  }\n\n  return elements.join(' ')\n    // Optimizations: remove spaces around commands & before `-`\n    //\n    // We could also remove leading zeros for `0.5`-like values,\n    // but their count is too small to spend time for.\n    .replace(/ ?([achlmqrstvz]) ?/gi, '$1')\n    .replace(/ \\-/g, '-')\n    // workaround for FontForge SVG importing bug\n    .replace(/zm/g, 'z m');\n};\n\n\n// Translate path to (x [, y])\n//\nSvgPath.prototype.translate = function (x, y) {\n  this.__stack.push(matrix().translate(x, y || 0));\n  return this;\n};\n\n\n// Scale path to (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.scale = function (sx, sy) {\n  this.__stack.push(matrix().scale(sx, (!sy && (sy !== 0)) ? sx : sy));\n  return this;\n};\n\n\n// Rotate path around point (sx [, sy])\n// sy = sx if not defined\n//\nSvgPath.prototype.rotate = function (angle, rx, ry) {\n  this.__stack.push(matrix().rotate(angle, rx || 0, ry || 0));\n  return this;\n};\n\n\n// Skew path along the X axis by `degrees` angle\n//\nSvgPath.prototype.skewX = function (degrees) {\n  this.__stack.push(matrix().skewX(degrees));\n  return this;\n};\n\n\n// Skew path along the Y axis by `degrees` angle\n//\nSvgPath.prototype.skewY = function (degrees) {\n  this.__stack.push(matrix().skewY(degrees));\n  return this;\n};\n\n\n// Apply matrix transform (array of 6 elements)\n//\nSvgPath.prototype.matrix = function (m) {\n  this.__stack.push(matrix().matrix(m));\n  return this;\n};\n\n\n// Transform path according to \"transform\" attr of SVG spec\n//\nSvgPath.prototype.transform = function (transformString) {\n  if (!transformString.trim()) {\n    return this;\n  }\n  this.__stack.push(transformParse(transformString));\n  return this;\n};\n\n\n// Round coords with given decimal precition.\n// 0 by default (to integers)\n//\nSvgPath.prototype.round = function (d) {\n  var contourStartDeltaX = 0, contourStartDeltaY = 0, deltaX = 0, deltaY = 0, l;\n\n  d = d || 0;\n\n  this.__evaluateStack();\n\n  this.segments.forEach(function (s) {\n    var isRelative = (s[0].toLowerCase() === s[0]);\n\n    switch (s[0]) {\n      case 'H':\n      case 'h':\n        if (isRelative) { s[1] += deltaX; }\n        deltaX = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'V':\n      case 'v':\n        if (isRelative) { s[1] += deltaY; }\n        deltaY = s[1] - s[1].toFixed(d);\n        s[1] = +s[1].toFixed(d);\n        return;\n\n      case 'Z':\n      case 'z':\n        deltaX = contourStartDeltaX;\n        deltaY = contourStartDeltaY;\n        return;\n\n      case 'M':\n      case 'm':\n        if (isRelative) {\n          s[1] += deltaX;\n          s[2] += deltaY;\n        }\n\n        deltaX = s[1] - s[1].toFixed(d);\n        deltaY = s[2] - s[2].toFixed(d);\n\n        contourStartDeltaX = deltaX;\n        contourStartDeltaY = deltaY;\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        return;\n\n      case 'A':\n      case 'a':\n        // [cmd, rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        if (isRelative) {\n          s[6] += deltaX;\n          s[7] += deltaY;\n        }\n\n        deltaX = s[6] - s[6].toFixed(d);\n        deltaY = s[7] - s[7].toFixed(d);\n\n        s[1] = +s[1].toFixed(d);\n        s[2] = +s[2].toFixed(d);\n        s[3] = +s[3].toFixed(d + 2); // better precision for rotation\n        s[6] = +s[6].toFixed(d);\n        s[7] = +s[7].toFixed(d);\n        return;\n\n      default:\n        // a c l q s t\n        l = s.length;\n\n        if (isRelative) {\n          s[l - 2] += deltaX;\n          s[l - 1] += deltaY;\n        }\n\n        deltaX = s[l - 2] - s[l - 2].toFixed(d);\n        deltaY = s[l - 1] - s[l - 1].toFixed(d);\n\n        s.forEach(function (val, i) {\n          if (!i) { return; }\n          s[i] = +s[i].toFixed(d);\n        });\n        return;\n    }\n  });\n\n  return this;\n};\n\n\n// Apply iterator function to all segments. If function returns result,\n// current segment will be replaced to array of returned segments.\n// If empty array is returned, current regment will be deleted.\n//\nSvgPath.prototype.iterate = function (iterator, keepLazyStack) {\n  var segments = this.segments,\n      replacements = {},\n      needReplace = false,\n      lastX = 0,\n      lastY = 0,\n      countourStartX = 0,\n      countourStartY = 0;\n  var i, j, newSegments;\n\n  if (!keepLazyStack) {\n    this.__evaluateStack();\n  }\n\n  segments.forEach(function (s, index) {\n\n    var res = iterator(s, index, lastX, lastY);\n\n    if (Array.isArray(res)) {\n      replacements[index] = res;\n      needReplace = true;\n    }\n\n    var isRelative = (s[0] === s[0].toLowerCase());\n\n    // calculate absolute X and Y\n    switch (s[0]) {\n      case 'm':\n      case 'M':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        lastY = s[2] + (isRelative ? lastY : 0);\n        countourStartX = lastX;\n        countourStartY = lastY;\n        return;\n\n      case 'h':\n      case 'H':\n        lastX = s[1] + (isRelative ? lastX : 0);\n        return;\n\n      case 'v':\n      case 'V':\n        lastY = s[1] + (isRelative ? lastY : 0);\n        return;\n\n      case 'z':\n      case 'Z':\n        // That make sence for multiple contours\n        lastX = countourStartX;\n        lastY = countourStartY;\n        return;\n\n      default:\n        lastX = s[s.length - 2] + (isRelative ? lastX : 0);\n        lastY = s[s.length - 1] + (isRelative ? lastY : 0);\n    }\n  });\n\n  // Replace segments if iterator return results\n\n  if (!needReplace) { return this; }\n\n  newSegments = [];\n\n  for (i = 0; i < segments.length; i++) {\n    if (typeof replacements[i] !== 'undefined') {\n      for (j = 0; j < replacements[i].length; j++) {\n        newSegments.push(replacements[i][j]);\n      }\n    } else {\n      newSegments.push(segments[i]);\n    }\n  }\n\n  this.segments = newSegments;\n\n  return this;\n};\n\n\n// Converts segments from relative to absolute\n//\nSvgPath.prototype.abs = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameUC = name.toUpperCase(),\n        i;\n\n    // Skip absolute commands\n    if (name === nameUC) { return; }\n\n    s[0] = nameUC;\n\n    switch (name) {\n      case 'v':\n        // v has shifted coords parity\n        s[1] += y;\n        return;\n\n      case 'a':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] += x;\n        s[7] += y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] += i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts segments from absolute to relative\n//\nSvgPath.prototype.rel = function () {\n\n  this.iterate(function (s, index, x, y) {\n    var name = s[0],\n        nameLC = name.toLowerCase(),\n        i;\n\n    // Skip relative commands\n    if (name === nameLC) { return; }\n\n    // Don't touch the first M to avoid potential confusions.\n    if (index === 0 && name === 'M') { return; }\n\n    s[0] = nameLC;\n\n    switch (name) {\n      case 'V':\n        // V has shifted coords parity\n        s[1] -= y;\n        return;\n\n      case 'A':\n        // ARC is: ['A', rx, ry, x-axis-rotation, large-arc-flag, sweep-flag, x, y]\n        // touch x, y only\n        s[6] -= x;\n        s[7] -= y;\n        return;\n\n      default:\n        for (i = 1; i < s.length; i++) {\n          s[i] -= i % 2 ? x : y; // odd values are X, even - Y\n        }\n    }\n  }, true);\n\n  return this;\n};\n\n\n// Converts arcs to cubic bézier curves\n//\nSvgPath.prototype.unarc = function () {\n  this.iterate(function (s, index, x, y) {\n    var new_segments, nextX, nextY, result = [], name = s[0];\n\n    // Skip anything except arcs\n    if (name !== 'A' && name !== 'a') { return null; }\n\n    if (name === 'a') {\n      // convert relative arc coordinates to absolute\n      nextX = x + s[6];\n      nextY = y + s[7];\n    } else {\n      nextX = s[6];\n      nextY = s[7];\n    }\n\n    new_segments = a2c(x, y, nextX, nextY, s[4], s[5], s[1], s[2], s[3]);\n\n    // Degenerated arcs can be ignored by renderer, but should not be dropped\n    // to avoid collisions with `S A S` and so on. Replace with empty line.\n    if (new_segments.length === 0) {\n      return [ [ s[0] === 'a' ? 'l' : 'L', s[6], s[7] ] ];\n    }\n\n    new_segments.forEach(function (s) {\n      result.push([ 'C', s[2], s[3], s[4], s[5], s[6], s[7] ]);\n    });\n\n    return result;\n  });\n\n  return this;\n};\n\n\n// Converts smooth curves (with missed control point) to generic curves\n//\nSvgPath.prototype.unshort = function () {\n  var segments = this.segments;\n  var prevControlX, prevControlY, prevSegment;\n  var curControlX, curControlY;\n\n  // TODO: add lazy evaluation flag when relative commands supported\n\n  this.iterate(function (s, idx, x, y) {\n    var name = s[0], nameUC = name.toUpperCase(), isRelative;\n\n    // First command MUST be M|m, it's safe to skip.\n    // Protect from access to [-1] for sure.\n    if (!idx) { return; }\n\n    if (nameUC === 'T') { // quadratic curve\n      isRelative = (name === 't');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'Q') {\n        prevControlX = prevSegment[1] - x;\n        prevControlY = prevSegment[2] - y;\n      } else if (prevSegment[0] === 'q') {\n        prevControlX = prevSegment[1] - prevSegment[3];\n        prevControlY = prevSegment[2] - prevSegment[4];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'q' : 'Q',\n        curControlX, curControlY,\n        s[1], s[2]\n      ];\n\n    } else if (nameUC === 'S') { // cubic curve\n      isRelative = (name === 's');\n\n      prevSegment = segments[idx - 1];\n\n      if (prevSegment[0] === 'C') {\n        prevControlX = prevSegment[3] - x;\n        prevControlY = prevSegment[4] - y;\n      } else if (prevSegment[0] === 'c') {\n        prevControlX = prevSegment[3] - prevSegment[5];\n        prevControlY = prevSegment[4] - prevSegment[6];\n      } else {\n        prevControlX = 0;\n        prevControlY = 0;\n      }\n\n      curControlX = -prevControlX;\n      curControlY = -prevControlY;\n\n      if (!isRelative) {\n        curControlX += x;\n        curControlY += y;\n      }\n\n      segments[idx] = [\n        isRelative ? 'c' : 'C',\n        curControlX, curControlY,\n        s[1], s[2], s[3], s[4]\n      ];\n    }\n  });\n\n  return this;\n};\n\n\nmodule.exports = SvgPath;\n"]},"metadata":{},"sourceType":"script"}